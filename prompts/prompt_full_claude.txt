<introduction>
 # Introduction to Task:
Your assignment is to generate RASP (Restricted Access Sequence Processing Language) programs capable of implementing a variety of algorithms using sequence operations. RASP allows you to articulate complex sequence to sequence in a format equivalent to what a neural network of the transformer architecture can do. RASP programs always output a sequence that has the same length as the input sequence. All of it's components also have this attribute.

# Your Task
Make a RASP program that takes the absolute value of each element in the sequence.
Example: [-1, 2, -3] --> [1, 2, 3]
Name the function that you can call to make this program 'make_absolute()'


Keep your task in mind while reading this information.
</introduction>

<understanding_RASP>
# Understanding RASP:

RASP programs are unique in that they process input sequences and output transformed sequences of equivalent length. Avoid conditional branches or loops if possible. Instead, they rely on a series of operations that interpret and manipulate the input data in a sequence-to-sequence fashion.

## Fundamental Principles:

- Input and Output: Each RASP program receives an input sequence and yields an output sequence of identical length.
- Structural Linearity: No variable length loops or branches; all operations flow in a straight line. If you make loops they should have a fixed length or be dependent on a "max_sequence_length" parameter.
- Operation Calls: Programs can only invoke core RASP functions or refer to other RASP programs.

## Technical operational Jargon:

- `rasp.Select`: Matches elements from two sequences based on a comparison condition.
- `rasp.Aggregate`: takes as input a selector and an SOp (Sequence Operation, which is an operation that transforms a sequence), and produces an SOp that averages the value of the SOp weighted by the selection matrix.
- `rasp.Map` and `rasp.SequenceMap`: Transform sequence elements individually or in pairs, respectively.
- `rasp.SelectorWidth`: returns the number of "True" values in each row of a selector

<function_overview>
### Function overview:
#### Map:
Function: Applies a function element-wise on the input SOp.
Syntax: `(f: Callable[[Value], Value], inner: SOp)`
Example: `Map(lambda x: x + 1, tokens)` adds 1 to each element of tokens.

#### SequenceMap:
Function: Applies a function element-wise on two given SOps.
Syntax: `rasp.SequenceMap(f: Callable[[Value, Value], Value], fst: SOp, snd: SOp)`
Example: `rasp.SequenceMap(lambda x, y: x - y, rasp.indices, rasp.tokens)` subtracts tokens from indices.

#### Aggregate:
Function: Takes as input a selector and an SOp, and produces an SOp that averages the value of the SOp weighted by the selection matrix.
Syntax: `rasp.Aggregate(selector: Selector, sop: SOp, default: Optional[VT] = None)`
Example: `rasp.Aggregate(select_all, any_negative, default=0)` aggregates based on select_all.

#### Select:
Function: Creates a selector to define relationships between elements of sequences.
Syntax: `rasp.Select(keys: SOp, queries: SOp, predicate: Predicate)`
Example: `rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.EQ)` selects elements where indices are equal.

#### SelectorWidth:
Function: Evaluates a selector in terms of its "width", which corresponds to the number of ones/"True"s in each row.
Syntax: `rasp.SelectorWidth(selector: Selector)`
Example: `rasp.SelectorWidth(selectAll)`

#### Tokens, Indices:
Tokens: Breaks input into a sequence of elements.
Indices: Returns the position index at each token.


### Example use of above Functions:
This is a selector of tokens applied to themselves with the "Greater Than" or GT comparison operator:

```python
greater_than_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.GT).named("greater_than_selector")
```
If applied to a rasp.tokens sequence like [1, 2, 3, 4] the selector will look like this:
[False, True, True, True]
[False, False, True, True]
[False, False, False, True]
[False, False, False, False]
If we now apply this to rasp.tokens again with:
```python
output = rasp.Aggregate(greater_than_selector, rasp.tokens)
```
Note that the default should be a number, character or "none"
We will get an average of all the values selected in each row. Output looks like this:
[3, 3.5, 4, 0]
[
3, # as an average of the selected 2,3 and 4
3.5, # as an average of the selected 3 and 4
4, # as an average of the selected 4
None # because none of the values were selected as none of them are greater than 4 at this position. So None, which is always the default value takes this spot.
]
If we now call:
```python
count_GT_selector = rasp.SelectorWidth(greater_than_selector)
```
We will get a sequence that contains the count of the truth values in each row:
[3,2,1,0]
If we call:
```python
map_count_GT = rasp.Map(lambda x: x*3+1, count_GT_selector)
```
We will get a sequence where this lambda function has been applied to all the values of count_GT_selector:
[10, 7, 4, 1]

But if we call:
```python
sequenceMap_combination = rasp.SequenceMap(lambda x, y: x*y+x, count_GT_selector, output)
```
We get an output where the sequences "count_GT_selector" and "output" are combined element wise according to the lambda function.
At this point "count_GT_selector" is [3,2,1,0] and output is [3, 3.5, 4, 0] so sequenceMap_combination is [12, 9, 5, 0]
[
12, #because 3 * 3 + 3 = 12
9, #because 2 * 3.5 + 2 = 9
5, #because 1 * 4 + 1 = 5
0 #because 0 * 0 + 0 = 0
]
</function_overview>
# Rules and Constraints:
- Use provided operation types (Select, Aggregate, SelectorWidth Map, SequenceMap) as the building blocks of your program. Feel free to be creative in how to combine them but remember which kind of output (Selector or Sop) they produce.
- Each operation must be traceable and reproducible, implying a transparent translation from instructions to action.
</understanding_RASP>


<source_code>
# Source Code
To make you better understand the RASP language you can look at the following code. These are the most important parts of rasp.py. Use this as a reference to find out what kind of functions there are in RASP, which inputs they take and what they do.

```python

"""RASP program objects.

class Map(SOp):
  """SOp that evaluates the function element-wise on the input SOp.

  Map(lambda x: x + 1, tokens).eval([1, 2, 3]) == [2, 3, 4]
  """

  def __init__(
      self,
      f: Callable[[Value], Value],
      inner: SOp,
      simplify: bool = True,
  ):
    """Initialises.

    Args:
      f: the function to apply element-wise.
      inner: the SOp to which to apply `f`.
      simplify: if True and if `inner` is also a Map, will combine the new map
        and `inner` into a single Map object.
    """
    super().__init__()
    self.f = f
    self.inner = inner

    assert isinstance(self.inner, SOp)
    assert callable(self.f) and not isinstance(self.f, RASPExpr)

    if simplify and isinstance(self.inner, Map):
      # combine the functions into just one.
      inner_f = self.inner.f
      self.f = lambda t: f(inner_f(t))
      self.inner = self.inner.inner

  @property
  def children(self) -> Sequence[RASPExpr]:
    return [self.inner]


class SequenceMap(SOp):
  """SOp that evaluates the function elemen-twise on the two given SOp's.

  SequenceMap(lambda x, y: x - y, length, tokens).eval([1, 2, 3]) == [2, 1, 0]
  """

  def __init__(
      self,
      f: Callable[[Value, Value], Value],
      fst: SOp,
      snd: SOp,
  ):
    super().__init__()

    if fst == snd:
      logging.warning("Creating a SequenceMap with both inputs being the same "
                      "SOp is discouraged. You should use a Map instead.")

    self.f = f
    self.fst = fst
    self.snd = snd
    assert isinstance(self.fst, SOp)
    assert isinstance(self.snd, SOp)
    assert callable(self.f) and not isinstance(self.f, RASPExpr)

  @property
  def children(self) -> Sequence[RASPExpr]:
    return [self.fst, self.snd]


class LinearSequenceMap(SequenceMap):
  """SOp that evaluates a linear function element-wise on the two given SOp's."""

  def __init__(self, fst: SOp, snd: SOp, fst_fac: float, snd_fac: float):
    super().__init__(fst=fst, snd=snd, f=lambda x, y: fst_fac * x + snd_fac * y)
    self.fst_fac = fst_fac
    self.snd_fac = snd_fac


### Selectors.

class Comparison(enum.Enum):
  """A two-place boolean comparison predicate for use in Select."""
  EQ = "=="
  LT = "<"
  LEQ = "<="
  GT = ">"
  GEQ = ">="
  NEQ = "!="
  TRUE = "True"
  FALSE = "False"

  def __call__(self, key: Value, query: Value) -> bool:
    if key is None:
      raise ValueError("key is None!")
    if query is None:
      raise ValueError("query is None!")
    return _comparison_table[self](key, query)


_comparison_table = {
    Comparison.EQ: lambda key, query: key == query,
    Comparison.LT: lambda key, query: key < query,
    Comparison.LEQ: lambda key, query: key <= query,
    Comparison.GT: lambda key, query: key > query,
    Comparison.GEQ: lambda key, query: key >= query,
    Comparison.NEQ: lambda key, query: key != query,
    Comparison.TRUE: lambda key, query: True,
    Comparison.FALSE: lambda key, query: False,
}


class Selector(RASPExpr):
  """RASP Selector. Represents something like an attention head's weights."""

  def __call__(self, xs: Sequence[Value]) -> SelectorValue:
    return evaluate(self, xs)  # pytype: disable=bad-return-type

  # allow construction of Selector combinations using Python logical operators.
  def __and__(self, other: "Selector") -> "Selector":
    """self & other."""
    return selector_and(self, other)

  def __rand__(self, other: "Selector") -> "Selector":
    """other & self."""
    return selector_and(other, self)

  def __or__(self, other: "Selector") -> "Selector":
    """self | other."""
    return selector_or(self, other)

  def __ror__(self, other: "Selector") -> "Selector":
    """other | self."""
    return selector_or(other, self)

  def __invert__(self) -> "Selector":
    """~self."""
    return selector_not(self)


class Select(Selector):
  """Primitive that creates a Selector."""

  def __init__(self, keys: SOp, queries: SOp, predicate: Predicate):
    super().__init__()
    self.keys = keys
    self.queries = queries
    self.predicate = predicate
    assert isinstance(self.keys, SOp)
    assert isinstance(self.queries, SOp)

  @property
  def children(self) -> Sequence[RASPExpr]:
    return [self.keys, self.queries]


class ConstantSelector(Selector):
  """A constant selector for testing purposes."""

  def __init__(self, value: SelectorValue, check_length: bool = True):
    super().__init__()
    self.value = value
    self.check_length = check_length

  @property
  def children(self) -> Sequence[RASPExpr]:
    return []


class SelectorWidth(SOp):
  """SelectorWidth primitive."""

  def __init__(self, selector: Selector):
    super().__init__()
    self.selector = selector
    assert isinstance(self.selector, Selector)

  @property
  def children(self) -> Sequence[RASPExpr]:
    return [self.selector]


class SelectorAnd(Selector):
  """Implements elementwise `and` between selectors."""

  def __init__(self, fst: Selector, snd: Selector):
    super().__init__()
    self.fst = fst
    self.snd = snd
    assert isinstance(self.fst, Selector)
    assert isinstance(self.snd, Selector)

  @property
  def children(self) -> Sequence[RASPExpr]:
    return [self.fst, self.snd]


class SelectorOr(Selector):
  """Implements elementwise `or` between selectors."""

  def __init__(self, fst: Selector, snd: Selector):
    super().__init__()
    self.fst = fst
    self.snd = snd
    assert isinstance(self.fst, Selector)
    assert isinstance(self.snd, Selector)

  @property
  def children(self) -> Sequence[RASPExpr]:
    return [self.fst, self.snd]


class SelectorNot(Selector):
  """Implements elementwise `not` on a selector."""

  def __init__(self, inner: Selector):
    self.inner = inner
    super().__init__()
    assert isinstance(self.inner, Selector)

  @property
  def children(self) -> Sequence[RASPExpr]:
    return [self.inner]


def selector_not(
    inner: Selector,
    simplify: bool = True,
) -> Selector:
  """Returns a SelectorNot, or a Select if simplifying is possible."""
  if simplify and isinstance(inner, Select):
    predicate = lambda k, q: not inner.predicate(k, q)
    return Select(inner.keys, inner.queries, predicate=predicate)

  return SelectorNot(inner)


def selector_and(
    fst: Selector,
    snd: Selector,
    simplify: bool = True,
) -> Selector:
  """Returns a SelectorAnd, or a Select if simplifying is possible."""
  if simplify and isinstance(fst, Select) and isinstance(snd, Select):
    simplified = _attempt_simplify(fst, snd, lambda l, r: l and r)
    if simplified:
      return simplified

  return SelectorAnd(fst, snd)


def selector_or(
    fst: Selector,
    snd: Selector,
    simplify: bool = True,
) -> Selector:
  """Returns a SelectorOr, or a Select if simplifying is possible."""
  if simplify and isinstance(fst, Select) and isinstance(snd, Select):
    simplified = _attempt_simplify(fst, snd, lambda l, r: l or r)
    if simplified:
      return simplified

  return SelectorOr(fst, snd)


class Aggregate(SOp, Generic[VT]):
  """Aggregate primitive."""

  def __init__(self,
               selector: Selector,
               sop: SOp,
               default: Optional[VT] = None):
    """Initialises. The default is used where nothing is selected."""
    super().__init__()
    self.selector = selector
    self.sop = sop
    self.default = default
    assert isinstance(self.selector, Selector)
    assert isinstance(self.sop, SOp)
    assert (self.default is None or isinstance(self.default,
                                               (str, float, bool, int)))

  @property
  def children(self) -> Sequence[RASPExpr]:
    return [self.selector, self.sop]

```
</source_code>

<examples>
# Examples:
Below are exemplary RASP programs to guide your understanding. They are designed using the core principles of RASP programming and should serve as templates for constructing your own algorithms within the given framework. Note that you can not call these functions in your code!

```python

def make_length() -> rasp.SOp:
  """Creates the `length` SOp using selector width primitive.

  Example usage:
    length = make_length()
    length("abcdefg")
    >> [7.0, 7.0, 7.0, 7.0, 7.0, 7.0, 7.0]

  Returns:
    length: SOp mapping an input to a sequence, where every element
      is the length of that sequence.
  """
  all_true_selector = rasp.Select(
      rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named("all_true_selector")
  return rasp.SelectorWidth(all_true_selector).named("length")


length = make_length()


def make_reverse(sop: rasp.SOp) -> rasp.SOp:
  """Create an SOp that reverses a sequence, using length primitive.

  Example usage:
    reverse = make_reverse(rasp.tokens)
    reverse("Hello")
    >> ['o', 'l', 'l', 'e', 'H']

  Args:
    sop: an SOp

  Returns:
    reverse : SOp that reverses the input sequence.
  """
  opp_idx = (length - rasp.indices).named("opp_idx")
  opp_idx = (opp_idx - 1).named("opp_idx-1")
  reverse_selector = rasp.Select(rasp.indices, opp_idx,rasp.Comparison.EQ).named("reverse_selector")
  return rasp.Aggregate(reverse_selector, sop).named("reverse")



def make_hist() -> rasp.SOp:
  """Returns the number of times each token occurs in the input.

   (As implemented in the RASP paper.)

  Example usage:
    hist = make_hist()
    hist("abac")
    >> [2, 1, 2, 1]
  """
  same_tok = rasp.Select(rasp.tokens, rasp.tokens,
                         rasp.Comparison.EQ).named("same_tok")
  return rasp.SelectorWidth(same_tok).named("hist")


def make_sort_unique(vals: rasp.SOp, keys: rasp.SOp) -> rasp.SOp:
  """Returns vals sorted by < relation on keys.

  Only supports unique keys.

  Example usage:
    sort = make_sort(rasp.tokens, rasp.tokens)
    sort([2, 4, 3, 1])
    >> [1, 2, 3, 4]

  Args:
    vals: Values to sort.
    keys: Keys for sorting.
  """
  smaller = rasp.Select(keys, keys, rasp.Comparison.LT).named("smaller")
  target_pos = rasp.SelectorWidth(smaller).named("target_pos")
  sel_new = rasp.Select(target_pos, rasp.indices, rasp.Comparison.EQ)
  return rasp.Aggregate(sel_new, vals).named("sort")


def make_sort(vals: rasp.SOp, keys: rasp.SOp, *, max_seq_len: int,
              min_key: float) -> rasp.SOp:
  """Returns vals sorted by < relation on keys, which don't need to be unique.

  Example usage:
    sort = make_sort(rasp.tokens, rasp.tokens, 5, 1)
    sort([2, 4, 3, 1])
    >> [1, 2, 3, 4]
    sort([2, 4, 1, 2])
    >> [1, 2, 2, 4]

  Args:
    vals: Values to sort.
    keys: Keys for sorting.
    max_seq_len: Maximum sequence length (used to ensure keys are unique)
    min_key: Minimum key value (used to ensure keys are unique)

  Returns:
    Output SOp of sort program.
  """
  keys = rasp.SequenceMap(lambda x, i: x + min_key * i / max_seq_len, keys,
                          rasp.indices)
  return make_sort_unique(vals, keys)


def make_sort_freq(max_seq_len: int) -> rasp.SOp:
  """Returns tokens sorted by the frequency they appear in the input.

  Example usage:
    sort = make_sort_freq(rasp.tokens, rasp.tokens, 5)
    sort([2, 4, 2, 1])
    >> [2, 2, 4, 1]

  Args:
    max_seq_len: Maximum sequence length (used to ensure keys are unique)
  """
  hist = -1 * make_hist().named("hist")
  return make_sort(
      rasp.tokens, hist, max_seq_len=max_seq_len, min_key=1).named("sort_freq")


### Programs that work under both causal and regular evaluation.


def make_frac_prevs(bools: rasp.SOp) -> rasp.SOp:
  """Count the fraction of previous tokens where a specific condition was True.

  Example usage:
    num_l = make_frac_prevs(rasp.tokens=="l")
    num_l("hello")
    >> [0, 0, 1/3, 1/2, 2/5]

  Args:
    bools: SOp mapping a sequence to a sequence of booleans.

  Returns:
    frac_prevs: SOp mapping an input to a sequence, where every element
      is the fraction of previous "True" tokens.
  """
  bools = rasp.numerical(bools)
  prevs = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.LEQ)
  return rasp.numerical(rasp.Aggregate(prevs, bools,
                                       default=0)).named("frac_prevs")


def make_count_less_freq(n: int) -> rasp.SOp:
  """Returns how many tokens appear fewer than n times in the input.

  Example usage:
    count_less_freq = make_count_less_freq(2)
    count_less_freq(["a", "a", "a", "b", "b", "c"])
    >> [3, 3, 3, 3, 3, 3]
    count_less_freq(["a", "a", "c", "b", "b", "c"])
    >> [6, 6, 6, 6, 6, 6]

  Args:
    n: Integer to compare token frequences to.
  """
  hist = make_hist().named("hist")
  select_less = rasp.Select(hist, hist,
                            lambda x, y: x <= n).named("select_less")
  return rasp.SelectorWidth(select_less).named("count_less_freq")


def make_count(sop, token):
  """Returns the count of `token` in `sop`.

  Example usage:
    count = make_count(tokens, "a")
    count(["a", "a", "a", "b", "b", "c"])
    >> [3, 3, 3, 3, 3, 3]
    count(["c", "a", "b", "c"])
    >> [1, 1, 1, 1]

  Args:
    sop: Sop to count tokens in.
    token: Token to count.
  """
  return rasp.SelectorWidth(rasp.Select(
      sop, sop, lambda k, q: k == token)).named(f"count_{token}")


def make_nary_sequencemap(f, *sops):
  """Returns an SOp that simulates an n-ary SequenceMap.

  Args:
    f: Function with n arguments.
    *sops: Sequence of SOps, one for each argument of f.
  """
  values, *sops = sops
  for sop in sops:
    # x is a single entry in the first iteration but a tuple in later iterations
    values = rasp.SequenceMap(
        lambda x, y: (*x, y) if isinstance(x, tuple) else (x, y), values, sop)
  return rasp.Map(lambda args: f(*args), values)


def predecessor_difference() -> rasp.SOp:
    """
    Creates an SOp that calculates the difference between each element and its predecessor. As the first element has no predecessor, the first element of the result will be 0.
    Returns: A RASP SOp that, when executed, produces a sequence where each element is the difference from its predecessor.
    Example use:
    pred_diff = predecessor_difference()
    pred_diff([4,2,6,3,9,6])
    >>[0, -2, 4, -3, 6, -3]
    """

    # shift the input sequence by 1 to the right, and insert 0 at the beginning.
    shifted_sequence = shift_by(1, rasp.tokens, 0)

    # subtract the shifted sequence from the original sequence to get the differences.
    differences = rasp.SequenceMap(lambda x, y: x - y, rasp.tokens, shifted_sequence).named("differences")

    # select the first element of the original sequence so it can be subtracted at the start of the "differences"-sequence
    first_element_selector = rasp.Select(rasp.indices, rasp.tokens, lambda x,y: x==0)
    first_element = rasp.Aggregate(first_element_selector, rasp.tokens, default = 0)

    # create a sequence where the first entry is the negation of the first element of the original sequence and 0 everywhere else
    first_element_adjuster = rasp.SequenceMap(lambda x,y: -y if x==0 else 0, rasp.indices, first_element)
    
    # return the sum of the first_element_adjuster and the differences which just sets the first element of the differences to 0
    return differences+first_element_adjuster

def make_multiply_all_elements(max_length = 5):
    '''
    returns the product of the first n elements in a sequence where n = "max_length" (for which the default is 5) 
    Example usage:
    multiply_all_elements = make_multiply_all_elements(max_length = 5)
    multiply_all_elements([1, 2, 3, 4])
    -> results in [24, 24, 24, 24]
    where as 
    multiply_all_elements([1, 2, 3, 4, 5, 6])
    results in [120, 120, 120, 120, 120, 120]
    1 * 2 * 3 * 4 * 5 = 120 (6 is not included as it is not among the first 5 elements)
    '''
    
    first_elem = rasp.Map(lambda x: 1, rasp.indices)
    for i in range(0, max_length):
        current_element_selector = rasp.Select(
            rasp.indices, 
            rasp.rasp.Map(lambda x: I, rasp.indices),  # Creating a full sequence with value i (the current index)
            rasp.Comparison.EQ
        ).named("current_element_selector")
    
        # Aggregate the input sequence to select the current element for each position
        current_elem = rasp.Aggregate(
            current_element_selector, 
            rasp.tokens, 
            default=1
        ).named("current_elem")
        first_elem = rasp.SequenceMap(lambda x,y: x*y, first_elem, current_elem)
    return first_elem
    
def sum_all_elements() -> rasp.SOp:
    """
    Creates an SOp that returns the sum of all elements in a sequence.

    Example usage:
      sum_elements = sum_all_elements()
      sum_elements([1, 2, 3, 4])
      >> [10, 10, 10, 10]

    Returns:
      sum_elements: SOp that returns a sequence where each element is the sum of all elements.
    """
    
    # Get the length of the sequence
    length = make_length()

    # Multiply each element by the length
    multiply_by_length = rasp.SequenceMap(lambda x, y: x * y, rasp.tokens, length).named("multiply_by_length")

    # Selector that selects all elements
    select_all = rasp.Select( , rasp.indices, rasp.Comparison.TRUE).named("select_all")

    # Aggregating all multiplied elements to get their sum
    sum_elements = rasp.Aggregate(select_all, multiply_by_length).named("sum_elements")

    return sum_elements


def make_divide_by(divisor: float) -> rasp.SOp:
    """Creates an SOp that divides each element of the input sequence by a given divisor.

    Args:
      divisor: A float value by which each element of the sequence will be divided.

    Returns:
      A RASP SOp that when executed, divides each element of the input sequence by the divisor.
    """
    # Ensure that divisor is not zero to avoid division by zero errors
    if divisor == 0:
        raise ValueError("Divisor cannot be zero.")

    # Define the division operation
    def divide(element):
        return element / divisor

    # Apply the division operation to each element of the input sequence
    return rasp.Map(divide, rasp.tokens).named(f"divide_by_{divisor}")

def make_one_hot_first() -> rasp.SOp:
    """
    one-hot encodes the first element of a sequence.
    Example:
    [3,2,1,5,3,2] --> [0,0,0,1,0,0] 
    (the one is in the 4th position because 3 is the first element of the input sequence (0-based))
    Note that if the first element is negative or greater than the length of the sequence, the output will just be a sequence of only 0s.
    """
    # Select the first element of the input sequence
    first_elem_selector = rasp.Select(rasp.indices, rasp.indices, lambda x,y: x==0).named("first_elem_selector")
    first_elem = rasp.Aggregate(first_elem_selector, rasp.tokens, default=None).named("first_elem")
    # places a 1 where the index is equal to the value of the first element
    one_hot_encoded_seq = rasp.SequenceMap(lambda x,y: 1 if x==y else 0, first_elem, rasp.indices)

    return one_hot_encoded_seq


def make_one_hot_decode() -> rasp.SOp:
    """
    decodes a one hot encoded sequence. 
    Example: [0,0,0,1,0,0] --> [3,3,3,3,3,3] 
    The one is in the 4th position which means 3 is the output (0-based)
    Note that if the input is not one-hot encoded, the output will be the average position of the ones or a sequence of None, if there is no 1 in the input sequence
    """
    # Create a selector that identifies the '1' in the one-hot encoded input sequence
    select_one = rasp.Select(rasp.tokens, rasp.tokens, lambda x,y: x==1).named("select_one")

    # Broadcast the index of that position to a whole sequence
    return rasp.Aggregate(select_one, rasp.indices)

def make_max_element() -> rasp.SOp:
    # A selector comparing each element with every other element using LEQ (less than or equal)
    unique_tokens = rasp.SequenceMap(lambda x,y: x+y*0.00000000000001, rasp.tokens, rasp.indices)
    leq_selector = rasp.Select(unique_tokens, unique_tokens, rasp.Comparison.LEQ).named("leq_selector")
    # Counting the number of elements each element is less than or equal to
    leq_count = rasp.SelectorWidth(leq_selector).named("leq_count")
    # The maximum element is the one that is less or equal to all elements (count equal to sequence length)
    length_sop = make_length()
    max_element_selector = rasp.Select(leq_count, length_sop, rasp.Comparison.EQ).named("max_element_selector")
    # Using Aggregate to select the maximum element and broadcast it across the entire sequence
    max_sequence = rasp.Aggregate(max_element_selector, rasp.tokens).named("max_sequence")
    return max_sequence

def make_rescale_by_max() -> rasp.SOp:
    """
    rescales a sequence based on its max. 
    example use:
    make_rescale_by_max() applied to [3, 0, 2, 6, 10] results in [0.3,0.0,0.2,0.6,1]
    note that this implies different behaviour if the maximum is negative, 
    """
    max_elem = make_max_element()

    # Check if the max element is 0 and replace with 1 to avoid division by zero; otherwise, use the value itself.
    safe_max_elem = rasp.Map(lambda x: 1 if x == 0 else x, max_elem).named("safe_max_elem")

    # Divide each element in the sequence by this safe max element to perform the rescaling.
    rescaled_sequence = rasp.SequenceMap(lambda x, y: x / y, rasp.tokens, safe_max_elem).named("rescaled_sequence")

    return rescaled_sequence


def make_length() -> rasp.SOp:
    all_true_selector = rasp.Select(
        rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named("all_true_selector")
    return rasp.SelectorWidth(all_true_selector).named("length")


def make_min_element() -> rasp.SOp:
    unique_tokens = rasp.SequenceMap(lambda x,y: x+y*0.00000000000001, rasp.tokens, rasp.indices)
    geq_selector = rasp.Select(unique_tokens, unique_tokens, rasp.Comparison.GEQ).named("leq_selector")
    # Counting the number of elements each element is less than or equal to
    geq_count = rasp.SelectorWidth(geq_selector).named("geq_count")
    # The maximum element is the one that is less or equal to all elements (count equal to sequence length)
    length_sop = make_length()
    min_element_selector = rasp.Select(geq_count, length_sop, rasp.Comparison.EQ).named("min_element_selector")
    # Using Aggregate to select the maximum element and broadcast it across the entire sequence
    min_sequence = rasp.Aggregate(min_element_selector, rasp.tokens).named("min_sequence")
    return min_sequence

def make_rescale(new_min: float, new_max: float) -> rasp.SOp:
    """Creates an SOp that rescales a sequence to a new range given by new_min and new_max."""
    original_max_sop = make_max_element().named("original_max")
    original_min_sop = make_min_element().named("original_min")
    # Calculate the original range
    original_range_sop = rasp.SequenceMap(lambda max_val, min_val: max_val - min_val, original_max_sop, original_min_sop).named("original_range")
    # Calculate scale and shift
    norm_sop = rasp.SequenceMap(lambda x,y: x/y if y!=0 else 1, rasp.tokens - original_min_sop, original_range_sop).named("norm")
    rescaled = rasp.Map(lambda x: new_min + x * (new_max - new_min), norm_sop)
    return rescaled

def make_polynomial(degree):
    """
    Computes the result of a polynomial. The first element of the sequence is treated as the base of the polynomial,
    while the following ones are the weights.
    Example: input [3,2,3,1,4] is treated as the polynomial 2*3^3 + 3*3^2 + 1*3 + 4 = 88
    Note that the degree parameter should correspond to the length of the input sequence minus two.
    """

    aggregator = rasp.tokens - rasp.tokens
    first_element_selector = rasp.Select(rasp.indices, aggregator, rasp.Comparison.EQ).named("first_element_selector")
    base = rasp.Aggregate(first_element_selector, rasp.tokens)

    # Function to create selectors and weights
    def create_elem(i):
        selector = rasp.Select(rasp.indices, rasp.Map(lambda x: i, rasp.tokens), rasp.Comparison.EQ).named(f"selector_{i}")
        weight = rasp.Aggregate(selector, rasp.tokens, default=None).named(f"weight_{i}")
        elem = rasp.SequenceMap(lambda x, y: y * (x ** (degree + 1 - i)), base, weight)
        return rasp.SequenceMap(lambda x, y: x + y, aggregator, elem)

    # Applying the function for each term
    for i in range(1, degree + 2):
        aggregator = create_elem(i)

    return aggregator

# Define shift_by function in RASP (uses existing `Select` and `Aggregate` operations)
def shift_by(offset: int, /, sop: rasp.SOp, fill: rasp.Value) -> rasp.SOp:
    """Returns the sop, shifted by `offset`, filled with `fill` value."""
    select_off_by_offset = rasp.Select(rasp.indices, rasp.indices,
                                       lambda k, q: q == k + offset)
    out = rasp.Aggregate(select_off_by_offset, sop, default=fill)
    return out.named(f"shift_by({offset})")

# Define the rolling maximum operation
def make_rolling_max(window_size: int, fill_value: rasp.Value) -> rasp.SOp:
    """Creates an SOp that calculates the rolling maximum of the input sequence
       with a window size of `window_size` and a fill value `fill_value`."""
    if window_size <= 0:
        raise ValueError("Window size must be positive.")

    # Shift the sequence by 1 and 2, using fill_value for padding
    shifted_1 = shift_by(1, rasp.tokens, fill=fill_value).named("shifted_1")
    shifted_2 = shift_by(2, rasp.tokens, fill=fill_value).named("shifted_2")
    # Use Map and SequenceMap to calculate the maximum for each element
    max_1 = rasp.SequenceMap(lambda x, y: max(x, y), rasp.tokens, shifted_1).named("max_1")
    rolling_max = rasp.SequenceMap(lambda x, y: max(x, y), max_1, shifted_2).named("rolling_max")

    return rolling_max

def make_elementwise_product_of_half_sequence() -> rasp.SOp:
    """
    creates SOp that devides the sequence into it's first and second halves. and then multiplies these sequences element-wise.
    Note this only works for sequences with an even number. For sequences with odd numbers the middle element will be included in both sequences.

    Example use:
    elementwise_product_of_half_sequence = make_elementwise_product_of_half_sequence()
    elementwise_product_of_half_sequence([1,2,3,4,5,6])
    >>[4,4,10,10,18,18] # this is the element wise product of the first half ([1,1,2,2,3,3]) and the second half ([4,4,5,5,6,6])
    """
    # Create a sequence of indices for the input sequence
    indices = rasp.indices.named("indices")
    
    # Create a sequence containing the length of the sequence like in make_lenght() 
    all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named("all_true_selector")
    length = rasp.SelectorWidth(all_true_selector).named("length")
    
    # Generate the reversed indices by subtracting the current index from the sequence length and then subtract 1
    reversed_indices = (length - indices - 1).named("reversed_indices")

    # Create a selection matrix where each position corresponds to the reversed index position
    reverse_selector = rasp.Select(indices, reversed_indices, rasp.Comparison.EQ).named("reverse_selector")
    
    # Aggregate the original sequence according to the reversed indices to create the reversed sequence
    reversed_sequence = rasp.Aggregate(reverse_selector, rasp.tokens).named("reversed_sequence")

    # Create a selector for the indices that are less than half the sequence length
    first_half_selector = rasp.Select(rasp.indices, rasp.indices, lambda y,x: y * 2 - 1 < x <= y * 2 + 1).named("first_half_selector")

    # get the first half of the original tokens
    first_half = rasp.Aggregate(first_half_selector, rasp.tokens, default=None).named("duplicated_sequence")

    # get the second half by taking the first half of the original sequence
    # create a new selector so for uneven number of elements the first element is only included once instead of the last so [1,2,3,4,5] --> [1,2,2,3,3] instead of [1,1,2,2,3]
    first_half_selector_rev = rasp.Select(rasp.indices, rasp.indices, lambda y,x: y * 2 - 1 <= x < y * 2 + 1).named("first_half_selector_rev")
    
    # apply the selector to the reversed sequence with aggregate to get the second half (which is still in the reversed state)
    second_half_reversed = rasp.Aggregate(first_half_selector, reversed_sequence, default=None).named("second_half_reversed")

    # reverse the second half again to get it in the correct order:    
    second_half = rasp.Aggregate(reverse_selector, second_half_reversed).named("second_half")
    
    # multiply the first and the second half element-wise
    output = rasp.SequenceMap(lambda x,y: x*y, first_half, second_half)
    
    # return the result
    return  output

def make_check_even() -> rasp.SOp:
    # Function to check if each element in the sequence is even or odd
    # 1 for even numbers (remainder of division by 2 is 0)
    # 0 for odd numbers (remainder of division by 2 is not 0)
    return rasp.Map(lambda x: 1 if x % 2 == 0 else 0, rasp.tokens).named("check_even")

```
</examples>

<example_use_of_functions>
# Example use of Functions:
This is a selector of tokens applied to themselves with the "Greater Than" or GT comparison operator:

```python
greater_than_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.GT).named("greater_than_selector")
```
If applied to a rasp.tokens sequence like [1, 2, 3, 4], the selector will look like this:
[False, True, True, True]
[False, False, True, True]
[False, False, False, True]
[False, False, False, False]
If we now apply this to rasp.tokens again with:
```python
output = rasp.Aggregate(greater_than_selector, rasp.tokens)
```
Note that the default should be a number, character or "none"
We will get an average of all the values selected in each row. Output looks like this:
[3, 3.5, 4, 0]
[
3, # as an average of the selected 2,3 and 4
3.5, # as an average of the selected 3 and 4
4, # as an average of the selected 4
None # because none of the values were selected as none of them are greater than 4 at this position. So None, which is always the default value takes this spot.
]
If we now call:
```python
count_GT_selector = rasp.SelectorWidth(greater_than_selector)
```
We will get a sequence that contains the count of the truth values in each row:
[3,2,1,0]
If we call:
```python
map_count_GT = rasp.Map(lambda x: x*3+1, count_GT_selector)
```
We will get a sequence where this lambda function has been applied to all the values of count_GT_selector:
[10, 7, 4, 1]

But if we call:
```python
sequenceMap_combination = rasp.SequenceMap(lambda x, y: x*y+x, count_GT_selector, output)
```
We get an output where the sequences "count_GT_selector" and "output" are combined element wise according to the lambda function.
At this point "count_GT_selector" is [3,2,1,0] and output is [3, 3.5, 4, 0] so sequenceMap_combination is [12, 9, 5, 0]
[
12, #because 3 * 3 + 3 = 12
9, #because 2 * 3.5 + 2 = 9
5, #because 1 * 4 + 1 = 5
0 #because 0 * 0 + 0 = 0
]
</example_use_of_functions>


Start your process by looking at the examples and the RASP language basics then write down a plan based on the information in the files and the examples above and then write your program.
If your plan includes the usage of certain functions, look up all of the allowed parameters for said functions, write them down before you start writing the program and make sure you do not make up any new parameters to any of the RASP functions.
Note that you are not allowed to use the above examples as functions in your code. If you want to call functions like `make_length()` or `shift_by()` you have to rewrite them in your output code.

<output_format>
# Output Format
When giving an answer, use the following Format:

<Task>
[Reiterate your understanding of the task and add an example of an input and the desired output.]
</Task>

<Plan>
[Your plan on how the program should broadly work.]
[Some details on which functions you'll have to use and what their inputs will be.]
</Plan>

<PlanVerification>
[Look back at your plan. Will this really work? Is this compatible with the functionality of the functions you're using? Are you using your functions correctly? (Look at the source code to verify this) Answer these questions here explicitly]
[List changes you have to make to the plan based on your verification]
</PlanVerification>

```python
[write out your RASP-python code in a code block here]
```
</output_format>

### Example Use of Format:

Here is an example of how you might use this output format:

<Task>
The task is to create a RASP program that takes a sequence and returns a new sequence of identical length where each element is the maximum value found in the original sequence.

For example:
max = make_max()
max([1,2,6,-2,1]) # returns [6,6,6,6,6]
</Task>

<Plan>
1. Create a selector that compares each element with every other element using a "Less Than or Equal" (LEQ) comparison.
2. Use SelectorWidth to count the number of elements that each element is less than or equal to.
3. The maximum element will have a count equal to the length of the sequence, so create a selector that selects the elements where the count from step 2 equals the length of the sequence.
4. Use Aggregate with the selector from step 3 to broadcast the maximum element across the entire sequence.

The functions we will use include:
- Select: for creating the comparison selector.
- SelectorWidth: for counting the number of comparisons that are true for each element.
- Map: for creating a sequence of the sequence length.
- Aggregate: for selecting and broadcasting the maximum element.
</Plan>

<PlanVerification>
The plan seems feasible and aligns with the capabilities of the RASP functions:
- The Select operation can create a comparison matrix that identifies where each element is less than or equal to every other element.
- SelectorWidth can count the number of True comparisons for each element.
- Map can create a sequence where each element is the length of the sequence.
- Aggregate can then broadcast the maximum element where the comparison count equals the sequence length.

There are no changes needed for the plan based on verification.
</PlanVerification>

```python
def make_max() -> rasp.SOp:
    # Selector that creates a comparison matrix where each element is compared to every other element.
    leq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LEQ).named("leq_selector")

    # Count the number of comparisons where each element is less than or equal to other elements.
    leq_count = rasp.SelectorWidth(leq_selector).named("leq_count")

    # Create a Map to get the sequence length for each element.
    sequence_length = rasp.Map(lambda x: len(x), rasp.tokens).named("sequence_length")

    # Selector that selects the element where the leq_count equals the sequence_length.
    max_element_selector = rasp.Select(leq_count, sequence_length, rasp.Comparison.EQ).named("max_element_selector")

    # Use Aggregate to broadcast the maximum element across the entire sequence.
    max_sequence = rasp.Aggregate(max_element_selector, rasp.tokens).named("max_sequence")

    return max_sequence
```

<your_task>
# Your Task
Make a RASP program that takes the absolute value of each element in the sequence.
Example: [-1, 2, -3] --> [1, 2, 3]
Name the function that you can call to make this program 'make_absolute()'
</your_task>

<guidelines>
Examples provided are starting points; use them to grasp the syntax and structure required for RASP. From there, your original programs should follow these established patterns but are not limited to the examples' specific functions.

Keep in mind:
- Adhere strictly to RASP's core operations.
- Keep your programs simple, if possible. (E.g. For identity just return rasp.tokens instead of rasp.Map(lambda x: x, rasp.tokens)
- Meticulously comment your code for clarity.
- Output functional, executable Python code utilizing RASP's parameters.
- Don't import any additional packages. Write pure RASP code.
- Provide functional complete Python code, not pseudo code or placeholders.

Also Note:
- Do not import rasp. It is already imported. You should also not try to import the rasp components individually.
- Aggregate functions should always have None as the default. (Which means you should leave the default as is). This is because we want to compile these functions later which only works with a default of None.
- Again: do not use any functions from the example without defining them yourself. You cannot assume any function from the examples is already defined.
- If your `make_x()` functions have additional parameters like `make_x(n)` or `make_x(threshold)`, you should always have a default value like `make_x(threshold = 2)`
- Avoid the `rasp.Full()` functionality. It will prevent compiling. Instead of `rasp.Full(n)`` use the following function: `rasp.Map(lambda x: n, rasp.indices)`
</guidelines>
Endeavor to follow these guidelines to construct accurate and efficient RASP programs. Your expertise in Python will be fundamental to this task, so make sure that your code is both clean and precise, adhering to the RASP principles.