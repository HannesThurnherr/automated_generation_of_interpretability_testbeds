{
    "successes": {
        "make_sum_digits": [
            "def make_sum_digits() -> rasp.SOp:\n    def sum_digits(num):\n        # Convert the number to its absolute value to handle negative numbers\n        num = abs(num)\n        # Convert to integer to handle floating-point numbers\n        num = int(num)\n        # Calculate the sum of digits\n        total = 0\n        while num > 0:\n            total += num % 10\n            num //= 10\n        return total\n\n    # Apply the sum_digits function to each element in the sequence\n    return rasp.Map(sum_digits, rasp.tokens).named(\"sum_digits\")"
        ],
        "make_absolute": [
            "def make_absolute() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that takes the absolute value of each element in the sequence.\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that computes the absolute value of each element.\n    \n    Example:\n    absolute = make_absolute()\n    absolute([-1, 2, -3, 0, 4, -5]) # returns [1, 2, 3, 0, 4, 5]\n    \"\"\"\n    # Use Map to apply the abs() function to each element of the input sequence\n    return rasp.Map(lambda x: abs(x), rasp.tokens).named(\"absolute_value\")"
        ],
        "make_first_element": [
            "def make_first_element() -> rasp.SOp:\n    # Create a selector that selects only the first element (index 0)\n    first_element_selector = rasp.Select(\n        rasp.indices,  # keys: the indices of the sequence\n        rasp.Map(lambda x: 0, rasp.indices),  # queries: a sequence of zeros\n        rasp.Comparison.EQ  # predicate: equality comparison\n    ).named(\"first_element_selector\")\n\n    # Use Aggregate to broadcast the first element across the entire sequence\n    first_element_sequence = rasp.Aggregate(\n        first_element_selector,  # selector: our first element selector\n        rasp.tokens,  # sop: the original sequence\n        default=None  # default value (not used in this case, but required)\n    ).named(\"first_element_sequence\")\n\n    return first_element_sequence"
        ],
        "make_nth_fibonacci": [],
        "make_count_greater_than": [
            "def make_count_greater_than() -> rasp.SOp:\n    # Create a selector that compares each element with every other element\n    # using the \"Greater Than\" (GT) comparison\n    gt_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.GT).named(\"gt_selector\")\n\n    # Use SelectorWidth to count the number of elements greater than each element\n    # This directly gives us the desired output\n    count_greater = rasp.SelectorWidth(gt_selector).named(\"count_greater\")\n\n    return count_greater"
        ],
        "make_double_first_half": [],
        "make_decrement": [
            "def make_decrement() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that decrements each element in the input sequence by 1.\n    \n    Returns:\n        rasp.SOp: A RASP sequence operation that, when executed, decrements each element of the input sequence by 1.\n    \n    Example:\n        decrement = make_decrement()\n        decrement([2, 3, 4]) # returns [1, 2, 3]\n    \"\"\"\n    # Apply the decrement operation to each element in the input sequence\n    decrement = rasp.Map(lambda x: x - 1, rasp.tokens).named(\"decrement\")\n    \n    return decrement"
        ],
        "make_count_frequency": [
            "def make_count_frequency() -> rasp.SOp:\n    # Create a selector that compares each element with every other element for equality\n    equal_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.EQ).named(\"equal_selector\")\n    \n    # Count the number of equal elements for each element in the sequence\n    frequency_count = rasp.SelectorWidth(equal_selector).named(\"frequency_count\")\n    \n    return frequency_count"
        ],
        "make_increment_by_index": [
            "def make_increment_by_index() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that increments each element by its index.\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that, when applied to a sequence,\n              returns a new sequence where each element is incremented by its index.\n    \n    Example:\n    increment_by_index = make_increment_by_index()\n    increment_by_index([1, 1, 1, 1]) # returns [1, 2, 3, 4]\n    \"\"\"\n    # Use SequenceMap to add each element (from tokens) to its index\n    return rasp.SequenceMap(lambda x, y: x + y, rasp.tokens, rasp.indices).named(\"increment_by_index\")"
        ],
        "make_decrement_to_multiple_of_three": [
            "def make_decrement_to_multiple_of_three() -> rasp.SOp:\n    def decrement_step(sequence):\n        # Check if each element is a multiple of 3\n        is_multiple_of_three = rasp.Map(lambda x: x % 3 == 0, sequence).named(\"is_multiple_of_three\")\n        \n        # Decrement elements that are not multiples of 3\n        decremented = rasp.SequenceMap(\n            lambda x, y: x if y else x - 1,\n            sequence,\n            is_multiple_of_three\n        ).named(\"decremented\")\n        \n        return decremented\n\n    # Apply the decrement step multiple times\n    result = rasp.tokens\n    for _ in range(3):  # Repeat 3 times, which should be sufficient for most practical inputs\n        result = decrement_step(result)\n\n    return result.named(\"decrement_to_multiple_of_three\")"
        ],
        "make_hyperbolic_cosine": [],
        "make_check_fibonacci": [
            "def make_check_fibonacci() -> rasp.SOp:\n    def is_perfect_square(n):\n        root = int(n**0.5)\n        return root * root == n\n\n    def is_fibonacci(n):\n        return is_perfect_square(5*n*n + 4) or is_perfect_square(5*n*n - 4)\n\n    # Map each element to 1 if it's Fibonacci, 0 otherwise\n    return rasp.Map(lambda x: 1 if is_fibonacci(x) else 0, rasp.tokens).named(\"check_fibonacci\")"
        ],
        "make_square_root": [
            "def make_square_root() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that takes the square root of each element in the input sequence.\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that calculates the square root of each element.\n    \n    Example use:\n    square_root = make_square_root()\n    square_root([1, 4, 9, 16, 25]) # returns [1.0, 2.0, 3.0, 4.0, 5.0]\n    \"\"\"\n    # Use Map to apply the square root operation to each element\n    return rasp.Map(lambda x: x ** 0.5, rasp.tokens).named(\"square_root\")"
        ],
        "make_increment_odd_indices": [],
        "make_hyperbolic_tangent": [],
        "make_hyperbolic_sine": [],
        "make_zero_every_third": [],
        "make_element_second": [],
        "make_mirror_first_half": [],
        "make_sorting": [
            "def make_sorting() -> rasp.SOp:\n    # Create unique elements by adding a small fraction of the index to each element\n    unique_elements = rasp.SequenceMap(\n        lambda x, y: x + y * 1e-10,  # Add a very small fraction of the index\n        rasp.tokens,\n        rasp.indices\n    ).named(\"unique_elements\")\n\n    # Selector that creates a comparison matrix where each element is compared to every other element\n    lt_selector = rasp.Select(\n        unique_elements,\n        unique_elements,\n        rasp.Comparison.LT\n    ).named(\"lt_selector\")\n\n    # Count the number of elements less than each element\n    lt_count = rasp.SelectorWidth(lt_selector).named(\"lt_count\")\n\n    # Selector that matches each element's count to its index\n    position_selector = rasp.Select(\n        lt_count,\n        rasp.indices,\n        rasp.Comparison.EQ\n    ).named(\"position_selector\")\n\n    # Use Aggregate to place each element in its sorted position\n    sorted_sequence = rasp.Aggregate(\n        position_selector,\n        rasp.tokens\n    ).named(\"sorted_sequence\")\n\n    return sorted_sequence"
        ],
        "make_increment": [
            "def make_increment() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that increments each element in the input sequence by 1.\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that, when applied to a sequence, \n              returns a new sequence where each element is incremented by 1.\n    \n    Example:\n    increment = make_increment()\n    increment([1, 2, 3]) # returns [2, 3, 4]\n    \"\"\"\n    # Use Map to apply the increment operation to each element\n    return rasp.Map(lambda x: x + 1, rasp.tokens).named(\"increment\")"
        ],
        "make_rank": [
            "def make_rank() -> rasp.SOp:\n    # Selector that creates a comparison matrix where each element is compared to every other element.\n    # We use LT (less than) here to count how many elements are smaller than each element.\n    lt_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LT).named(\"lt_selector\")\n\n    # Count the number of elements that are less than each element.\n    lt_count = rasp.SelectorWidth(lt_selector).named(\"lt_count\")\n\n    # Add 1 to each count to get the final rank.\n    # We add 1 because ranks typically start from 1, not 0.\n    rank = rasp.Map(lambda x: x + 1, lt_count).named(\"rank\")\n\n    return rank"
        ],
        "make_factorial": [],
        "make_count_less_than": [
            "def make_count_less_than() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that replaces each element with the number of elements less than it in the sequence.\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that counts elements less than each element.\n    \n    Example:\n    count_less_than = make_count_less_than()\n    count_less_than([4, 1, 3, 2]) # returns [3, 0, 2, 1]\n    \"\"\"\n    # Create a selector that compares each element with every other element\n    # using the \"Less Than\" (LT) comparison\n    lt_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LT).named(\"lt_selector\")\n    \n    # Use SelectorWidth to count the number of elements less than each element\n    count_less_than = rasp.SelectorWidth(lt_selector).named(\"count_less_than\")\n    \n    return count_less_than"
        ],
        "make_cube_each_element": [
            "def make_cube_each_element() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that cubes each element in the input sequence.\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that, when applied to a sequence,\n              returns a new sequence where each element is the cube of the\n              corresponding element in the input sequence.\n    \"\"\"\n    # Use Map to apply the cubing operation to each element\n    return rasp.Map(lambda x: x * x * x, rasp.tokens).named(\"cube_each_element\")"
        ],
        "make_cube_root": [
            "def make_cube_root() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that computes the cube root of each element in the input sequence.\n    \n    Returns:\n        A RASP SOp that, when executed, produces a sequence where each element\n        is the cube root of the corresponding element in the input sequence.\n    \"\"\"\n    def cube_root(x):\n        # Handle negative numbers by taking the cube root of the absolute value\n        # and then reapplying the sign\n        return (abs(x) ** (1/3)) * (-1 if x < 0 else 1)\n    \n    return rasp.Map(cube_root, rasp.tokens).named(\"cube_root\")"
        ],
        "make_round": [
            "def make_round() -> rasp.SOp:\n    def custom_round(x):\n        # Handle the special case of .5\n        if abs(x - round(x)) == 0.5:\n            return int(x + (0 if x < 0 else 1))\n        else:\n            return int(round(x))\n    \n    # Apply the custom rounding function to each element\n    return rasp.Map(custom_round, rasp.tokens).named(\"round_to_nearest_int\")"
        ],
        "make_multiply_by_length": [
            "def make_multiply_by_length() -> rasp.SOp:\n    # Create a selector that selects all elements\n    all_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_selector\")\n    \n    # Calculate the length of the sequence\n    length = rasp.SelectorWidth(all_selector).named(\"length\")\n    \n    # Create a sequence where each element is the length of the input sequence\n    length_sequence = rasp.Map(lambda x: x, length).named(\"length_sequence\")\n    \n    # Multiply each element of the input sequence by the length\n    result = rasp.SequenceMap(lambda x, y: x * y, rasp.tokens, length_sequence).named(\"result\")\n    \n    return result\n\n# Example usage:\n# multiply_by_length = make_multiply_by_length()\n# multiply_by_length([1, 2, 3])  # returns [3, 6, 9]"
        ],
        "make_increment_to_multiple_of_three": [
            "def make_increment_to_multiple_of_three() -> rasp.SOp:\n    # Calculate the number of increments needed to reach the next multiple of 3\n    increments_needed = rasp.Map(\n        lambda x: (3 - x % 3) % 3,\n        rasp.tokens\n    ).named(\"increments_needed\")\n    \n    # Add the calculated increments to the original elements\n    result = rasp.SequenceMap(\n        lambda x, y: x + y,\n        rasp.tokens,\n        increments_needed\n    ).named(\"result\")\n    \n    return result"
        ],
        "make_sign": [
            "def make_sign() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that determines the sign of each element in a sequence.\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that transforms an input sequence into a \n              sequence of signs (-1 for negative, 0 for zero, 1 for positive).\n    \"\"\"\n    # Use Map to apply a sign-determining function to each element\n    return rasp.Map(\n        lambda x: -1 if x < 0 else (0 if x == 0 else 1),\n        rasp.tokens\n    ).named(\"sign_sequence\")"
        ],
        "make_cosine": [],
        "make_divide_by_length": [
            "def make_divide_by_length() -> rasp.SOp:\n    # Create a selector that selects all elements in the sequence\n    all_selector = rasp.Select(\n        rasp.tokens, rasp.tokens, rasp.Comparison.TRUE\n    ).named(\"all_selector\")\n    \n    # Calculate the length of the sequence\n    length = rasp.SelectorWidth(all_selector).named(\"length\")\n    \n    # Divide each element by the length\n    # Note: SequenceMap will automatically broadcast the length to match the shape of rasp.tokens\n    divide_by_length = rasp.SequenceMap(\n        lambda x, y: x / y if y != 0 else None,  # Avoid division by zero\n        rasp.tokens,\n        length\n    ).named(\"divide_by_length\")\n    \n    return divide_by_length"
        ],
        "make_negation": [
            "def make_negation() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that negates each element in the input sequence.\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that, when executed, negates each element of the input sequence.\n    \n    Example:\n    negation = make_negation()\n    negation([1, -2, 3, 0, -5]) # returns [-1, 2, -3, 0, 5]\n    \"\"\"\n    # Use Map to apply negation to each element\n    negated_sequence = rasp.Map(lambda x: -x, rasp.tokens).named(\"negated_sequence\")\n    \n    return negated_sequence"
        ],
        "make_sine": [
            "def make_sine() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that applies the sine function to each element of the input sequence.\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that applies sine to each element.\n    \n    Example:\n    sine = make_sine()\n    sine([0, \u03c0/2, \u03c0]) # returns [0, 1, 0]\n    \"\"\"\n    # Apply the sine function to each element using Map\n    return rasp.Map(lambda x: __import__('math').sin(x), rasp.tokens).named(\"sine\")"
        ],
        "make_histogram": [
            "def make_histogram() -> rasp.SOp:\n    # Create a selector that compares each element with every other element for equality\n    equality_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.EQ).named(\"equality_selector\")\n    \n    # Count the number of equal elements for each position, which gives us the frequency\n    histogram = rasp.SelectorWidth(equality_selector).named(\"histogram\")\n    \n    return histogram"
        ],
        "make_element_double": [
            "def make_element_double() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP SOp that doubles each element in the input sequence.\n    \n    Returns:\n    rasp.SOp: A sequence operation that, when applied to a sequence, \n              returns a new sequence with each element doubled.\n    \n    Example:\n    double = make_element_double()\n    double([1, 2, 3]) # returns [2, 4, 6]\n    \"\"\"\n    # Use Map to apply the doubling operation to each element\n    return rasp.Map(lambda x: x * 2, rasp.tokens).named(\"element_double\")"
        ],
        "make_zero_even_indices": [],
        "make_tangent": [],
        "make_count_occurrences": [
            "def make_count_occurrences() -> rasp.SOp:\n    # Create a selector that compares each element with every other element\n    # using an \"Equal\" (EQ) comparison.\n    equal_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.EQ).named(\"equal_selector\")\n\n    # Use SelectorWidth to count the number of elements that are equal to each element\n    # (including itself). This gives us the count of occurrences for each element.\n    occurrence_count = rasp.SelectorWidth(equal_selector).named(\"occurrence_count\")\n\n    # Return the count of occurrences\n    return occurrence_count"
        ],
        "make_compute_median": [],
        "make_halve_second_half": [],
        "make_triple": [
            "def make_triple() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP SOp that triples each element in the input sequence.\n    \n    Returns:\n    rasp.SOp: A sequence operation that, when applied to an input sequence,\n              returns a new sequence where each element is tripled.\n    \n    Example:\n    triple = make_triple()\n    triple([1, 2, 3]) # returns [3, 6, 9]\n    \"\"\"\n    return rasp.Map(lambda x: x * 3, rasp.tokens).named(\"triple\")"
        ],
        "make_arctangent": [
            "import math\n\ndef make_arctangent(infinity_threshold: float = 1e9) -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that applies the arctangent function to each element of the input sequence.\n    \n    Args:\n        infinity_threshold (float): The threshold above which numbers are considered to approximate infinity.\n                                    Default is 1e9.\n    \n    Returns:\n        rasp.SOp: A RASP sequence operation that applies arctangent to each element.\n    \"\"\"\n    def arctangent(x):\n        if x == 0:\n            return 0\n        elif abs(x) >= infinity_threshold:\n            return math.copysign(math.pi / 2, x)\n        else:\n            return math.atan(x)\n    \n    return rasp.Map(arctangent, rasp.tokens).named(\"arctangent\")"
        ],
        "make_square_each_element": [
            "def make_square_each_element() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that squares each element in the input sequence.\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that, when applied to a sequence,\n              returns a new sequence where each element is the square of the \n              corresponding element in the input sequence.\n    \"\"\"\n    # Use Map to apply a squaring operation to each element of the input sequence\n    return rasp.Map(lambda x: x * x, rasp.tokens).named(\"square_each_element\")"
        ],
        "make_check_power_of_n": [
            "import math\n\ndef make_check_power_of_n(n: int = 2) -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that checks if each element in a sequence is a power of n.\n    \n    Args:\n    n (int): The base number to check powers of. Default is 2.\n    \n    Returns:\n    rasp.SOp: A RASP program that returns 1 for elements that are powers of n, and 0 otherwise.\n    \"\"\"\n    \n    def is_power_of_n(x):\n        # Check if x is 1 (n^0) or n (n^1)\n        if x == 1 or x == n:\n            return 1\n        # Check if x is a positive integer\n        if x <= 0 or not float(x).is_integer():\n            return 0\n        # Use logarithm to check if x is a power of n\n        log_n = math.log(x, n)\n        return 1 if math.isclose(log_n, round(log_n)) else 0\n\n    # Apply the is_power_of_n function to each element in the input sequence\n    return rasp.Map(is_power_of_n, rasp.tokens).named(f\"check_power_of_{n}\")"
        ],
        "make_binarize": [
            "def make_binarize(threshold: float = 3) -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that binarizes elements based on a threshold.\n    \n    Args:\n    threshold (float): The threshold for binarization. Default is 3.\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that binarizes the input sequence.\n    \n    Example:\n    binarize = make_binarize()\n    binarize([1, 4, 3, 2]) # returns [0, 1, 1, 0]\n    \"\"\"\n    \n    # Use Map to apply the binarization function to each element\n    return rasp.Map(\n        lambda x: 1 if x >= threshold else 0,\n        rasp.tokens\n    ).named(f\"binarize_threshold_{threshold}\")"
        ],
        "make_average_first_last": [
            "def make_average_first_last() -> rasp.SOp:\n    # Create a selector for the first element (index 0)\n    first_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == 0).named(\"first_selector\")\n    \n    # Create a selector for the last element\n    # We need to create a length operation first\n    def make_length() -> rasp.SOp:\n        all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n        return rasp.SelectorWidth(all_true_selector).named(\"length\")\n    \n    length = make_length()\n    last_selector = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\"last_selector\")\n    \n    # Extract the first and last elements\n    first_element = rasp.Aggregate(first_selector, rasp.tokens, default=None).named(\"first_element\")\n    last_element = rasp.Aggregate(last_selector, rasp.tokens, default=None).named(\"last_element\")\n    \n    # Calculate the average of first and last elements\n    average = rasp.SequenceMap(lambda x, y: (x + y) / 2, first_element, last_element).named(\"average\")\n    \n    return average"
        ],
        "make_check_increasing": [],
        "make_identity": [
            "def make_identity() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that returns the same sequence as the input.\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that implements the identity function.\n    \n    Example:\n    identity = make_identity()\n    identity([1, 2, 3]) # returns [1, 2, 3]\n    \"\"\"\n    # Use Map to apply the identity function (lambda x: x) to each element of the input sequence\n    return rasp.Map(lambda x: x, rasp.tokens).named(\"identity\")"
        ],
        "make_apply_threshold": [
            "def make_apply_threshold(threshold: float = 3) -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that applies a threshold to a sequence,\n    setting elements below the threshold to zero.\n    \n    Args:\n    threshold (float): The threshold value. Default is 3.\n    \n    Returns:\n    rasp.SOp: A RASP program that applies the threshold.\n    \"\"\"\n    # Create a constant sequence of the threshold value\n    threshold_sequence = rasp.Map(lambda x: threshold, rasp.indices).named(\"threshold_sequence\")\n    \n    # Compare each element with the threshold\n    comparison = rasp.SequenceMap(\n        lambda x, y: x >= y,\n        rasp.tokens,\n        threshold_sequence\n    ).named(\"comparison\")\n    \n    # Apply the threshold: keep original value if >= threshold, else set to 0\n    thresholded = rasp.SequenceMap(\n        lambda x, y: x if y else 0,\n        rasp.tokens,\n        comparison\n    ).named(\"thresholded\")\n    \n    return thresholded\n\n# Example usage:\n# apply_threshold = make_apply_threshold()\n# result = apply_threshold([1, 4, 2, 5, 3])  # returns [0, 4, 0, 5, 3]"
        ],
        "make_replace_small_tokens": [],
        "make_swap_odd_index": [],
        "make_check_descending": [],
        "make_rotate_left": [
            "def make_rotate_left() -> rasp.SOp:\n    # Get the length of the sequence\n    def make_length() -> rasp.SOp:\n        all_true_selector = rasp.Select(\n            rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n        return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n    length = make_length()\n\n    # Create indices for circular shift\n    circular_indices = rasp.SequenceMap(\n        lambda i, l: (i + 1) % l if l > 0 else i,\n        rasp.indices,\n        length\n    ).named(\"circular_indices\")\n\n    # Create a selector for the circular shift\n    shift_selector = rasp.Select(\n        rasp.indices,\n        circular_indices,\n        rasp.Comparison.EQ\n    ).named(\"shift_selector\")\n\n    # Use Aggregate to perform the left rotation\n    rotated_sequence = rasp.Aggregate(\n        shift_selector,\n        rasp.tokens,\n        default=None\n    ).named(\"rotated_sequence\")\n\n    return rotated_sequence"
        ],
        "make_remove_duplicates": [
            "def make_remove_duplicates() -> rasp.SOp:\n    # Create a selector that identifies duplicate elements\n    duplicate_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.EQ).named(\"duplicate_selector\")\n\n    # Count the number of occurrences of each element\n    occurrence_count = rasp.SelectorWidth(duplicate_selector).named(\"occurrence_count\")\n\n    # Create the final sequence where duplicates are replaced with 0\n    remove_duplicates = rasp.SequenceMap(\n        lambda x, count: x if count == 1 else 0,\n        rasp.tokens,\n        occurrence_count\n    ).named(\"remove_duplicates\")\n\n    return remove_duplicates"
        ],
        "make_scale_by_max": [],
        "make_sum_with_next": [],
        "make_swap_elements": [],
        "make_one_if_equal_to_next": [],
        "make_swap_consecutive": [],
        "make_check_palindrome": [],
        "make_next_prime": [
            "def make_next_prime() -> rasp.SOp:\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def next_prime(n):\n        if is_prime(n):\n            return n\n        next_num = n + 1\n        while not is_prime(next_num):\n            next_num += 1\n        return next_num\n\n    return rasp.Map(lambda x: next_prime(x), rasp.tokens).named(\"next_prime\")"
        ],
        "make_mask_sequence": [],
        "make_wrap": [
            "def make_wrap(range_min: float = 2, range_max: float = 7) -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that wraps each element of the input sequence within the specified range.\n    \n    Args:\n    range_min (float): The lower bound of the range (default is 2).\n    range_max (float): The upper bound of the range (default is 7).\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that wraps the input sequence within the specified range.\n    \"\"\"\n    # Calculate the range size\n    range_size = range_max - range_min\n\n    # Define the wrapping operation\n    def wrap(x):\n        # Shift, wrap, and shift back in one operation\n        return ((x - range_min) % range_size) + range_min\n\n    # Apply the wrapping operation to each element in the sequence\n    wrapped_sequence = rasp.Map(wrap, rasp.tokens).named(\"wrapped_sequence\")\n\n    return wrapped_sequence"
        ],
        "make_alternate_elements": [],
        "make_check_last_two_equal": [],
        "make_insert_zeros": [],
        "make_last_element": [],
        "make_difference_to_next": [],
        "make_invert_if_sorted": [],
        "make_logarithm": [],
        "make_product_with_next": [],
        "make_check_multiple_of_first": [],
        "make_sum_of_last_two": [],
        "make_pairwise_sum": [],
        "make_polynomial": [],
        "make_flip_halves": [],
        "make_arcsine": [],
        "make_check_divisibility": [
            "def make_check_divisibility(parameter: int = 3) -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that checks if each number in a sequence is divisible by the given parameter.\n    \n    Args:\n    parameter (int): The number to check divisibility against. Default is 3.\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that transforms the input sequence into a sequence of 1's and 0's,\n              where 1 indicates the number is divisible by the parameter, and 0 indicates it is not.\n    \"\"\"\n    # Use Map to apply the divisibility check to each element\n    return rasp.Map(\n        lambda x: 1 if x % parameter == 0 else 0,\n        rasp.tokens\n    ).named(f\"check_divisibility_by_{parameter}\")"
        ],
        "make_arccosine": [],
        "make_check_all_equal": [
            "def make_length() -> rasp.SOp:\n    \"\"\"Creates the `length` SOp using selector width primitive.\"\"\"\n    all_true_selector = rasp.Select(\n        rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\ndef make_check_all_equal() -> rasp.SOp:\n    \"\"\"\n    Creates an SOp that checks whether all elements in the input sequence are equal.\n    Returns a sequence of 1's if all elements are equal, and 0's otherwise.\n    \"\"\"\n    # Create a selector that compares each element with every other element\n    equal_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.EQ).named(\"equal_selector\")\n\n    # Count the number of elements each element is equal to\n    equal_count = rasp.SelectorWidth(equal_selector).named(\"equal_count\")\n\n    # Get the length of the sequence\n    length = make_length()\n\n    # Compare the count of equal elements with the sequence length\n    all_equal = rasp.SequenceMap(lambda x, y: x == y, equal_count, length).named(\"all_equal\")\n\n    # Convert boolean result to 1 (True) or 0 (False)\n    return rasp.Map(lambda x: 1 if x else 0, all_equal).named(\"check_all_equal\")"
        ],
        "make_position": [],
        "make_set_to_median": [],
        "make_swap_min_max": [],
        "make_clip": [
            "def make_clip(lower_bound: float = 2, upper_bound: float = 7) -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that clips each element of the input sequence to be within the specified range.\n    \n    Args:\n    lower_bound (float): The lower bound of the clipping range. Default is 2.\n    upper_bound (float): The upper bound of the clipping range. Default is 7.\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that clips the input sequence.\n    \"\"\"\n    def clip_function(x):\n        return max(lower_bound, min(x, upper_bound))\n    \n    # Apply the clipping function to each element of the input sequence\n    clipped_sequence = rasp.Map(clip_function, rasp.tokens).named(\"clipped_sequence\")\n    \n    return clipped_sequence\n\n# Example usage:\n# clip = make_clip()  # Uses default range [2, 7]\n# clip([1, 5, 8, 0, 3, 10])  # Would return [2, 5, 7, 2, 3, 7]\n\n# Custom range example:\n# clip_custom = make_clip(0, 5)  # Uses range [0, 5]\n# clip_custom([1, 5, 8, -2, 3, 6])  # Would return [1, 5, 5, 0, 3, 5]"
        ],
        "make_pairwise_max": [],
        "make_check_alternating": [],
        "make_exponential": [],
        "make_interleave_reverse": [],
        "make_element_divide": [],
        "make_set_to_index": [],
        "make_check_multiple_of_n": [],
        "make_swap_first_last": [],
        "make_test_at_least_two_equal": [
            "def make_test_at_least_two_equal() -> rasp.SOp:\n    # Create a selector that compares each element with every other element\n    eq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.EQ).named(\"eq_selector\")\n\n    # Count the number of elements each element is equal to\n    eq_count = rasp.SelectorWidth(eq_selector).named(\"eq_count\")\n\n    # Subtract 1 from each count (as each element is equal to itself)\n    adjusted_count = rasp.Map(lambda x: x - 1, eq_count).named(\"adjusted_count\")\n\n    # Convert counts to 1 if >= 1, 0 otherwise\n    binary_count = rasp.Map(lambda x: 1 if x >= 1 else 0, adjusted_count).named(\"binary_count\")\n\n    # Create a selector to identify where binary_count is 1\n    has_equal_selector = rasp.Select(binary_count, rasp.Map(lambda x: 1, rasp.tokens), rasp.Comparison.EQ).named(\"has_equal_selector\")\n\n    # Count how many elements have at least one other equal element\n    equal_elements_count = rasp.SelectorWidth(has_equal_selector).named(\"equal_elements_count\")\n\n    # Check if the count is greater than 0\n    at_least_two_equal = rasp.Map(lambda x: 1 if x > 0 else 0, equal_elements_count).named(\"at_least_two_equal\")\n\n    # Broadcast the result across the entire sequence\n    result = rasp.Aggregate(rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE), at_least_two_equal, default=None).named(\"result\")\n\n    return result"
        ],
        "make_reflect": [
            "def make_reflect(lower_bound: float = 2, upper_bound: float = 7) -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that reflects each element within the given range.\n    \n    Args:\n    lower_bound (float): The lower bound of the range (default: 2)\n    upper_bound (float): The upper bound of the range (default: 7)\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that reflects input values into the specified range\n    \"\"\"\n    \n    def reflect_value(x):\n        \"\"\"Helper function to reflect a single value into the range.\"\"\"\n        range_size = upper_bound - lower_bound\n        if x < lower_bound:\n            offset = lower_bound - x\n            return lower_bound + (offset % range_size)\n        elif x > upper_bound:\n            offset = x - upper_bound\n            return upper_bound - (offset % range_size)\n        else:\n            return x\n\n    return rasp.Map(reflect_value, rasp.tokens).named(\"reflect\")"
        ],
        "make_check_square": [
            "def make_check_square() -> rasp.SOp:\n    def is_square(x):\n        # Check if x is a non-negative integer\n        if not isinstance(x, int) or x < 0:\n            return 0\n        # Check if x is a perfect square\n        root = int(x ** 0.5)\n        return 1 if root * root == x else 0\n\n    # Apply the is_square function to each element in the input sequence\n    return rasp.Map(is_square, rasp.tokens).named(\"check_square\")"
        ],
        "make_count_prime_factors": [],
        "make_zero_if_less_than_previous": [],
        "make_element_subtract_constant": [
            "def make_element_subtract_constant(constant: float = 2) -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that subtracts a constant from each element of the input sequence.\n    \n    Args:\n        constant (float): The value to subtract from each element. Defaults to 2.\n    \n    Returns:\n        rasp.SOp: A RASP sequence operation that subtracts the constant from each element.\n    \"\"\"\n    # Use Map to apply the subtraction operation to each element\n    return rasp.Map(lambda x: x - constant, rasp.tokens).named(f\"subtract_{constant}\")"
        ],
        "make_check_prime": [],
        "make_index_parity": []
    },
    "failures": {
        "make_sum_digits": [],
        "make_absolute": [],
        "make_first_element": [],
        "make_nth_fibonacci": [
            {
                "generated rasp code": "def make_nth_fibonacci(max_length: int = 20) -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that replaces each element with the nth Fibonacci number.\n    \n    Args:\n        max_length (int): The maximum length of the Fibonacci sequence to generate.\n    \n    Returns:\n        rasp.SOp: A RASP program that replaces each element with the nth Fibonacci number.\n    \"\"\"\n    \n    # Generate Fibonacci sequence\n    def fib_generator(x, prev_values):\n        if x <= 1:\n            return x\n        else:\n            return prev_values[-1] + prev_values[-2]\n    \n    fib_sequence = rasp.Map(fib_generator, rasp.indices).named(\"fib_sequence\")\n    \n    # Create a selector for valid indices (non-negative and within max_length)\n    valid_selector = rasp.Select(\n        rasp.tokens,\n        rasp.Map(lambda x: max_length - 1, rasp.tokens),\n        lambda x, y: 0 <= x <= y\n    ).named(\"valid_selector\")\n    \n    # Select the corresponding Fibonacci numbers\n    fib_selector = rasp.Select(\n        rasp.tokens,\n        rasp.indices,\n        rasp.Comparison.EQ\n    ).named(\"fib_selector\")\n    \n    # Combine the valid selector and fib selector\n    combined_selector = (valid_selector & fib_selector).named(\"combined_selector\")\n    \n    # Replace each element with its corresponding Fibonacci number\n    nth_fibonacci = rasp.Aggregate(combined_selector, fib_sequence).named(\"nth_fibonacci\")\n    \n    # Handle invalid inputs (negative or too large) by replacing them with 0\n    result = rasp.SequenceMap(\n        lambda x, y: y if y is not None else 0,\n        rasp.tokens,\n        nth_fibonacci\n    ).named(\"result\")\n    \n    return result",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_nth_fibonacci(max_length=20) -> rasp.SOp:\n    # Initialize the first two Fibonacci numbers\n    fib_seq = rasp.Map(lambda x: 1 if x < 2 else 0, rasp.indices).named(\"initial_fib\")\n\n    # Generate subsequent Fibonacci numbers\n    for _ in range(2, max_length):\n        fib_seq = rasp.SequenceMap(\n            lambda x, y: x + y,\n            fib_seq,\n            rasp.Map(lambda x: x, fib_seq).named(\"shifted_fib\")\n        ).named(\"fib_seq\")\n\n    # Create a selector to choose the correct Fibonacci numbers\n    fib_selector = rasp.Select(\n        rasp.indices,\n        rasp.tokens,\n        rasp.Comparison.EQ\n    ).named(\"fib_selector\")\n\n    # Replace input sequence with selected Fibonacci numbers\n    return rasp.Aggregate(fib_selector, fib_seq).named(\"nth_fibonacci\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0.0, None, 0.0, 262144.0, 0.0, 0.0]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_nth_fibonacci(max_length=20) -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that replaces each element with the nth Fibonacci number.\n    \n    Args:\n    max_length (int): The maximum length of the Fibonacci sequence to generate.\n    \n    Returns:\n    rasp.SOp: A RASP program that transforms input sequences into Fibonacci sequences.\n    \"\"\"\n    \n    # Create a sequence of indices\n    indices = rasp.indices.named(\"indices\")\n    \n    # Create the Fibonacci sequence\n    def fib(prev, curr, idx):\n        return curr if idx <= 1 else prev + curr\n    \n    fib_sequence = rasp.SequenceMap(\n        lambda x, y: fib(x, y, indices),\n        rasp.Map(lambda x: 0 if x == 0 else 1, indices),\n        rasp.Map(lambda x: 1, indices)\n    ).named(\"fib_sequence\")\n    \n    # Create a selector to choose the correct Fibonacci numbers\n    fib_selector = rasp.Select(\n        rasp.tokens,\n        indices,\n        lambda x, y: (x == y) and (x >= 0) and (x < max_length)\n    ).named(\"fib_selector\")\n    \n    # Replace input elements with selected Fibonacci numbers\n    fib_result = rasp.Aggregate(fib_selector, fib_sequence).named(\"fib_result\")\n    \n    # Handle edge cases: input <= 0 or input >= max_length\n    edge_case_handler = rasp.Map(\n        lambda x: 0 if x <= 0 else (fib_sequence[max_length-1] if x >= max_length else x),\n        rasp.tokens\n    ).named(\"edge_case_handler\")\n    \n    # Combine results\n    final_result = rasp.SequenceMap(\n        lambda x, y: y if x is None else x,\n        fib_result,\n        edge_case_handler\n    ).named(\"final_result\")\n    \n    return final_result\n\n# Usage:\n# fibonacci = make_nth_fibonacci()\n# result = fibonacci([1, 2, 3, 4, 5])  # returns [1, 1, 2, 3, 5]",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, 1.0, 1.0, 1.0, 1.0, 1.0]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_nth_fibonacci(max_length=20) -> rasp.SOp:\n    # Create a sequence of Fibonacci numbers\n    def fib_seq(x, y):\n        if x == 0:\n            return 0\n        elif x == 1:\n            return 1\n        else:\n            return y\n\n    fibonacci = rasp.SequenceMap(fib_seq, rasp.indices, \n                                 rasp.Map(lambda x: x-1, rasp.indices)).named(\"fibonacci\")\n    \n    # Create a selector to match input values with Fibonacci sequence indices\n    selector = rasp.Select(rasp.indices, rasp.tokens, rasp.Comparison.EQ).named(\"selector\")\n    \n    # Replace input sequence with corresponding Fibonacci numbers\n    return rasp.Aggregate(selector, fibonacci).named(\"nth_fibonacci\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [2.0, None, 1.0, 1.0, 4.0, 3.0]. (0.975 error rate)"
            },
            {
                "generated rasp code": "def make_nth_fibonacci(max_fib: int = 20) -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that replaces each element with the nth Fibonacci number.\n    \n    Args:\n        max_fib (int): The maximum Fibonacci number to generate (default is 20).\n    \n    Returns:\n        rasp.SOp: A RASP program that replaces each element with the nth Fibonacci number.\n    \"\"\"\n    # Initialize the first two Fibonacci numbers\n    fib_init = rasp.Map(lambda x: 1 if x < 2 else 0, rasp.indices).named(\"fib_init\")\n    \n    # Generate the Fibonacci sequence\n    fib_sequence = fib_init\n    for _ in range(2, max_fib):\n        fib_sequence = rasp.SequenceMap(\n            lambda x, y: x + y,\n            fib_sequence,\n            rasp.Map(lambda x: x, fib_sequence)  # Shift the sequence by one\n        ).named(\"fib_sequence\")\n    \n    # Create a selector to pick the correct Fibonacci number for each input\n    fib_selector = rasp.Select(\n        rasp.tokens,\n        rasp.indices,\n        rasp.Comparison.EQ\n    ).named(\"fib_selector\")\n    \n    # Use Aggregate to select the correct Fibonacci number based on the input\n    return rasp.Aggregate(fib_selector, fib_sequence).named(\"nth_fibonacci\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, 0.0, 0.0, 262144.0, 0.0, 0.0]. (1.0 error rate)"
            }
        ],
        "make_count_greater_than": [],
        "make_double_first_half": [
            {
                "generated rasp code": "def make_double_first_half() -> rasp.SOp:\n    # Create a sequence representing the length of the input\n    length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"length\")\n    \n    # Create a selector for the first half of the sequence\n    # For odd lengths, this will automatically round up\n    first_half_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: x / 2, length),\n        rasp.Comparison.LT\n    ).named(\"first_half_selector\")\n    \n    # Double the selected elements\n    doubled_first_half = rasp.SequenceMap(\n        lambda x, y: x * 2 if y else x,\n        rasp.tokens,\n        first_half_selector\n    ).named(\"doubled_first_half\")\n    \n    return doubled_first_half",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_double_first_half() -> rasp.SOp:\n    # Calculate the length of the sequence\n    all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    length = rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n    # Calculate the index of the middle element (rounded up for odd lengths)\n    middle_index = rasp.Map(lambda x: (x + 1) // 2, length).named(\"middle_index\")\n\n    # Create a selector for the first half of the sequence\n    first_half_selector = rasp.Select(rasp.indices, middle_index, rasp.Comparison.LT).named(\"first_half_selector\")\n\n    # Double the elements in the first half\n    doubled_first_half = rasp.SequenceMap(lambda x, y: x * 2 if y else x, rasp.tokens, first_half_selector).named(\"doubled_first_half\")\n\n    # Combine the doubled first half with the unchanged second half\n    result = rasp.Aggregate(first_half_selector, doubled_first_half, default=None).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_double_first_half() -> rasp.SOp:\n    # Create a selector that selects all elements (used for determining sequence length)\n    all_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_selector\")\n    \n    # Determine the sequence length\n    length = rasp.SelectorWidth(all_selector).named(\"length\")\n    \n    # Create a selector for the first half of the sequence (rounding up for odd lengths)\n    first_half_selector = rasp.Select(\n        rasp.indices,\n        length,\n        lambda idx, len: idx < (len + 1) // 2\n    ).named(\"first_half_selector\")\n    \n    # Double the selected elements\n    doubled_first_half = rasp.SequenceMap(\n        lambda x, sel: x * 2 if sel else x,\n        rasp.tokens,\n        first_half_selector\n    ).named(\"doubled_first_half\")\n    \n    return doubled_first_half",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_double_first_half() -> rasp.SOp:\n    # Calculate the length of the sequence\n    all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    length = rasp.SelectorWidth(all_true_selector).named(\"length\")\n    \n    # Create a selector for the first half of the sequence (rounded up for odd lengths)\n    first_half_selector = rasp.Select(\n        rasp.indices,\n        length,\n        lambda x, y: x < (y + 1) / 2\n    ).named(\"first_half_selector\")\n\n    # Double the selected elements\n    doubled_first_half = rasp.Map(lambda x: x * 2, rasp.tokens).named(\"doubled_first_half\")\n\n    # Combine the doubled first half with the unchanged second half\n    result = rasp.SequenceMap(\n        lambda x, y: x if y else z,\n        doubled_first_half,\n        first_half_selector,\n        rasp.tokens\n    ).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            },
            {
                "generated rasp code": "def make_double_first_half() -> rasp.SOp:\n    # Calculate the length of the sequence\n    all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    length = rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n    # Calculate the midpoint (rounding up for odd lengths)\n    midpoint = rasp.Map(lambda x: (x + 1) // 2, length).named(\"midpoint\")\n\n    # Create a selector for the first half of the sequence\n    first_half_selector = rasp.Select(rasp.indices, midpoint, rasp.Comparison.LT).named(\"first_half_selector\")\n\n    # Double the selected elements\n    doubled_first_half = rasp.SequenceMap(lambda x, y: x * 2 if y else x, \n                                          rasp.tokens, \n                                          first_half_selector).named(\"doubled_first_half\")\n\n    return doubled_first_half",
                "failure stage": 0,
                "error": ""
            }
        ],
        "make_decrement": [],
        "make_count_frequency": [],
        "make_increment_by_index": [],
        "make_decrement_to_multiple_of_three": [
            {
                "generated rasp code": "def make_decrement_to_multiple_of_three(max_iterations: int = 100) -> rasp.SOp:\n    def is_multiple_of_three(x):\n        return x % 3 == 0\n\n    def decrement_step(tokens):\n        # Check if each element is a multiple of 3\n        is_multiple = rasp.Map(is_multiple_of_three, tokens).named(\"is_multiple\")\n        \n        # Create a sequence of 1s for decrementing\n        ones = rasp.Map(lambda x: 1, tokens).named(\"ones\")\n        \n        # Decrement elements that are not multiples of 3\n        decremented = rasp.SequenceMap(lambda x, y: x - y, tokens, ones).named(\"decremented\")\n        \n        # Select elements that are already multiples of 3\n        selector = rasp.Select(is_multiple, is_multiple, rasp.Comparison.EQ).named(\"selector\")\n        \n        # Combine original multiples of 3 with decremented non-multiples\n        return rasp.Aggregate(selector, tokens, default=None) + rasp.Aggregate(~selector, decremented, default=None)\n\n    result = rasp.tokens\n    for _ in range(max_iterations):\n        result = decrement_step(result)\n\n    return result.named(\"decrement_to_multiple_of_three\")",
                "failure stage": 1,
                "error": "Unsupported type for aggregation: [6.0, 6.0, 6.0, 6.0, 6.0]"
            },
            {
                "generated rasp code": "def make_decrement_to_multiple_of_three() -> rasp.SOp:\n    def decrement_step(sop: rasp.SOp) -> rasp.SOp:\n        # Check if each element is a multiple of 3\n        is_multiple_of_three = rasp.Map(lambda x: x % 3 == 0, sop).named(\"is_multiple_of_three\")\n        \n        # Create a selector for elements that are not multiples of 3\n        not_multiple_selector = rasp.Select(is_multiple_of_three, is_multiple_of_three, lambda x, y: not x).named(\"not_multiple_selector\")\n        \n        # Decrement the non-multiples of 3\n        decremented = rasp.Map(lambda x: x - 1, sop).named(\"decremented\")\n        \n        # Use the selector to keep original values for multiples of 3 and decremented values for others\n        return rasp.Aggregate(not_multiple_selector, decremented, default=None).named(\"decremented_step\")\n\n    # Apply the decrement step twice\n    step1 = decrement_step(rasp.tokens).named(\"step1\")\n    step2 = decrement_step(step1).named(\"step2\")\n\n    return step2\n\n# Example usage:\n# decrement_to_multiple_of_three = make_decrement_to_multiple_of_three()\n# result = decrement_to_multiple_of_three([2, 3, 4, 7, 9, 11])\n# This would return [0, 3, 3, 6, 9, 9]",
                "failure stage": 1,
                "error": "Unsupported type for aggregation: [1.25, 1.25, 1.25, 1.25, 1.25, 1.25, 1.25, 1.25]"
            }
        ],
        "make_hyperbolic_cosine": [
            {
                "generated rasp code": "def make_exp_approximation(terms=10):\n    \"\"\"\n    Creates an SOp that approximates e^x using a Taylor series expansion.\n    \n    Args:\n    terms (int): Number of terms to use in the Taylor series (default is 10)\n    \n    Returns:\n    rasp.SOp: An SOp that approximates e^x for each element in the input sequence\n    \"\"\"\n    def factorial(n):\n        if n == 0 or n == 1:\n            return 1\n        return n * factorial(n - 1)\n    \n    def exp_taylor_term(x, n):\n        return x**n / factorial(n)\n    \n    exp_approx = rasp.tokens  # Start with x^0 / 0! = 1\n    for i in range(1, terms):\n        term = rasp.Map(lambda x: exp_taylor_term(x, i), rasp.tokens)\n        exp_approx = rasp.SequenceMap(lambda x, y: x + y, exp_approx, term)\n    \n    return exp_approx.named(\"exp_approximation\")\n\ndef make_hyperbolic_cosine() -> rasp.SOp:\n    \"\"\"\n    Creates an SOp that applies the hyperbolic cosine function to each element of the input sequence.\n    \n    Returns:\n    rasp.SOp: An SOp that calculates the hyperbolic cosine for each element in the input sequence\n    \"\"\"\n    # Create the exponential approximation SOp\n    exp_approx = make_exp_approximation()\n    \n    # Calculate cosh(x) = (e^x + e^(-x)) / 2\n    def cosh(x):\n        pos_exp = exp_approx(x)\n        neg_exp = exp_approx(-x)\n        return (pos_exp + neg_exp) / 2\n    \n    return rasp.Map(cosh, rasp.tokens).named(\"hyperbolic_cosine\")",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_hyperbolic_cosine() -> rasp.SOp:\n    def exp(x):\n        \"\"\"Approximation of exponential function using Taylor series.\"\"\"\n        result = 1.0\n        term = 1.0\n        for i in range(1, 100):  # Using 100 terms for approximation\n            term *= x / i\n            result += term\n            if abs(term) < 1e-10:  # Stop if the term becomes very small\n                break\n        return result\n\n    def cosh(x):\n        \"\"\"Calculate hyperbolic cosine using exp function.\"\"\"\n        return (exp(x) + exp(-x)) / 2\n\n    return rasp.Map(cosh, rasp.tokens).named(\"hyperbolic_cosine\")",
                "failure stage": 4,
                "error": "ground truth: ['BOS', 74.20994852478785, 10.067661995777765, 74.20994852478785, 1490.479161252178, 1490.479161252178] model output: ['BOS', 74.20994852478424, 10.067661995777302, 74.20994852478424, 1490.4791612521753, 1490.4791612521753] for [5, 3, 5, 8, 8]"
            },
            {
                "generated rasp code": "def make_hyperbolic_cosine() -> rasp.SOp:\n    def exp_approx(x):\n        # Approximate e^x using Taylor series up to 4th term\n        return 1 + x + (x**2)/2 + (x**3)/6 + (x**4)/24\n\n    def cosh_approx(x):\n        # Approximate cosh(x) using the definition and our exp approximation\n        return (exp_approx(x) + exp_approx(-x)) / 2\n\n    # Apply the approximate hyperbolic cosine function to each element\n    return rasp.Map(lambda x: cosh_approx(x), rasp.tokens).named(\"hyperbolic_cosine\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [8.875, 203.66666666666666, 3.6666666666666665, 1.5416666666666665, 39.54166666666667, 19.666666666666664]. (0.989 error rate)"
            },
            {
                "generated rasp code": "def make_hyperbolic_cosine() -> rasp.SOp:\n    def approximate_exp(x):\n        # Approximate e^x using the first 5 terms of its Taylor series\n        return 1 + x + (x**2)/2 + (x**3)/6 + (x**4)/24 + (x**5)/120\n\n    def hyperbolic_cosine(x):\n        # Calculate cosh(x) = (e^x + e^(-x)) / 2\n        return (approximate_exp(x) + approximate_exp(-x)) / 2\n\n    # Apply the hyperbolic cosine function to each element of the input sequence\n    return rasp.Map(lambda x: hyperbolic_cosine(x), rasp.tokens).named(\"hyperbolic_cosine\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [8.875, 203.66666666666663, 3.6666666666666665, 1.5416666666666665, 39.54166666666667, 19.666666666666664]. (0.989 error rate)"
            },
            {
                "generated rasp code": "def make_exp() -> rasp.SOp:\n    \"\"\"\n    Creates an SOp that approximates the exponential function e^x using a Taylor series expansion.\n    The approximation uses the first 10 terms of the series.\n    \"\"\"\n    def factorial(n):\n        if n == 0 or n == 1:\n            return 1\n        return n * factorial(n - 1)\n\n    def exp_approx(x):\n        result = 1.0\n        for n in range(1, 10):  # Using first 10 terms of the series\n            result += (x ** n) / factorial(n)\n        return result\n\n    return rasp.Map(exp_approx, rasp.tokens).named(\"exp_approximation\")\n\ndef make_hyperbolic_cosine() -> rasp.SOp:\n    \"\"\"\n    Creates an SOp that applies the hyperbolic cosine function to each element of the input sequence.\n    \"\"\"\n    exp = make_exp()\n\n    def cosh(x):\n        ex = exp(x)\n        e_minus_x = exp(rasp.Map(lambda y: -y, rasp.tokens))\n        return rasp.SequenceMap(lambda a, b: (a + b) / 2, ex, e_minus_x)\n\n    return cosh(rasp.tokens).named(\"hyperbolic_cosine\")",
                "failure stage": 0,
                "error": "'TokensType' object is not iterable"
            }
        ],
        "make_check_fibonacci": [
            {
                "generated rasp code": "def make_check_fibonacci(max_fib: int = 20) -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that checks if each element in the input sequence is a Fibonacci number.\n    \n    Args:\n        max_fib (int): The number of Fibonacci numbers to generate for comparison (default: 20).\n    \n    Returns:\n        rasp.SOp: A RASP program that returns 1 for Fibonacci numbers and 0 for non-Fibonacci numbers.\n    \"\"\"\n    # Generate the first 'max_fib' Fibonacci numbers\n    fib = [0, 1]\n    for i in range(2, max_fib):\n        fib.append(fib[i-1] + fib[i-2])\n    \n    # Create a constant sequence of Fibonacci numbers\n    fib_sequence = rasp.Map(lambda x: fib[x] if x < len(fib) else None, rasp.indices).named(\"fib_sequence\")\n    \n    # Create a selector that checks if each input element is equal to any Fibonacci number\n    is_fib_selector = rasp.Select(rasp.tokens, fib_sequence, rasp.Comparison.EQ).named(\"is_fib_selector\")\n    \n    # Count how many times each input element matches a Fibonacci number (should be 0 or 1)\n    fib_match_count = rasp.SelectorWidth(is_fib_selector).named(\"fib_match_count\")\n    \n    # Map the result to 1 if the count is greater than 0, and 0 otherwise\n    is_fibonacci = rasp.Map(lambda x: 1 if x > 0 else 0, fib_match_count).named(\"is_fibonacci\")\n    \n    return is_fibonacci\n\n# Example usage:\n# fibonacci_checker = make_check_fibonacci()\n# result = fibonacci_checker([1, 4, 5])  # Should return [1, 0, 1]",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0, 1, 1, 1, 1, 1]. (0.893 error rate)"
            }
        ],
        "make_square_root": [],
        "make_increment_odd_indices": [
            {
                "generated rasp code": "def make_increment_odd_indices() -> rasp.SOp:\n    # Create a selector for odd indices\n    odd_indices_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: 0, rasp.indices),  # Create a sequence of zeros\n        lambda x, y: x % 2 == 1  # Select odd indices\n    ).named(\"odd_indices_selector\")\n\n    # Create a sequence of 1's with the same length as the input\n    ones = rasp.Map(lambda x: 1, rasp.indices).named(\"ones\")\n\n    # Use SequenceMap to add 1 to elements at odd indices\n    incremented = rasp.SequenceMap(\n        lambda x, y: x + y,\n        rasp.tokens,\n        rasp.Aggregate(odd_indices_selector, ones, default=None)\n    ).named(\"incremented\")\n\n    return incremented",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [4.0, 9.0, 3.0, 2.0, 6.0, 5.0]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_increment_odd_indices() -> rasp.SOp:\n    # Create a selector for odd indices\n    odd_indices_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: 0, rasp.indices),\n        lambda x, y: x % 2 == 1\n    ).named(\"odd_indices_selector\")\n\n    # Create a sequence of 1's\n    ones = rasp.Map(lambda x: 1, rasp.indices).named(\"ones\")\n\n    # Use Aggregate to add 1 to elements at odd indices\n    increment = rasp.Aggregate(odd_indices_selector, ones, default=None).named(\"increment\")\n\n    # Add the increment to the original sequence\n    result = rasp.SequenceMap(\n        lambda x, y: x + y if y is not None else x,\n        rasp.tokens,\n        increment\n    ).named(\"result\")\n\n    return result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [4.0, 9.0, 3.0, 2.0, 6.0, 5.0]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_increment_odd_indices() -> rasp.SOp:\n    # Create a selector for odd indices\n    # An index is odd if index % 2 == 1\n    odd_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 1).named(\"odd_selector\")\n\n    # Create a sequence of 1's at odd indices and 0's at even indices\n    increment_sequence = rasp.Map(lambda x: 1 if x else 0, odd_selector).named(\"increment_sequence\")\n\n    # Add the increment sequence to the original sequence\n    incremented_sequence = rasp.SequenceMap(lambda x, y: x + y, rasp.tokens, increment_sequence).named(\"incremented_sequence\")\n\n    return incremented_sequence",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_increment_odd_indices() -> rasp.SOp:\n    # Create a selector for odd indices\n    odd_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: 1, rasp.indices),\n        lambda x, y: x % 2 == 1\n    ).named(\"odd_selector\")\n\n    # Create an increment sequence (1 for odd indices, 0 for even indices)\n    increment_sequence = rasp.Aggregate(odd_selector, rasp.Map(lambda x: 1, rasp.indices), default=0).named(\"increment_sequence\")\n\n    # Add the increment sequence to the original sequence\n    incremented_sequence = rasp.SequenceMap(\n        lambda x, y: x + y,\n        rasp.tokens,\n        increment_sequence\n    ).named(\"incremented_sequence\")\n\n    return incremented_sequence\n\n# Example usage:\n# increment_odd = make_increment_odd_indices()\n# result = increment_odd([1, 2, 3, 4, 5, 6])\n# print(result)  # Output: [1, 3, 3, 5, 5, 7]",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [4.0, 9.0, 3.0, 2.0, 6.0, 5.0]. (0.891 error rate)"
            },
            {
                "generated rasp code": "def make_increment_odd_indices() -> rasp.SOp:\n    # Create a selector for odd indices\n    odd_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 1).named(\"odd_selector\")\n    \n    # Create a sequence of 1's with the same length as the input\n    ones = rasp.Map(lambda x: 1, rasp.tokens).named(\"ones\")\n    \n    # Use Aggregate to add 1 to elements at odd indices\n    increment = rasp.Aggregate(odd_selector, ones, default=None).named(\"increment\")\n    \n    # Combine the original sequence with the incremented odd indices\n    result = rasp.SequenceMap(lambda x, y: x + y if y is not None else x, rasp.tokens, increment).named(\"result\")\n    \n    return result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [4.0, 9.0, 3.0, 2.0, 6.0, 5.0]. (1.0 error rate)"
            }
        ],
        "make_hyperbolic_tangent": [
            {
                "generated rasp code": "def make_hyperbolic_tangent() -> rasp.SOp:\n    def exp_approx(x):\n        # Taylor series approximation of e^x\n        # e^x \u2248 1 + x + x^2/2! + x^3/3! + x^4/4! + x^5/5!\n        return 1 + x + (x**2)/2 + (x**3)/6 + (x**4)/24 + (x**5)/120\n\n    def tanh(x):\n        exp_x = exp_approx(x)\n        exp_neg_x = exp_approx(-x)\n        return (exp_x - exp_neg_x) / (exp_x + exp_neg_x)\n\n    # Apply the tanh function to each element of the input sequence\n    return rasp.Map(lambda x: tanh(x), rasp.tokens).named(\"hyperbolic_tangent\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [1.0732394366197182, 1.7990180032733227, 0.9818181818181819, 0.7621621621621621, 1.3119072708113801, 1.1796610169491524]. (0.986 error rate)"
            },
            {
                "generated rasp code": "def make_hyperbolic_tangent() -> rasp.SOp:\n    def exp_approx(x):\n        # Approximate e^x using Taylor series (up to 5th term)\n        return 1 + x + (x**2)/2 + (x**3)/6 + (x**4)/24 + (x**5)/120\n\n    def tanh_approx(x):\n        # Calculate tanh(x) using the approximated exp function\n        exp_x = exp_approx(x)\n        exp_neg_x = exp_approx(-x)\n        return (exp_x - exp_neg_x) / (exp_x + exp_neg_x)\n\n    # Apply the approximate hyperbolic tangent function to each element\n    return rasp.Map(lambda x: tanh_approx(x), rasp.tokens).named(\"hyperbolic_tangent\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [1.0732394366197182, 1.7990180032733227, 0.9818181818181819, 0.7621621621621621, 1.3119072708113801, 1.1796610169491524]. (0.986 error rate)"
            },
            {
                "generated rasp code": "def make_hyperbolic_tangent() -> rasp.SOp:\n    def exp_approx(x):\n        # Taylor series approximation of e^x\n        return 1 + x + (x**2)/2 + (x**3)/6 + (x**4)/24 + (x**5)/120\n\n    def tanh_approx(x):\n        ex = exp_approx(x)\n        e_minus_x = exp_approx(-x)\n        return (ex - e_minus_x) / (ex + e_minus_x)\n\n    return rasp.Map(lambda x: tanh_approx(x), rasp.tokens).named(\"hyperbolic_tangent\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [1.0732394366197182, 1.7990180032733227, 0.9818181818181819, 0.7621621621621621, 1.3119072708113801, 1.1796610169491524]. (0.986 error rate)"
            },
            {
                "generated rasp code": "def make_hyperbolic_tangent() -> rasp.SOp:\n    def exp_approx(x, terms=10):\n        \"\"\"Approximate e^x using Taylor series.\"\"\"\n        result = 1.0\n        term = 1.0\n        for i in range(1, terms):\n            term *= x / i\n            result += term\n        return result\n\n    def tanh(x):\n        \"\"\"Calculate hyperbolic tangent using exp approximation.\"\"\"\n        pos_exp = exp_approx(x)\n        neg_exp = exp_approx(-x)\n        return (pos_exp - neg_exp) / (pos_exp + neg_exp)\n\n    # Apply the hyperbolic tangent function to each element\n    return rasp.Map(tanh, rasp.tokens).named(\"hyperbolic_tangent\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0.9963131593559132, 1.1712774291158687, 0.9640881387716831, 0.7615942766625055, 1.0257588481208166, 1.0071250212443295]. (0.986 error rate)"
            },
            {
                "generated rasp code": "def make_hyperbolic_tangent() -> rasp.SOp:\n    def exp_approx(x, terms=10):\n        \"\"\"Approximate e^x using Taylor series.\"\"\"\n        result = 1.0\n        term = 1.0\n        for i in range(1, terms):\n            term *= x / i\n            result += term\n        return result\n\n    def tanh(x):\n        \"\"\"Calculate hyperbolic tangent using exp approximation.\"\"\"\n        pos_exp = exp_approx(x)\n        neg_exp = exp_approx(-x)\n        return (pos_exp - neg_exp) / (pos_exp + neg_exp)\n\n    # Apply the hyperbolic tangent function to each element\n    return rasp.Map(lambda x: tanh(x), rasp.tokens).named(\"hyperbolic_tangent\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0.9963131593559132, 1.1712774291158687, 0.9640881387716831, 0.7615942766625055, 1.0257588481208166, 1.0071250212443295]. (0.986 error rate)"
            }
        ],
        "make_hyperbolic_sine": [
            {
                "generated rasp code": "def make_hyperbolic_sine() -> rasp.SOp:\n    def sinh_approx(x):\n        # Taylor series approximation of sinh(x)\n        # sinh(x) = x + x^3/3! + x^5/5! + x^7/7! + ...\n        # We'll use the first 4 terms for a good approximation\n        x_squared = x * x\n        x_cubed = x_squared * x\n        x_fifth = x_cubed * x_squared\n        x_seventh = x_fifth * x_squared\n        \n        return x + x_cubed/6 + x_fifth/120 + x_seventh/5040\n\n    # Apply the sinh_approx function to each element of the input sequence\n    return rasp.Map(sinh_approx, rasp.tokens).named(\"hyperbolic_sine\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [9.958928571428572, 782.5015873015873, 3.625396825396825, 1.1751984126984127, 67.37599206349206, 26.45079365079365]. (0.992 error rate)"
            },
            {
                "generated rasp code": "def make_exp() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP operation that approximates the exponential function e^x.\n    This uses a 5th order Taylor series approximation.\n    \"\"\"\n    return rasp.Map(lambda x: 1 + x + x**2/2 + x**3/6 + x**4/24 + x**5/120, rasp.tokens).named(\"exp\")\n\ndef make_hyperbolic_sine() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP operation that applies the hyperbolic sine function to each element.\n    \"\"\"\n    # Create the exponential function\n    exp = make_exp()\n    \n    # Define the hyperbolic sine function using the exponential function\n    def sinh(x):\n        pos_exp = exp(rasp.Map(lambda y: y, rasp.tokens))  # e^x\n        neg_exp = exp(rasp.Map(lambda y: -y, rasp.tokens))  # e^(-x)\n        return rasp.Map(lambda z: (z - 1/z) / 2, rasp.SequenceMap(lambda a, b: a/b, pos_exp, neg_exp))\n    \n    return sinh(rasp.tokens).named(\"hyperbolic_sine\")",
                "failure stage": 0,
                "error": "'Map' object is not iterable"
            },
            {
                "generated rasp code": "def make_hyperbolic_sine() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP SOp that applies the hyperbolic sine function to each element of the input sequence.\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that computes the hyperbolic sine of each input element.\n    \"\"\"\n    \n    def sinh(x):\n        \"\"\"\n        Computes the hyperbolic sine of x using the definition: sinh(x) = (e^x - e^(-x)) / 2\n        \"\"\"\n        exp_x = 2.718281828459045 ** x  # e^x\n        return (exp_x - 1/exp_x) / 2\n\n    return rasp.Map(lambda x: sinh(x), rasp.tokens).named(\"hyperbolic_sine\")",
                "failure stage": 4,
                "error": "ground truth: ['BOS', 4051.54190208279] model output: ['BOS', 4051.5419020827876] for [9]"
            },
            {
                "generated rasp code": "def make_hyperbolic_sine() -> rasp.SOp:\n    def exp_approx(x, terms=10):\n        \"\"\"Approximate e^x using Taylor series expansion.\"\"\"\n        result = 1.0\n        term = 1.0\n        for i in range(1, terms):\n            term *= x / i\n            result += term\n        return result\n\n    def sinh_approx(x):\n        \"\"\"Approximate hyperbolic sine using exp_approx.\"\"\"\n        return (exp_approx(x) - exp_approx(-x)) / 2\n\n    return rasp.Map(sinh_approx, rasp.tokens).named(\"hyperbolic_sine\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [10.013169642857141, 1152.369664902998, 3.626807760141093, 1.175201168430335, 72.75828097442681, 27.173192239858906]. (0.992 error rate)"
            },
            {
                "generated rasp code": "def make_hyperbolic_sine() -> rasp.SOp:\n    def exp_approx(x):\n        # Approximate e^x using Taylor series (up to 10 terms for accuracy)\n        return sum(x**n / factorial(n) for n in range(10))\n    \n    def factorial(n):\n        if n == 0 or n == 1:\n            return 1\n        return n * factorial(n-1)\n    \n    def sinh(x):\n        ex = exp_approx(x)\n        e_minus_x = exp_approx(-x)\n        return (ex - e_minus_x) / 2\n    \n    return rasp.Map(lambda x: sinh(x), rasp.tokens).named(\"hyperbolic_sine\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [10.013169642857141, 1152.3696649029982, 3.626807760141093, 1.175201168430335, 72.7582809744268, 27.173192239858906]. (0.992 error rate)"
            }
        ],
        "make_zero_every_third": [
            {
                "generated rasp code": "def make_zero_every_third() -> rasp.SOp:\n    # Create a selector that identifies every third element\n    third_element_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: x % 3, rasp.indices),\n        lambda x, y: y == 2\n    ).named(\"third_element_selector\")\n\n    # Use SequenceMap to replace every third element with zero\n    zero_every_third = rasp.SequenceMap(\n        lambda x, y: 0 if y else x,\n        rasp.tokens,\n        third_element_selector\n    ).named(\"zero_every_third\")\n\n    return zero_every_third",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_zero_every_third() -> rasp.SOp:\n    # Create a selector that identifies every third element\n    third_element_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: 2, rasp.indices),  # Constant sequence of 2\n        lambda x, y: x % 3 == y\n    ).named(\"third_element_selector\")\n\n    # Use SequenceMap to set every third element to zero\n    zero_every_third = rasp.SequenceMap(\n        lambda x, y: 0 if y else x,  # If selected (y is True), set to 0; otherwise, keep x\n        rasp.tokens,\n        third_element_selector\n    ).named(\"zero_every_third\")\n\n    return zero_every_third",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_zero_every_third() -> rasp.SOp:\n    # Create a selector that identifies every third element\n    every_third_selector = rasp.Select(\n        rasp.indices,  # keys\n        rasp.indices,  # queries\n        lambda k, q: (q + 1) % 3 == 0  # predicate\n    ).named(\"every_third_selector\")\n\n    # Use SequenceMap to combine the original sequence with our selector\n    # If the selector is True (every third element), return 0, otherwise return the original element\n    return rasp.SequenceMap(\n        lambda x, y: 0 if y else x,  # if y is True (every third element), return 0, else return x\n        rasp.tokens,  # original sequence\n        every_third_selector  # our selector\n    ).named(\"zero_every_third\")",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_zero_every_third() -> rasp.SOp:\n    # Create a selector that identifies every third element\n    every_third_selector = rasp.Select(\n        rasp.indices,\n        rasp.indices,\n        lambda x, y: (x + 1) % 3 == 0\n    ).named(\"every_third_selector\")\n\n    # Use SequenceMap to combine the original sequence with our selector\n    # If the selector is True (every third element), return 0, otherwise return the original element\n    return rasp.SequenceMap(\n        lambda x, y: 0 if y else x,\n        rasp.tokens,\n        every_third_selector\n    ).named(\"zero_every_third\")",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_zero_every_third() -> rasp.SOp:\n    # Create a selector that identifies every third element\n    # We use (x % 3 == 2) because indices are 0-based\n    third_element_selector = rasp.Select(\n        rasp.indices,\n        rasp.indices,\n        lambda x, y: x % 3 == 2\n    ).named(\"third_element_selector\")\n\n    # Use SequenceMap to replace every third element with zero\n    # If the selector is True (every third element), return 0; otherwise, return the original element\n    zero_every_third = rasp.SequenceMap(\n        lambda x, y: 0 if y else x,\n        rasp.tokens,\n        third_element_selector\n    ).named(\"zero_every_third\")\n\n    return zero_every_third",
                "failure stage": 0,
                "error": ""
            }
        ],
        "make_element_second": [
            {
                "generated rasp code": "def make_element_second() -> rasp.SOp:\n    # Create a selector for the second element (index 1)\n    second_element_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: 1, rasp.indices),\n        rasp.Comparison.EQ\n    ).named(\"second_element_selector\")\n\n    # Extract the second element and broadcast it\n    second_element = rasp.Aggregate(second_element_selector, rasp.tokens, default=None).named(\"second_element\")\n\n    # Create a selector for sequences with length >= 2\n    length = rasp.SelectorWidth(rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE)).named(\"length\")\n    sufficient_length_selector = rasp.Select(\n        length,\n        rasp.Map(lambda x: 2, rasp.indices),\n        rasp.Comparison.GEQ\n    ).named(\"sufficient_length_selector\")\n\n    # Combine the selectors: select second element only if length is sufficient\n    final_selector = rasp.SelectorAnd(sufficient_length_selector, rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE)).named(\"final_selector\")\n\n    # Use Aggregate with the final selector to get the desired result\n    result = rasp.Aggregate(final_selector, second_element, default=None).named(\"result\")\n\n    return result",
                "failure stage": 1,
                "error": "Unsupported type for aggregation: [4.0, 4.0, 4.0, 4.0, 4.0, 4.0]"
            },
            {
                "generated rasp code": "def make_element_second() -> rasp.SOp:\n    # Create a selector that selects only the second element (index 1)\n    second_elem_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == 1).named(\"second_elem_selector\")\n    \n    # Use Aggregate to broadcast the second element across the entire sequence\n    second_elem_sequence = rasp.Aggregate(second_elem_selector, rasp.tokens, default=None).named(\"second_elem_sequence\")\n    \n    # Create a selector that checks if the index is less than 1 (True for sequences with fewer than two elements)\n    short_sequence_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x < 1).named(\"short_sequence_selector\")\n    \n    # Create a sequence of None values\n    none_sequence = rasp.Map(lambda x: None, rasp.tokens).named(\"none_sequence\")\n    \n    # Combine the results: use second_elem_sequence if the sequence has at least two elements,\n    # otherwise use none_sequence\n    result = rasp.SequenceMap(\n        lambda x, y: y if x else None,\n        ~short_sequence_selector,  # Invert the selector to True for sequences with at least two elements\n        second_elem_sequence\n    ).named(\"result\")\n    \n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_length() -> rasp.SOp:\n    \"\"\"Creates the `length` SOp using selector width primitive.\"\"\"\n    all_true_selector = rasp.Select(\n        rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\ndef make_element_second() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that replaces each element with the second element of the sequence.\n    If the sequence has fewer than two elements, it returns [None].\n    \"\"\"\n    # Create a selector that selects only the second element (index 1)\n    second_element_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: 1, rasp.tokens),\n        rasp.Comparison.EQ\n    ).named(\"second_element_selector\")\n\n    # Use Aggregate to broadcast the second element across the entire sequence\n    second_element_sequence = rasp.Aggregate(\n        second_element_selector,\n        rasp.tokens,\n        default=None\n    ).named(\"second_element_sequence\")\n\n    # Get the length of the sequence\n    length = make_length()\n\n    # Create a selector that checks if the length is at least 2\n    length_check_selector = rasp.Select(\n        length,\n        rasp.Map(lambda x: 2, rasp.tokens),\n        rasp.Comparison.GEQ\n    ).named(\"length_check_selector\")\n\n    # Combine the results: use the second_element_sequence if length >= 2, else use None\n    result = rasp.Aggregate(\n        length_check_selector,\n        second_element_sequence,\n        default=None\n    ).named(\"result\")\n\n    return result",
                "failure stage": 1,
                "error": "Unsupported type for aggregation: [4.0, 4.0, 4.0, 4.0, 4.0, 4.0]"
            },
            {
                "generated rasp code": "def make_element_second() -> rasp.SOp:\n    # Create a selector that selects only the second element (index 1)\n    second_element_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: 1, rasp.tokens),\n        rasp.Comparison.EQ\n    ).named(\"second_element_selector\")\n\n    # Use Aggregate to broadcast the second element across the entire sequence\n    second_element_broadcast = rasp.Aggregate(\n        second_element_selector,\n        rasp.tokens,\n        default=None\n    ).named(\"second_element_broadcast\")\n\n    # Create a sequence representing the length of the input\n    sequence_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"sequence_length\")\n\n    # Combine the length check with the main logic\n    result = rasp.SequenceMap(\n        lambda length, element: element if length > 1 else None,\n        sequence_length,\n        second_element_broadcast\n    ).named(\"result\")\n\n    return result\n\n# The function can be called as:\n# make_element_second()",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_element_second() -> rasp.SOp:\n    # Create a selector that selects only the second element (index 1)\n    second_element_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: 1, rasp.tokens),\n        rasp.Comparison.EQ\n    ).named(\"second_element_selector\")\n\n    # Broadcast the second element across the entire sequence\n    broadcasted_second = rasp.Aggregate(\n        second_element_selector,\n        rasp.tokens\n    ).named(\"broadcasted_second\")\n\n    # Create a selector to check if the sequence length is at least 2\n    length_check = rasp.Select(\n        rasp.Map(lambda x: len(x), rasp.tokens),\n        rasp.Map(lambda x: 2, rasp.tokens),\n        rasp.Comparison.GEQ\n    ).named(\"length_check\")\n\n    # Combine the results: use broadcasted_second if length >= 2, else None\n    result = rasp.SequenceMap(\n        lambda x, y: y if x else None,\n        length_check,\n        broadcasted_second\n    ).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": ""
            }
        ],
        "make_mirror_first_half": [
            {
                "generated rasp code": "def make_mirror_first_half() -> rasp.SOp:\n    # Calculate the length of the sequence\n    all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    length = rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n    # Create a selector for the first half (including the middle element for odd lengths)\n    first_half_selector = rasp.Select(rasp.indices, length, lambda i, l: i < (l + 1) / 2).named(\"first_half_selector\")\n\n    # Duplicate the first half across the entire sequence\n    first_half = rasp.Aggregate(first_half_selector, rasp.tokens).named(\"first_half\")\n\n    # Create reversed indices\n    reversed_indices = rasp.SequenceMap(lambda i, l: l - i - 1, rasp.indices, length).named(\"reversed_indices\")\n\n    # Create a selector for the reversed first half\n    reversed_first_half_selector = rasp.Select(reversed_indices, length, lambda i, l: i < (l + 1) / 2).named(\"reversed_first_half_selector\")\n\n    # Reverse the first half\n    reversed_first_half = rasp.Aggregate(reversed_first_half_selector, first_half).named(\"reversed_first_half\")\n\n    # Create a selector for the second half of the sequence\n    second_half_selector = rasp.Select(rasp.indices, length, lambda i, l: i >= l / 2).named(\"second_half_selector\")\n\n    # Combine the first half and the reversed first half\n    mirrored_sequence = rasp.SequenceMap(\n        lambda x, y: x if y else None,\n        first_half,\n        first_half_selector\n    ).named(\"first_half_output\")\n\n    mirrored_sequence = rasp.SequenceMap(\n        lambda x, y: y if x else None,\n        second_half_selector,\n        reversed_first_half\n    ).named(\"mirrored_sequence\")\n\n    return mirrored_sequence",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_mirror_first_half() -> rasp.SOp:\n    def make_length() -> rasp.SOp:\n        all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n        return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n    # Calculate the length of the sequence\n    length = make_length()\n\n    # Calculate the midpoint (using floor division for odd-length sequences)\n    midpoint = rasp.Map(lambda x: x // 2, length).named(\"midpoint\")\n\n    # Create a selector for the first half (including middle element for odd-length sequences)\n    first_half_selector = rasp.Select(rasp.indices, midpoint, rasp.Comparison.LT).named(\"first_half_selector\")\n\n    # Select the first half of the sequence\n    first_half = rasp.Aggregate(first_half_selector, rasp.tokens).named(\"first_half\")\n\n    # Create reversed indices for the second half\n    reversed_indices = rasp.SequenceMap(lambda x, y: y - x - 1, rasp.indices, midpoint).named(\"reversed_indices\")\n\n    # Create a selector for the second half\n    second_half_selector = rasp.Select(rasp.indices, midpoint, rasp.Comparison.GEQ).named(\"second_half_selector\")\n\n    # Reverse the first half\n    reversed_first_half = rasp.Aggregate(rasp.Select(reversed_indices, rasp.indices, rasp.Comparison.EQ), first_half).named(\"reversed_first_half\")\n\n    # Combine the original first half and the reversed first half\n    mirrored_sequence = rasp.SequenceMap(\n        lambda x, y, z: y if x else z,\n        first_half_selector,\n        rasp.tokens,\n        reversed_first_half\n    ).named(\"mirrored_sequence\")\n\n    return mirrored_sequence",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            },
            {
                "generated rasp code": "def make_mirror_first_half() -> rasp.SOp:\n    # Create a sequence of indices\n    indices = rasp.indices.named(\"indices\")\n    \n    # Calculate the length of the sequence\n    length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"length\")\n    \n    # Calculate the midpoint (using integer division to handle odd-length sequences)\n    midpoint = rasp.Map(lambda x: x // 2, length).named(\"midpoint\")\n    \n    # Create reversed indices for the second half\n    reversed_indices = rasp.SequenceMap(lambda l, i: l - i - 1, length, indices).named(\"reversed_indices\")\n    \n    # Create a selector for the first half\n    first_half_selector = rasp.Select(indices, midpoint, rasp.Comparison.LT).named(\"first_half_selector\")\n    \n    # Create a selector for the second half (mirrored)\n    second_half_selector = rasp.Select(indices, midpoint, rasp.Comparison.GEQ).named(\"second_half_selector\")\n    \n    # Combine the selectors\n    combined_selector = rasp.SequenceMap(\n        lambda f, s: f or s,\n        first_half_selector,\n        second_half_selector\n    ).named(\"combined_selector\")\n    \n    # Create the mirrored sequence\n    mirrored_sequence = rasp.Aggregate(\n        combined_selector,\n        rasp.SequenceMap(\n            lambda i, r: rasp.tokens[i] if i < r else rasp.tokens[r],\n            indices,\n            reversed_indices\n        )\n    ).named(\"mirrored_sequence\")\n    \n    return mirrored_sequence",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_mirror_first_half() -> rasp.SOp:\n    # Calculate the length of the sequence\n    all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    length = rasp.SelectorWidth(all_true_selector).named(\"length\")\n    \n    # Create a selector for the first half (including middle element for odd lengths)\n    first_half_selector = rasp.Select(rasp.indices, length, lambda i, l: i < (l + 1) / 2).named(\"first_half_selector\")\n    \n    # Extract the first half of the sequence\n    first_half = rasp.Aggregate(first_half_selector, rasp.tokens).named(\"first_half\")\n    \n    # Create a selector for the reversed second half\n    reverse_selector = rasp.Select(rasp.indices, length, lambda i, l: i >= l / 2).named(\"reverse_selector\")\n    \n    # Create the reversed first half\n    reversed_first_half = rasp.Aggregate(reverse_selector, first_half).named(\"reversed_first_half\")\n    \n    # Combine the original first half with the reversed first half\n    mirrored_sequence = rasp.SequenceMap(\n        lambda x, y: x if x is not None else y,\n        first_half,\n        reversed_first_half\n    ).named(\"mirrored_sequence\")\n    \n    return mirrored_sequence",
                "failure stage": 1,
                "error": "Unsupported type for aggregation: [4.0, 4.0]"
            },
            {
                "generated rasp code": "def make_mirror_first_half() -> rasp.SOp:\n    # Calculate the length of the sequence\n    all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    length = rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n    # Calculate half the length (rounded up for odd lengths)\n    half_length = rasp.Map(lambda x: (x + 1) // 2, length).named(\"half_length\")\n\n    # Create a selector for the first half (or slightly more than half for odd lengths)\n    first_half_selector = rasp.Select(rasp.indices, half_length, rasp.Comparison.LT).named(\"first_half_selector\")\n\n    # Extract the first half of the sequence\n    first_half = rasp.Aggregate(first_half_selector, rasp.tokens).named(\"first_half\")\n\n    # Create reversed indices for the second half\n    reversed_indices = rasp.SequenceMap(lambda x, y: y - x - 1, rasp.indices, half_length).named(\"reversed_indices\")\n\n    # Create a selector for reversing the first half\n    reverse_selector = rasp.Select(rasp.indices, reversed_indices, rasp.Comparison.EQ).named(\"reverse_selector\")\n\n    # Create the reversed first half\n    reversed_first_half = rasp.Aggregate(reverse_selector, first_half).named(\"reversed_first_half\")\n\n    # Combine the first half and the reversed first half\n    result = rasp.SequenceMap(\n        lambda x, y: x if y else z,\n        first_half,\n        first_half_selector,\n        reversed_first_half\n    ).named(\"mirrored_sequence\")\n\n    return result",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            }
        ],
        "make_sorting": [],
        "make_increment": [],
        "make_rank": [
            {
                "generated rasp code": "def make_rank() -> rasp.SOp:\n    # Create unique identifiers for each element to handle ties\n    unique_tokens = rasp.SequenceMap(lambda x, y: x + y * 0.000000001, rasp.tokens, rasp.indices).named(\"unique_tokens\")\n    \n    # Selector that creates a comparison matrix where each element is compared to every other element\n    lt_selector = rasp.Select(unique_tokens, unique_tokens, rasp.Comparison.LT).named(\"lt_selector\")\n    \n    # Count the number of elements less than each element\n    lt_count = rasp.SelectorWidth(lt_selector).named(\"lt_count\")\n    \n    # Add 1 to the count to get the rank (ranks start from 1)\n    rank = rasp.Map(lambda x: x + 1, lt_count).named(\"rank\")\n    \n    return rank",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3, 6, 2, 1, 5, 4]. (0.638 error rate)"
            },
            {
                "generated rasp code": "def make_rank() -> rasp.SOp:\n    # Create a unique version of the input sequence by adding a small fraction of the index\n    unique_tokens = rasp.SequenceMap(lambda x, y: x + y * 0.00000000000001, rasp.tokens, rasp.indices).named(\"unique_tokens\")\n    \n    # Create a selector that compares each element with every other element\n    lt_selector = rasp.Select(unique_tokens, unique_tokens, rasp.Comparison.LT).named(\"lt_selector\")\n    \n    # Count the number of elements less than each element\n    lt_count = rasp.SelectorWidth(lt_selector).named(\"lt_count\")\n    \n    # Add 1 to the count to get the rank (ranks start at 1)\n    rank = rasp.Map(lambda x: x + 1, lt_count).named(\"rank\")\n    \n    return rank",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3, 6, 2, 1, 5, 4]. (0.638 error rate)"
            },
            {
                "generated rasp code": "def make_rank() -> rasp.SOp:\n    # Create unique identifiers for each element\n    unique_tokens = rasp.SequenceMap(lambda x, y: x + y * 1e-10, rasp.tokens, rasp.indices).named(\"unique_tokens\")\n\n    # Selector that creates a comparison matrix where each element is compared to every other element\n    lt_selector = rasp.Select(unique_tokens, unique_tokens, rasp.Comparison.LT).named(\"lt_selector\")\n\n    # Count the number of elements less than each element\n    lt_count = rasp.SelectorWidth(lt_selector).named(\"lt_count\")\n\n    # Add 1 to the count to get the final rank\n    rank = rasp.Map(lambda x: x + 1, lt_count).named(\"rank\")\n\n    return rank",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3, 6, 2, 1, 5, 4]. (0.638 error rate)"
            },
            {
                "generated rasp code": "def make_rank() -> rasp.SOp:\n    # Create unique values by adding a small fraction of the index to each element\n    unique_tokens = rasp.SequenceMap(lambda x, y: x + y * 0.00000000000001, rasp.tokens, rasp.indices).named(\"unique_tokens\")\n\n    # Selector that creates a comparison matrix where each element is compared to every other element (less than)\n    lt_selector = rasp.Select(unique_tokens, unique_tokens, rasp.Comparison.LT).named(\"lt_selector\")\n\n    # Count the number of elements less than each element\n    lt_count = rasp.SelectorWidth(lt_selector).named(\"lt_count\")\n\n    # Selector for equal elements\n    eq_selector = rasp.Select(unique_tokens, unique_tokens, rasp.Comparison.EQ).named(\"eq_selector\")\n\n    # Count the number of equal elements for each element\n    eq_count = rasp.SelectorWidth(eq_selector).named(\"eq_count\")\n\n    # Combine lt_count and eq_count to calculate the final rank\n    # We add 1 to lt_count because ranking starts at 1, not 0\n    # We subtract (eq_count - 1) / 2 to handle ties correctly\n    rank = rasp.SequenceMap(\n        lambda lt, eq: lt + 1 - (eq - 1) / 2, \n        lt_count, \n        eq_count\n    ).named(\"rank\")\n\n    return rank",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3.0, 6.0, 2.0, 1.0, 5.0, 4.0]. (0.638 error rate)"
            }
        ],
        "make_factorial": [
            {
                "generated rasp code": "def make_factorial() -> rasp.SOp:\n    def factorial_calculation(n):\n        # Handle edge cases: return 1 for n <= 1\n        edge_case_selector = rasp.Select(n, rasp.Map(lambda x: 1, rasp.indices), rasp.Comparison.LEQ)\n        edge_case_result = rasp.Aggregate(edge_case_selector, rasp.Map(lambda x: 1, rasp.indices), default=None)\n        \n        # Create a range of numbers from 1 to n\n        range_selector = rasp.Select(rasp.indices, n, rasp.Comparison.LT)\n        range_length = rasp.SelectorWidth(range_selector)\n        range_sequence = rasp.SequenceMap(lambda x, y: y + 1, rasp.tokens, range_length)\n        \n        # Calculate the product of the range\n        product = rasp.Aggregate(range_selector, range_sequence, default=1)\n        \n        # Combine the edge case result and the calculated factorial\n        return rasp.SequenceMap(lambda x, y: x if x is not None else y, edge_case_result, product)\n\n    # Apply the factorial calculation to each element in the input sequence\n    return rasp.Map(factorial_calculation, rasp.tokens).named(\"factorial\")",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_factorial() -> rasp.SOp:\n    # Create a sequence of indices starting from 1\n    indices_from_one = rasp.Map(lambda x: x + 1, rasp.indices).named(\"indices_from_one\")\n\n    # Create a sequence of ones with the same length as the input\n    ones = rasp.Map(lambda x: 1, rasp.tokens).named(\"ones\")\n\n    # Multiply each index with the corresponding accumulator\n    products = rasp.SequenceMap(lambda x, y: x * y, indices_from_one, ones).named(\"products\")\n\n    # Create a selector for accumulating products\n    accumulate_selector = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.LEQ).named(\"accumulate_selector\")\n\n    # Accumulate products to calculate factorial\n    factorials = rasp.Aggregate(accumulate_selector, products).named(\"factorials\")\n\n    return factorials",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [1.0, 1.5, 2.0, 2.5, 3.0, 3.5]. (0.986 error rate)"
            },
            {
                "generated rasp code": "def make_factorial(max_input: int = 10) -> rasp.SOp:\n    # Start with a sequence of ones\n    factorial = rasp.Map(lambda x: 1, rasp.tokens).named(\"initial_ones\")\n    \n    # For each possible multiplication (up to max_input)\n    for i in range(1, max_input + 1):\n        # Create a sequence where each element is i\n        i_sequence = rasp.Map(lambda x: i, rasp.indices).named(f\"i_sequence_{i}\")\n        \n        # Create a selector that is True for indices less than i\n        selector = rasp.Select(rasp.indices, i_sequence, rasp.Comparison.LT).named(f\"selector_{i}\")\n        \n        # Create a sequence that's i where the selector is True, and 1 otherwise\n        multiplier = rasp.Aggregate(selector, i_sequence, default=1).named(f\"multiplier_{i}\")\n        \n        # Multiply the current factorial by the multiplier\n        factorial = rasp.SequenceMap(lambda x, y: x * y, factorial, multiplier).named(f\"factorial_{i}\")\n    \n    return factorial",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [10000000000.0, 10000000000.0, 10000000000.0, 10000000000.0, 10000000000.0, 10000000000.0]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_factorial(max_n: int = 10) -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that replaces each element with its factorial.\n    \n    Args:\n    max_n (int): The maximum number for which to pre-calculate factorial. Default is 10.\n    \n    Returns:\n    rasp.SOp: A RASP program that calculates factorials.\n    \"\"\"\n    \n    # Create a sequence from 1 to max_n\n    sequence = rasp.SequenceMap(lambda x, y: y + 1, rasp.tokens, rasp.indices).named(\"sequence\")\n    \n    # Create a selector that selects numbers less than or equal to each input number\n    selector = rasp.Select(rasp.tokens, sequence, rasp.Comparison.GEQ).named(\"selector\")\n    \n    # Calculate the product of selected numbers for each input\n    factorial = rasp.Aggregate(selector, sequence).named(\"factorial\")\n    \n    # Handle edge cases: 0 should return 1, negative numbers should return None\n    result = rasp.SequenceMap(\n        lambda x, y: 1 if x == 0 else (None if x < 0 else y),\n        rasp.tokens,\n        factorial\n    ).named(\"result\")\n    \n    return result\n\n# Example usage:\n# factorial = make_factorial()\n# factorial([1, 3, 5])  # returns [1, 6, 120]\n# factorial([2, 4, 0, 7])  # returns [2, 24, 1, 5040]",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3.5, 3.4, 3.5, 4.333333333333333, 3.5, 2.0]. (0.995 error rate)"
            },
            {
                "generated rasp code": "def make_factorial() -> rasp.SOp:\n    def make_length() -> rasp.SOp:\n        \"\"\"Creates the `length` SOp using selector width primitive.\"\"\"\n        all_true_selector = rasp.Select(\n            rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n        return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n    length = make_length()\n\n    # Generate a sequence from 1 to n for each element\n    seq_gen = rasp.SequenceMap(\n        lambda x, y: y if y <= x else 1,\n        rasp.tokens,\n        rasp.Map(lambda x: x + 1, rasp.indices)\n    ).named(\"seq_gen\")\n\n    # Create a selector for valid numbers in the sequence\n    valid_selector = rasp.Select(\n        seq_gen,\n        rasp.Map(lambda x: 1, rasp.tokens),\n        rasp.Comparison.GT\n    ).named(\"valid_selector\")\n\n    # Compute the product of valid numbers (factorial)\n    factorial = rasp.Aggregate(\n        valid_selector,\n        seq_gen\n    ).named(\"factorial\")\n\n    # Handle the special case of 0\n    return rasp.SequenceMap(\n        lambda x, y: 1 if x == 0 else y,\n        rasp.tokens,\n        factorial\n    ).named(\"factorial_with_zero_case\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3.5, 3.5, 3.5, 3.5, 3.5, 3.5]. (0.996 error rate)"
            }
        ],
        "make_count_less_than": [
            {
                "generated rasp code": "def make_count_less_than() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that replaces each element with the number of elements less than it in the sequence.\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that, when applied to a sequence, returns a new sequence\n              where each element is replaced by the count of elements less than it.\n    \"\"\"\n    # Create a selector that compares each element with every other element\n    # using \"Greater Than\" comparison. This effectively selects elements that are less than each element.\n    gt_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.GT).named(\"gt_selector\")\n    \n    # Use SelectorWidth to count the number of elements less than each element\n    count_less_than = rasp.SelectorWidth(gt_selector).named(\"count_less_than\")\n    \n    return count_less_than",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3, 0, 4, 5, 1, 2]. (0.897 error rate)"
            },
            {
                "generated rasp code": "def make_count_less_than() -> rasp.SOp:\n    # Create a selector that compares each element with every other element.\n    # We use GT (greater than) here because we want to count elements less than the current element.\n    gt_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.GT).named(\"gt_selector\")\n\n    # Count the number of elements less than each element.\n    # This is equivalent to the width of the GT selector for each element.\n    count_less_than = rasp.SelectorWidth(gt_selector).named(\"count_less_than\")\n\n    return count_less_than",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3, 0, 4, 5, 1, 2]. (0.897 error rate)"
            }
        ],
        "make_cube_each_element": [],
        "make_cube_root": [],
        "make_round": [],
        "make_multiply_by_length": [],
        "make_increment_to_multiple_of_three": [],
        "make_sign": [],
        "make_cosine": [
            {
                "generated rasp code": "def make_cosine() -> rasp.SOp:\n    def cos_approx(x):\n        # Normalize x to be between -2\u03c0 and 2\u03c0\n        x = x % (2 * 3.14159265358979323846)\n        if x > 3.14159265358979323846:\n            x -= 2 * 3.14159265358979323846\n        \n        # Taylor series approximation of cosine\n        x_squared = x * x\n        return 1 - x_squared / 2 + x_squared * x_squared / 24 - x_squared * x_squared * x_squared / 720\n\n    return rasp.Map(lambda x: cos_approx(x), rasp.tokens).named(\"cosine\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [-1.1375, -0.1473119111275425, -0.4222222222222223, 0.5402777777777777, 0.28348317621293834, -0.670938581882107]. (0.986 error rate)"
            },
            {
                "generated rasp code": "def make_factorial() -> rasp.SOp:\n    \"\"\"Helper function to compute factorial.\"\"\"\n    def factorial(n):\n        if n <= 1:\n            return 1\n        return n * factorial(n - 1)\n    return rasp.Map(lambda x: factorial(int(abs(x))), rasp.tokens).named(\"factorial\")\n\ndef make_power() -> rasp.SOp:\n    \"\"\"Helper function to compute power.\"\"\"\n    return rasp.SequenceMap(lambda x, y: x ** y, rasp.tokens, rasp.tokens).named(\"power\")\n\ndef make_cosine(num_terms: int = 10) -> rasp.SOp:\n    \"\"\"\n    Creates an SOp that approximates the cosine function using a Taylor series.\n    \n    Args:\n        num_terms: Number of terms to use in the Taylor series approximation.\n    \n    Returns:\n        An SOp that applies an approximation of the cosine function to each element.\n    \"\"\"\n    def cosine_term(x, n):\n        \"\"\"Compute a single term of the cosine Taylor series.\"\"\"\n        power = make_power()\n        factorial = make_factorial()\n        numerator = power(rasp.Map(lambda t: -1, rasp.tokens), rasp.Map(lambda t: n, rasp.tokens))\n        denominator = factorial(rasp.Map(lambda t: 2*n, rasp.tokens))\n        x_power = power(x, rasp.Map(lambda t: 2*n, rasp.tokens))\n        return rasp.SequenceMap(lambda num, den: (num * x_power) / den, numerator, denominator)\n    \n    def cosine_approx(x):\n        \"\"\"Approximate cosine using Taylor series.\"\"\"\n        terms = [cosine_term(x, n) for n in range(num_terms)]\n        return sum(terms)\n    \n    return rasp.Map(lambda x: cosine_approx(x), rasp.tokens).named(\"cosine\")",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_cosine() -> rasp.SOp:\n    def cosine_approx(x):\n        # Normalize x to be between -2\u03c0 and 2\u03c0\n        x = x % (2 * 3.14159265358979323846)\n        if x > 3.14159265358979323846:\n            x -= 2 * 3.14159265358979323846\n        elif x < -3.14159265358979323846:\n            x += 2 * 3.14159265358979323846\n        \n        # Taylor series approximation of cosine\n        x2 = x * x\n        return 1 - x2 / 2 + x2 * x2 / 24 - x2 * x2 * x2 / 720 + x2 * x2 * x2 * x2 / 40320\n\n    # Apply the cosine approximation to each element of the input sequence\n    return rasp.Map(cosine_approx, rasp.tokens).named(\"cosine\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [-0.9747767857142857, -0.145440079212265, -0.41587301587301595, 0.5403025793650793, 0.2836654795010996, -0.6526235042215284]. (0.976 error rate)"
            },
            {
                "generated rasp code": "def make_cosine() -> rasp.SOp:\n    def cos_approx(x):\n        # Approximate cosine using Taylor series expansion\n        # cos(x) \u2248 1 - x^2/2! + x^4/4! - x^6/6!\n        x2 = x * x\n        return 1 - x2/2 + (x2*x2)/24 - (x2*x2*x2)/720\n\n    # Apply the cosine approximation to each element of the input sequence\n    return rasp.Map(cos_approx, rasp.tokens).named(\"cosine\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [-1.1375, -224.42222222222225, -0.4222222222222223, 0.5402777777777777, -7.159722222222221, -2.022222222222223]. (0.986 error rate)"
            },
            {
                "generated rasp code": "def make_cosine() -> rasp.SOp:\n    def factorial(n):\n        if n == 0 or n == 1:\n            return 1\n        return n * factorial(n - 1)\n\n    def power(x, n):\n        result = 1\n        for _ in range(n):\n            result *= x\n        return result\n\n    def cos_approx(x):\n        # Ensure x is within the range [-2\u03c0, 2\u03c0]\n        x = x % (2 * 3.14159265358979323846)\n        if x > 3.14159265358979323846:\n            x -= 2 * 3.14159265358979323846\n        \n        result = 0\n        for n in range(10):  # Using 10 terms for approximation\n            result += ((-1) ** n * power(x, 2*n)) / factorial(2*n)\n        return result\n\n    return rasp.Map(cos_approx, rasp.tokens).named(\"cosine\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [-0.9899924980061545, -0.145500033808634, -0.41614683654756973, 0.5403023058681397, 0.2836621854632265, -0.6536436208696347]. (0.653 error rate)"
            }
        ],
        "make_divide_by_length": [],
        "make_negation": [],
        "make_sine": [
            {
                "generated rasp code": "def make_sine() -> rasp.SOp:\n    def sine_approx(x):\n        # Normalize x to be between -\u03c0 and \u03c0\n        x = x % (2 * 3.14159265358979323846)\n        if x > 3.14159265358979323846:\n            x -= 2 * 3.14159265358979323846\n        \n        # Taylor series approximation of sine\n        result = x\n        term = x\n        for i in range(1, 7):  # Using 7 terms for a good approximation\n            term = -term * x * x / ((2 * i) * (2 * i + 1))\n            result += term\n        return result\n\n    # Apply the sine approximation to each element of the input sequence\n    return rasp.Map(sine_approx, rasp.tokens).named(\"sine\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0.14113062718531463, 0.989358249133306, 0.9092974515196738, 0.8414709848086585, -0.9589242746951434, -0.7568026745093327]. (0.883 error rate)"
            },
            {
                "generated rasp code": "def make_sine() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that approximates the sine function for each element in the input sequence.\n    Uses a Taylor series approximation: sin(x) \u2248 x - x^3/3! + x^5/5! - x^7/7!\n    \"\"\"\n\n    def make_power(n: int) -> rasp.SOp:\n        \"\"\"Helper function to compute x^n.\"\"\"\n        result = rasp.tokens\n        for _ in range(n - 1):\n            result = rasp.SequenceMap(lambda x, y: x * y, result, rasp.tokens)\n        return result.named(f\"power_{n}\")\n\n    def make_factorial(n: int) -> rasp.SOp:\n        \"\"\"Helper function to compute n!.\"\"\"\n        return rasp.Map(lambda x: 1 if n == 0 else\n                        2 if n == 1 else\n                        6 if n == 2 else\n                        24 if n == 3 else\n                        120 if n == 4 else\n                        720 if n == 5 else\n                        5040 if n == 6 else\n                        40320, rasp.tokens).named(f\"factorial_{n}\")\n\n    # Compute the terms of the Taylor series\n    x1 = rasp.tokens.named(\"x1\")\n    x3 = make_power(3).named(\"x3\")\n    x5 = make_power(5).named(\"x5\")\n    x7 = make_power(7).named(\"x7\")\n\n    fact3 = make_factorial(3).named(\"fact3\")\n    fact5 = make_factorial(5).named(\"fact5\")\n    fact7 = make_factorial(7).named(\"fact7\")\n\n    term1 = x1.named(\"term1\")\n    term2 = rasp.SequenceMap(lambda x, y: -x / y, x3, fact3).named(\"term2\")\n    term3 = rasp.SequenceMap(lambda x, y: x / y, x5, fact5).named(\"term3\")\n    term4 = rasp.SequenceMap(lambda x, y: -x / y, x7, fact7).named(\"term4\")\n\n    # Sum up the terms\n    sum_terms = rasp.SequenceMap(lambda a, b: a + b, term1, term2)\n    sum_terms = rasp.SequenceMap(lambda a, b: a + b, sum_terms, term3)\n    sum_terms = rasp.SequenceMap(lambda a, b: a + b, sum_terms, term4)\n\n    return sum_terms.named(\"sine_approximation\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [2.1582589285714286, -19.834920634920636, 1.707936507936508, 0.9596974206349207, 2.1943204365079367, 2.3492063492063493]. (0.986 error rate)"
            }
        ],
        "make_histogram": [],
        "make_element_double": [],
        "make_zero_even_indices": [
            {
                "generated rasp code": "def make_zero_even_indices() -> rasp.SOp:\n    # Create a selector that identifies even indices\n    even_indices_selector = rasp.Select(\n        rasp.indices,\n        rasp.indices,\n        lambda x, y: x % 2 == 0\n    ).named(\"even_indices_selector\")\n\n    # Create a mask where even indices are 0 and odd indices are 1\n    mask = rasp.Map(\n        lambda x: 0 if x else 1,\n        even_indices_selector\n    ).named(\"mask\")\n\n    # Multiply the original sequence with the mask to set even indices to zero\n    result = rasp.SequenceMap(\n        lambda x, y: x * y,\n        rasp.tokens,\n        mask\n    ).named(\"zero_even_indices\")\n\n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_zero_even_indices() -> rasp.SOp:\n    # Create a selector for even indices\n    even_indices_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: 0, rasp.indices),\n        lambda x, y: x % 2 == y\n    ).named(\"even_indices_selector\")\n\n    # Create a sequence of zeros with the same length as the input\n    zero_sequence = rasp.Map(lambda x: 0, rasp.tokens).named(\"zero_sequence\")\n\n    # Combine the original sequence with the zero sequence based on the selector\n    result = rasp.SequenceMap(\n        lambda x, y: y if x else x,\n        even_indices_selector,\n        rasp.SequenceMap(lambda x, y: y, even_indices_selector, rasp.tokens)\n    ).named(\"zero_even_indices\")\n\n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_zero_even_indices() -> rasp.SOp:\n    # Create a sequence of alternating 0 and 1 to identify even and odd indices\n    even_odd_seq = rasp.Map(lambda x: x % 2, rasp.indices).named(\"even_odd_seq\")\n\n    # Create a selector that identifies even indices (where even_odd_seq is 0)\n    even_indices_selector = rasp.Select(even_odd_seq, even_odd_seq, lambda x, y: x == 0).named(\"even_indices_selector\")\n\n    # Use SequenceMap to combine the original sequence with our selector\n    # If the index is even (selector is True), set to 0; otherwise, keep the original value\n    zero_even_indices = rasp.SequenceMap(\n        lambda x, y: 0 if y else x,\n        rasp.tokens,\n        even_indices_selector\n    ).named(\"zero_even_indices\")\n\n    return zero_even_indices",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_zero_even_indices() -> rasp.SOp:\n    # Create a selector that identifies even indices\n    even_indices_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: 0, rasp.indices),\n        lambda x, y: x % 2 == 0\n    ).named(\"even_indices_selector\")\n\n    # Create a sequence of 0s and 1s where even indices are 0 and odd indices are 1\n    zero_one_sequence = rasp.Map(\n        lambda x: 0 if x else 1,\n        even_indices_selector\n    ).named(\"zero_one_sequence\")\n\n    # Multiply the original sequence with the zero_one_sequence\n    result = rasp.SequenceMap(\n        lambda x, y: x * y,\n        rasp.tokens,\n        zero_one_sequence\n    ).named(\"zero_even_indices_result\")\n\n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_zero_even_indices() -> rasp.SOp:\n    # Create a selector for even indices\n    even_indices_selector = rasp.Select(\n        rasp.indices,\n        rasp.indices,\n        lambda x, y: x % 2 == 0\n    ).named(\"even_indices_selector\")\n\n    # Create a sequence of zeros with the same length as the input\n    zero_sequence = rasp.Map(lambda x: 0, rasp.tokens).named(\"zero_sequence\")\n\n    # Combine the original sequence with the zero sequence based on the even index selector\n    result = rasp.SequenceMap(\n        lambda x, y: y if x else x,\n        even_indices_selector,\n        rasp.tokens\n    ).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": ""
            }
        ],
        "make_tangent": [
            {
                "generated rasp code": "def make_tangent() -> rasp.SOp:\n    # Define pi constant\n    PI = 3.14159265358979323846\n\n    def approximate_tan(x):\n        # Normalize x to be between -pi/2 and pi/2\n        x = x % PI\n        if x > PI/2:\n            x -= PI\n        elif x < -PI/2:\n            x += PI\n        \n        # Taylor series approximation of tan(x)\n        x3 = x * x * x\n        x5 = x3 * x * x\n        x7 = x5 * x * x\n        return x + (x3/3) + (2*x5/15) + (17*x7/315)\n\n    def safe_tan(x):\n        # Continuous approximation that handles the asymptote\n        return approximate_tan(x) / (1 - (2*abs(x)/PI)**8)\n\n    return rasp.Map(lambda x: safe_tan(x), rasp.tokens).named(\"tangent\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0.0008098527301218943, 8.428086751012764e-06, 0.3440747300664339, 1.5627991482995705, 0.000261953160746753, -0.0006507231512783202]. (0.986 error rate)"
            },
            {
                "generated rasp code": "def make_tangent() -> rasp.SOp:\n    def factorial(n):\n        if n == 0 or n == 1:\n            return 1\n        return n * factorial(n - 1)\n\n    def sin_approx(x, terms=7):\n        return sum((-1)**n * x**(2*n+1) / factorial(2*n+1) for n in range(terms))\n\n    def cos_approx(x, terms=7):\n        return sum((-1)**n * x**(2*n) / factorial(2*n) for n in range(terms))\n\n    def tan_calc(x):\n        # Handle special cases\n        if abs(x) < 1e-10:  # Close to 0\n            return 0\n        if abs(abs(x) % (3.14159265358979323846 / 2)) < 1e-10:  # Close to \u03c0/2 or its odd multiples\n            return 1e12  # Representation of infinity\n\n        # Calculate tangent\n        sin_x = sin_approx(x)\n        cos_x = cos_approx(x)\n        \n        # Avoid division by zero\n        if abs(cos_x) < 1e-10:\n            return 1e12 if sin_x >= 0 else -1e12\n        \n        return sin_x / cos_x\n\n    # Apply the tangent calculation to each element of the input sequence\n    return rasp.Map(lambda x: tan_calc(x), rasp.tokens).named(\"tangent\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [-0.1425648825556274, 0.575541918727439, -2.1850408931569705, 1.557407724623386, -2.702440068516421, 1.1617618704794161]. (0.974 error rate)"
            },
            {
                "generated rasp code": "def make_tangent() -> rasp.SOp:\n    # Approximate value of \u03c0\n    PI = 3.14159265358979323846\n\n    # Helper function to approximate sin(x)\n    def sin_approx(x):\n        # Use Taylor series approximation\n        x = x % (2 * PI)  # Normalize to [0, 2\u03c0)\n        return x - x**3 / 6 + x**5 / 120 - x**7 / 5040\n\n    # Helper function to approximate cos(x)\n    def cos_approx(x):\n        return sin_approx(x + PI / 2)\n\n    # Helper function to calculate tangent\n    def tan_approx(x):\n        # Normalize x to [-\u03c0, \u03c0)\n        x = x % (2 * PI)\n        if x > PI:\n            x -= 2 * PI\n        \n        # Check for \u03c0/2 and its odd multiples (use a small epsilon for floating point comparison)\n        epsilon = 1e-10\n        if abs(abs(x) - PI/2) < epsilon:\n            return 1e16  # A very large number to represent infinity\n        \n        # Calculate tangent\n        sin_x = sin_approx(x)\n        cos_x = cos_approx(x)\n        \n        # Avoid division by zero\n        if abs(cos_x) < epsilon:\n            return 1e16 if sin_x >= 0 else -1e16\n        \n        return sin_x / cos_x\n\n    # Apply the tangent function to each element\n    return rasp.Map(lambda x: tan_approx(x), rasp.tokens).named(\"tangent\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [-0.03046522005391313, -3.8364682175059035, -1.4002518660916932, 1.5950036734886257, -18.658316131237534, 0.1196391290251175]. (0.986 error rate)"
            },
            {
                "generated rasp code": "def make_tangent() -> rasp.SOp:\n    def factorial(n):\n        if n == 0 or n == 1:\n            return 1\n        return n * factorial(n - 1)\n\n    def sin_approx(x, terms=10):\n        result = 0\n        for n in range(terms):\n            result += (-1)**n * x**(2*n + 1) / factorial(2*n + 1)\n        return result\n\n    def cos_approx(x, terms=10):\n        result = 0\n        for n in range(terms):\n            result += (-1)**n * x**(2*n) / factorial(2*n)\n        return result\n\n    def tan_approx(x):\n        # Normalize x to be within [-\u03c0, \u03c0]\n        x = x % (2 * 3.14159265358979323846)\n        if x > 3.14159265358979323846:\n            x -= 2 * 3.14159265358979323846\n        \n        # Check for \u03c0/2 and its odd multiples\n        if abs(abs(x) - 1.57079632679489661923) < 1e-10:\n            return 1e10 if x > 0 else -1e10\n        \n        sin_x = sin_approx(x)\n        cos_x = cos_approx(x)\n        \n        if abs(cos_x) < 1e-10:\n            return 1e10 if sin_x > 0 else -1e10\n        \n        return sin_x / cos_x\n\n    return rasp.Map(lambda x: tan_approx(x), rasp.tokens).named(\"tangent\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [-0.1425465426686876, -6.799711455219412, -2.185039863259177, 1.5574077246549025, -3.3805150062465827, 1.1578212823379068]. (0.626 error rate)"
            },
            {
                "generated rasp code": "def make_tangent() -> rasp.SOp:\n    # Define pi with high precision\n    PI = 3.141592653589793\n\n    def custom_tan(x):\n        # Normalize x to be within [-pi, pi]\n        x = x % (2 * PI)\n        if x > PI:\n            x -= 2 * PI\n        \n        # Check if x is close to pi/2 or its odd multiples\n        if abs(abs(x) - PI/2) < 1e-10:\n            return 1e308 if x > 0 else -1e308\n        \n        # Taylor series approximation of tan(x)\n        x2 = x * x\n        return x * (1 + x2 * (1/3 + x2 * (2/15 + x2 * (17/315 + x2 * 62/2835))))\n\n    return rasp.Map(lambda x: custom_tan(x), rasp.tokens).named(\"tangent\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [592.8857142857142, 10.598346188433956, 27.038447971781306, 1.5425044091710758, -2.966745973758595, -68.8515169049295]. (0.986 error rate)"
            }
        ],
        "make_count_occurrences": [],
        "make_compute_median": [
            {
                "generated rasp code": "def make_length() -> rasp.SOp:\n    \"\"\"Creates the `length` SOp using selector width primitive.\"\"\"\n    all_true_selector = rasp.Select(\n        rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\ndef make_sort(max_seq_len: int = 100, min_key: float = 0) -> rasp.SOp:\n    \"\"\"Returns vals sorted by < relation on keys.\"\"\"\n    keys = rasp.SequenceMap(lambda x, i: x + min_key * i / max_seq_len, rasp.tokens, rasp.indices)\n    smaller = rasp.Select(keys, keys, rasp.Comparison.LT).named(\"smaller\")\n    target_pos = rasp.SelectorWidth(smaller).named(\"target_pos\")\n    sel_new = rasp.Select(target_pos, rasp.indices, rasp.Comparison.EQ)\n    return rasp.Aggregate(sel_new, rasp.tokens).named(\"sort\")\n\ndef make_compute_median() -> rasp.SOp:\n    \"\"\"Computes the median of the sequence.\"\"\"\n    # Sort the sequence\n    sorted_seq = make_sort().named(\"sorted_seq\")\n    \n    # Get the length of the sequence\n    length = make_length().named(\"length\")\n    \n    # Calculate the middle index\n    middle_index = rasp.Map(lambda x: (x - 1) // 2, length).named(\"middle_index\")\n    \n    # Create a selector for the middle element (odd-length case)\n    middle_selector = rasp.Select(middle_index, rasp.indices, rasp.Comparison.EQ).named(\"middle_selector\")\n    \n    # Select the middle element\n    middle_element = rasp.Aggregate(middle_selector, sorted_seq).named(\"middle_element\")\n    \n    # Create a selector for the element after the middle (for even-length case)\n    next_middle_selector = rasp.Select(rasp.Map(lambda x: x + 1, middle_index), rasp.indices, rasp.Comparison.EQ).named(\"next_middle_selector\")\n    \n    # Select the element after the middle\n    next_middle_element = rasp.Aggregate(next_middle_selector, sorted_seq).named(\"next_middle_element\")\n    \n    # Calculate the average of middle and next_middle elements\n    average = rasp.Map(lambda x: (x[0] + x[1]) / 2 if x[0] is not None and x[1] is not None else x[0] or x[1],\n                       rasp.SequenceMap(lambda x, y: (x, y), middle_element, next_middle_element)).named(\"average\")\n    \n    # Create a selector for even-length sequences\n    even_selector = rasp.Select(rasp.Map(lambda x: x % 2 == 0, length), rasp.Map(lambda x: True, rasp.tokens), rasp.Comparison.EQ).named(\"even_selector\")\n    \n    # Select the median based on whether the length is odd or even\n    median = rasp.Aggregate(even_selector, average, default=None).named(\"median\")\n    median = rasp.SequenceMap(lambda x, y: y if x is None else x, median, middle_element).named(\"final_median\")\n    \n    return median",
                "failure stage": 1,
                "error": "Unsupported type for aggregation: [1.0, 2.0, 3.0, None, 8.0]"
            },
            {
                "generated rasp code": "def make_length() -> rasp.SOp:\n    \"\"\"Returns the length of the input sequence.\"\"\"\n    all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\ndef make_sort(max_seq_len: int = 100) -> rasp.SOp:\n    \"\"\"Returns a sorted version of the input sequence.\"\"\"\n    keys = rasp.SequenceMap(lambda x, i: x + i / max_seq_len, rasp.tokens, rasp.indices).named(\"unique_keys\")\n    smaller = rasp.Select(keys, keys, rasp.Comparison.LT).named(\"smaller\")\n    target_pos = rasp.SelectorWidth(smaller).named(\"target_pos\")\n    sel_new = rasp.Select(target_pos, rasp.indices, rasp.Comparison.EQ).named(\"sel_new\")\n    return rasp.Aggregate(sel_new, rasp.tokens).named(\"sorted\")\n\ndef make_compute_median() -> rasp.SOp:\n    \"\"\"Computes the median of the input sequence.\"\"\"\n    # Sort the input sequence\n    sorted_seq = make_sort().named(\"sorted_seq\")\n    \n    # Get the length of the sequence\n    length = make_length().named(\"length\")\n    \n    # Calculate the middle index (for odd lengths) or the two middle indices (for even lengths)\n    half_length = rasp.Map(lambda x: x // 2, length).named(\"half_length\")\n    is_odd = rasp.Map(lambda x: x % 2 == 1, length).named(\"is_odd\")\n    \n    # Select the middle element(s)\n    middle_selector = rasp.Select(rasp.indices, half_length, rasp.Comparison.EQ).named(\"middle_selector\")\n    middle_element = rasp.Aggregate(middle_selector, sorted_seq).named(\"middle_element\")\n    \n    # For even lengths, also select the element after the middle\n    next_middle_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: x + 1, half_length), rasp.Comparison.EQ).named(\"next_middle_selector\")\n    next_middle_element = rasp.Aggregate(next_middle_selector, sorted_seq).named(\"next_middle_element\")\n    \n    # Calculate the average of the two middle elements for even lengths\n    even_median = rasp.SequenceMap(lambda x, y: (x + y) / 2, middle_element, next_middle_element).named(\"even_median\")\n    \n    # Choose between odd and even median based on the sequence length\n    median = rasp.SequenceMap(lambda is_odd, odd_med, even_med: odd_med if is_odd else even_med,\n                              is_odd, middle_element, even_median).named(\"median\")\n    \n    return median",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            },
            {
                "generated rasp code": "def make_length() -> rasp.SOp:\n    \"\"\"Returns the length of the input sequence.\"\"\"\n    all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\ndef make_sort(max_seq_len: int = 1000, min_key: float = 0) -> rasp.SOp:\n    \"\"\"Returns a sorted version of the input sequence.\"\"\"\n    keys = rasp.SequenceMap(lambda x, i: x + min_key * i / max_seq_len, rasp.tokens, rasp.indices).named(\"unique_keys\")\n    smaller = rasp.Select(keys, keys, rasp.Comparison.LT).named(\"smaller\")\n    target_pos = rasp.SelectorWidth(smaller).named(\"target_pos\")\n    sel_new = rasp.Select(target_pos, rasp.indices, rasp.Comparison.EQ).named(\"sel_new\")\n    return rasp.Aggregate(sel_new, rasp.tokens).named(\"sort\")\n\ndef make_compute_median() -> rasp.SOp:\n    \"\"\"Computes the median of the input sequence.\"\"\"\n    # Sort the input sequence\n    sorted_seq = make_sort().named(\"sorted_seq\")\n    \n    # Get the length of the sequence\n    length = make_length().named(\"length\")\n    \n    # Calculate the middle index\n    middle_index = rasp.Map(lambda x: (x - 1) // 2, length).named(\"middle_index\")\n    \n    # Check if the length is odd\n    is_odd = rasp.Map(lambda x: x % 2 == 1, length).named(\"is_odd\")\n    \n    # Select the middle element(s)\n    middle_selector = rasp.Select(rasp.indices, middle_index, rasp.Comparison.EQ).named(\"middle_selector\")\n    next_to_middle_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: x + 1, middle_index), rasp.Comparison.EQ).named(\"next_to_middle_selector\")\n    \n    middle_element = rasp.Aggregate(middle_selector, sorted_seq).named(\"middle_element\")\n    next_to_middle_element = rasp.Aggregate(next_to_middle_selector, sorted_seq).named(\"next_to_middle_element\")\n    \n    # Calculate the median\n    median = rasp.SequenceMap(\n        lambda odd, mid, next_mid: mid if odd else (mid + next_mid) / 2,\n        is_odd,\n        middle_element,\n        next_to_middle_element\n    ).named(\"median\")\n    \n    # Broadcast the median across the entire sequence\n    return rasp.Map(lambda x: x, median).named(\"compute_median\")",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            },
            {
                "generated rasp code": "def make_length() -> rasp.SOp:\n    \"\"\"Returns an SOp that computes the length of the input sequence.\"\"\"\n    all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\ndef make_sort_unique(vals: rasp.SOp, keys: rasp.SOp) -> rasp.SOp:\n    \"\"\"Returns an SOp that sorts vals based on keys.\"\"\"\n    smaller = rasp.Select(keys, keys, rasp.Comparison.LT).named(\"smaller\")\n    target_pos = rasp.SelectorWidth(smaller).named(\"target_pos\")\n    sel_new = rasp.Select(target_pos, rasp.indices, rasp.Comparison.EQ)\n    return rasp.Aggregate(sel_new, vals).named(\"sort\")\n\ndef make_sort(max_seq_len: int = 1000, min_val: float = -1e6) -> rasp.SOp:\n    \"\"\"Returns an SOp that sorts the input sequence.\"\"\"\n    keys = rasp.SequenceMap(lambda x, i: x + min_val * i / max_seq_len, rasp.tokens, rasp.indices)\n    return make_sort_unique(rasp.tokens, keys).named(\"sort\")\n\ndef make_compute_median() -> rasp.SOp:\n    \"\"\"Returns an SOp that computes the median of the input sequence.\"\"\"\n    # Sort the input sequence\n    sorted_seq = make_sort().named(\"sorted_seq\")\n    \n    # Get the length of the sequence\n    length = make_length().named(\"length\")\n    \n    # Calculate the middle index\n    middle_index = rasp.Map(lambda x: (x - 1) / 2, length).named(\"middle_index\")\n    \n    # Check if the length is odd\n    is_odd = rasp.Map(lambda x: x % 2 == 1, length).named(\"is_odd\")\n    \n    # Select the middle element for odd-length sequences\n    odd_median_selector = rasp.Select(rasp.indices, middle_index, rasp.Comparison.EQ).named(\"odd_median_selector\")\n    odd_median = rasp.Aggregate(odd_median_selector, sorted_seq).named(\"odd_median\")\n    \n    # Select the two middle elements for even-length sequences\n    lower_middle_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: x - 0.5, middle_index), rasp.Comparison.EQ).named(\"lower_middle_selector\")\n    upper_middle_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: x + 0.5, middle_index), rasp.Comparison.EQ).named(\"upper_middle_selector\")\n    lower_middle = rasp.Aggregate(lower_middle_selector, sorted_seq).named(\"lower_middle\")\n    upper_middle = rasp.Aggregate(upper_middle_selector, sorted_seq).named(\"upper_middle\")\n    \n    # Calculate the average of the two middle elements for even-length sequences\n    even_median = rasp.SequenceMap(lambda x, y: (x + y) / 2, lower_middle, upper_middle).named(\"even_median\")\n    \n    # Choose between odd and even median based on the sequence length\n    median = rasp.SequenceMap(lambda odd, even, is_odd: odd if is_odd else even, odd_median, even_median, is_odd).named(\"median\")\n    \n    # Handle edge cases (empty sequence or single element)\n    edge_case_selector = rasp.Select(length, rasp.Map(lambda x: 2, rasp.tokens), rasp.Comparison.LT).named(\"edge_case_selector\")\n    edge_case_median = rasp.Aggregate(edge_case_selector, rasp.tokens).named(\"edge_case_median\")\n    \n    # Combine edge case and normal case\n    final_median = rasp.SequenceMap(lambda x, y, is_edge: y if is_edge else x, median, edge_case_median, edge_case_selector).named(\"final_median\")\n    \n    return final_median",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            },
            {
                "generated rasp code": "def make_length() -> rasp.SOp:\n    \"\"\"Creates an SOp that returns the length of the input sequence.\"\"\"\n    all_true_selector = rasp.Select(\n        rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\ndef make_sort(max_seq_len: int = 1000, min_key: float = 0) -> rasp.SOp:\n    \"\"\"Returns an SOp that sorts the input sequence.\"\"\"\n    keys = rasp.SequenceMap(lambda x, i: x + min_key * i / max_seq_len, rasp.tokens, rasp.indices)\n    smaller = rasp.Select(keys, keys, rasp.Comparison.LT).named(\"smaller\")\n    target_pos = rasp.SelectorWidth(smaller).named(\"target_pos\")\n    sel_new = rasp.Select(target_pos, rasp.indices, rasp.Comparison.EQ)\n    return rasp.Aggregate(sel_new, rasp.tokens).named(\"sort\")\n\ndef make_compute_median() -> rasp.SOp:\n    \"\"\"Creates an SOp that computes the median of the input sequence.\"\"\"\n    # Sort the input sequence\n    sorted_seq = make_sort().named(\"sorted_seq\")\n    \n    # Get the length of the sequence\n    length = make_length().named(\"length\")\n    \n    # Calculate the middle index (for both odd and even lengths)\n    middle_index = rasp.Map(lambda x: (x - 1) // 2, length).named(\"middle_index\")\n    \n    # Select the middle element (for odd lengths) or the two middle elements (for even lengths)\n    middle_selector = rasp.Select(rasp.indices, middle_index, rasp.Comparison.EQ).named(\"middle_selector\")\n    next_middle_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: x + 1, middle_index), rasp.Comparison.EQ).named(\"next_middle_selector\")\n    \n    # Get the middle element(s)\n    middle_element = rasp.Aggregate(middle_selector, sorted_seq).named(\"middle_element\")\n    next_middle_element = rasp.Aggregate(next_middle_selector, sorted_seq).named(\"next_middle_element\")\n    \n    # Calculate the average of the two middle elements (for even lengths)\n    avg_middle = rasp.SequenceMap(lambda x, y: (x + y) / 2, middle_element, next_middle_element).named(\"avg_middle\")\n    \n    # Determine if the length is odd or even\n    is_odd = rasp.Map(lambda x: x % 2, length).named(\"is_odd\")\n    \n    # Select the correct median (middle element for odd lengths, average for even lengths)\n    median = rasp.SequenceMap(lambda odd, avg, mid: mid if odd else avg, is_odd, avg_middle, middle_element).named(\"median\")\n    \n    # Create a selector to broadcast the median value\n    all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    \n    # Broadcast the median value across the entire sequence\n    return rasp.Aggregate(all_true_selector, median).named(\"median_sequence\")",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            }
        ],
        "make_halve_second_half": [
            {
                "generated rasp code": "def make_halve_second_half() -> rasp.SOp:\n    # Create a function to get the length of the sequence\n    def make_length() -> rasp.SOp:\n        all_true_selector = rasp.Select(\n            rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n        return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n    # Get the length of the sequence\n    length = make_length()\n\n    # Create a selector for the second half of the sequence\n    # For odd-length sequences, this includes the middle element\n    second_half_selector = rasp.Select(\n        rasp.indices,\n        length,\n        lambda idx, len: idx >= (len - 1) / 2\n    ).named(\"second_half_selector\")\n\n    # Create a sequence of 0.5s for the second half and 1s for the first half\n    halving_sequence = rasp.Map(\n        lambda x: 0.5 if x else 1,\n        second_half_selector\n    ).named(\"halving_sequence\")\n\n    # Multiply the original sequence by the halving sequence\n    halved_sequence = rasp.SequenceMap(\n        lambda x, y: x * y,\n        rasp.tokens,\n        halving_sequence\n    ).named(\"halved_sequence\")\n\n    return halved_sequence",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_halve_second_half() -> rasp.SOp:\n    # Calculate the length of the sequence\n    all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    length = rasp.SelectorWidth(all_true_selector).named(\"length\")\n    \n    # Calculate the midpoint (rounded down for odd-length sequences)\n    midpoint = rasp.Map(lambda x: x / 2 - 0.5, length).named(\"midpoint\")\n    \n    # Create a selector for the second half of the sequence\n    second_half_selector = rasp.Select(rasp.indices, midpoint, rasp.Comparison.GT).named(\"second_half_selector\")\n    \n    # Create a sequence of 1s and 0.5s\n    halving_sequence = rasp.Map(lambda x: 0.5 if x else 1, second_half_selector).named(\"halving_sequence\")\n    \n    # Multiply the original sequence by the halving sequence\n    halved_sequence = rasp.SequenceMap(lambda x, y: x * y, rasp.tokens, halving_sequence).named(\"halved_sequence\")\n    \n    return halved_sequence",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_halve_second_half() -> rasp.SOp:\n    # Create a function to calculate the length of the sequence\n    def make_length() -> rasp.SOp:\n        all_true_selector = rasp.Select(\n            rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n        return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n    length = make_length()\n\n    # Calculate the midpoint (rounding up for odd-length sequences)\n    midpoint = rasp.Map(lambda x: (x + 1) // 2, length).named(\"midpoint\")\n\n    # Create a selector for the second half of the sequence\n    second_half_selector = rasp.Select(\n        rasp.indices, midpoint, rasp.Comparison.GE).named(\"second_half_selector\")\n\n    # Create a sequence of 0.5 for the second half and 1 for the first half\n    halving_sequence = rasp.Map(\n        lambda x: 0.5 if x else 1, second_half_selector).named(\"halving_sequence\")\n\n    # Multiply the original sequence by the halving sequence\n    halved_sequence = rasp.SequenceMap(\n        lambda x, y: x * y, rasp.tokens, halving_sequence).named(\"halved_sequence\")\n\n    return halved_sequence",
                "failure stage": 0,
                "error": "GE"
            },
            {
                "generated rasp code": "def make_halve_second_half() -> rasp.SOp:\n    # Calculate the length of the sequence\n    all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    length = rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n    # Calculate the midpoint (length + 1) // 2\n    midpoint = rasp.Map(lambda x: (x + 1) // 2, length).named(\"midpoint\")\n\n    # Create a selector for the second half of the sequence\n    second_half_selector = rasp.Select(rasp.indices, midpoint, rasp.Comparison.GE).named(\"second_half_selector\")\n\n    # Create a sequence of 0.5 for the second half and 1 for the first half\n    halving_sequence = rasp.SequenceMap(lambda x, y: 0.5 if x else 1, second_half_selector, rasp.tokens).named(\"halving_sequence\")\n\n    # Multiply the original sequence with the halving sequence\n    halved_sequence = rasp.SequenceMap(lambda x, y: x * y, rasp.tokens, halving_sequence).named(\"halved_sequence\")\n\n    return halved_sequence",
                "failure stage": 0,
                "error": "GE"
            },
            {
                "generated rasp code": "def make_halve_second_half() -> rasp.SOp:\n    # Create a function to calculate the length of the sequence\n    def make_length() -> rasp.SOp:\n        all_true_selector = rasp.Select(\n            rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n        return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n    length = make_length()\n\n    # Create a selector for the second half of the sequence\n    second_half_selector = rasp.Select(\n        rasp.indices,\n        length,\n        lambda idx, len: idx >= (len - 1) // 2\n    ).named(\"second_half_selector\")\n\n    # Create a sequence of 1s and 0.5s\n    halving_sequence = rasp.Map(\n        lambda x: 0.5 if x else 1,\n        second_half_selector\n    ).named(\"halving_sequence\")\n\n    # Multiply the original sequence by the halving sequence\n    halved_sequence = rasp.SequenceMap(\n        lambda x, y: x * y,\n        rasp.tokens,\n        halving_sequence\n    ).named(\"halved_sequence\")\n\n    return halved_sequence",
                "failure stage": 0,
                "error": ""
            }
        ],
        "make_triple": [],
        "make_arctangent": [
            {
                "generated rasp code": "def make_arctangent() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP SOp that applies the arctangent function to each element of the input sequence.\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that calculates the arctangent of each input element.\n    \"\"\"\n    \n    # Approximate value of \u03c0\n    PI = 3.14159265359\n    \n    def atan_approx(x):\n        \"\"\"\n        Approximates arctangent using a simple algorithm.\n        Handles special cases separately for better accuracy.\n        \"\"\"\n        if x == 0:\n            return 0\n        elif x == 1:\n            return PI / 4\n        elif x == -1:\n            return -PI / 4\n        elif abs(x) > 1e10:  # Treating very large values as infinity\n            return PI / 2 if x > 0 else -PI / 2\n        \n        # Taylor series approximation for |x| < 1\n        if abs(x) < 1:\n            return x - (x**3)/3 + (x**5)/5 - (x**7)/7\n        else:\n            # Using the identity atan(x) = \u03c0/2 - atan(1/x) for |x| > 1\n            return (PI / 2 if x > 0 else -PI / 2) - atan_approx(1/x)\n    \n    # Apply the arctangent approximation to each element of the input sequence\n    return rasp.Map(lambda x: atan_approx(x), rasp.tokens).named(\"arctangent\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [1.249050948259498, 1.4464413330656358, 1.107329064890238, 0.7853981633975, 1.3734008220330953, 1.325818066936369]. (0.972 error rate)"
            },
            {
                "generated rasp code": "def make_arctangent() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that applies the arctangent function to each element of the input sequence.\n    Returns a new sequence where each element is the arctangent of the corresponding input element.\n    Approximates \u03c0/2 for very large values (> 1e10) to handle the case of infinity.\n    \"\"\"\n    # Define constants\n    PI = 3.141592653589793\n    LARGE_VALUE_THRESHOLD = 1e10\n\n    def arctangent(x):\n        # Check if the input is greater than the threshold\n        if x > LARGE_VALUE_THRESHOLD:\n            return PI / 2\n        # For normal values, calculate arctangent\n        return atan(x)\n\n    # Apply the arctangent function to each element of the input sequence\n    return rasp.Map(arctangent, rasp.tokens).named(\"arctangent\")",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_arctangent() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP SOp that applies an approximation of the arctangent function to each element.\n    \"\"\"\n    # Define constants\n    PI = 3.14159265358979323846\n    HALF_PI = PI / 2\n\n    def atan_approx(x):\n        # Piecewise approximation of arctangent\n        if x < -1:\n            return -HALF_PI + atan_approx(1/x)\n        elif x > 1:\n            return HALF_PI - atan_approx(1/x)\n        else:\n            # Approximation for -1 <= x <= 1\n            return x / (1 + 0.28 * x * x)\n\n    def arctangent(x):\n        if x == float('inf'):\n            return HALF_PI\n        elif x == float('-inf'):\n            return -HALF_PI\n        else:\n            return atan_approx(x)\n\n    return rasp.Map(lambda x: arctangent(x), rasp.tokens).named(\"arctangent\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [1.247520464725931, 1.4463408196387049, 1.1035066071687283, 0.78125, 1.3730115166683143, 1.3250960810946508]. (0.987 error rate)"
            },
            {
                "generated rasp code": "def make_arctangent() -> rasp.SOp:\n    # Define pi constant\n    PI = 3.141592653589793\n\n    def arctangent(x):\n        # Check for \"infinity\" (very large number)\n        if x > 1e100:\n            return PI / 2\n        # Calculate arctangent\n        # Use the formula: atan(x) = x / (1 + x^2)^0.5 for -1 <= x <= 1\n        # For |x| > 1, use atan(x) = sign(x) * (pi/2 - atan(1/|x|))\n        if -1 <= x <= 1:\n            return x / ((1 + x * x) ** 0.5)\n        else:\n            sign = 1 if x > 0 else -1\n            return sign * (PI / 2 - (1 / abs(x)) / ((1 + (1 / (x * x))) ** 0.5))\n\n    # Apply arctangent function to each element\n    return rasp.Map(arctangent, rasp.tokens).named(\"arctangent\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [1.2545685607780586, 1.446761592205688, 1.1235827312949387, 0.7071067811865475, 1.3746801916567126, 1.3282607017585635]. (0.987 error rate)"
            }
        ],
        "make_square_each_element": [],
        "make_check_power_of_n": [
            {
                "generated rasp code": "def make_length() -> rasp.SOp:\n    \"\"\"Creates an SOp that returns the length of the input sequence.\"\"\"\n    all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\ndef make_max_element() -> rasp.SOp:\n    \"\"\"Creates an SOp that returns the maximum element in the input sequence.\"\"\"\n    leq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LEQ).named(\"leq_selector\")\n    leq_count = rasp.SelectorWidth(leq_selector).named(\"leq_count\")\n    length = make_length()\n    max_element_selector = rasp.Select(leq_count, length, rasp.Comparison.EQ).named(\"max_element_selector\")\n    return rasp.Aggregate(max_element_selector, rasp.tokens).named(\"max_element\")\n\ndef make_check_power_of_n(n: int = 2) -> rasp.SOp:\n    \"\"\"\n    Creates an SOp that checks if each element in the input sequence is a power of n.\n    \n    Args:\n    n (int): The base number to check powers of. Default is 2.\n    \n    Returns:\n    An SOp that returns 1 for elements that are powers of n, and 0 otherwise.\n    \"\"\"\n    # Get the length and maximum element of the input sequence\n    length = make_length()\n    max_element = make_max_element()\n    \n    # Generate a sequence of powers of n up to the maximum element\n    def generate_powers(x):\n        power = 1\n        powers = [1]  # Start with 1 (n^0)\n        while power <= x:\n            power *= n\n            if power <= x:\n                powers.append(power)\n        return powers\n    \n    powers_of_n = rasp.Map(generate_powers, max_element).named(\"powers_of_n\")\n    \n    # Check if each element is in the powers_of_n sequence\n    is_power_selector = rasp.Select(rasp.tokens, powers_of_n, rasp.Comparison.EQ).named(\"is_power_selector\")\n    \n    # Count how many times each element appears in the powers_of_n sequence\n    power_count = rasp.SelectorWidth(is_power_selector).named(\"power_count\")\n    \n    # Convert to 1 (True) if the element appears at least once, 0 (False) otherwise\n    return rasp.SequenceMap(lambda count, _: 1 if count > 0 else 0, power_count, rasp.tokens).named(\"check_power_of_n\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0, 0, 0, 0, 0, 0]. (0.856 error rate)"
            },
            {
                "generated rasp code": "def make_check_power_of_n(n: int = 2) -> rasp.SOp:\n    def check_power(tokens):\n        # Initial check for 1 (n^0)\n        is_one = rasp.Select(tokens, tokens, lambda x, y: x == 1).named(\"is_one\")\n        result = rasp.Aggregate(is_one, rasp.numerical(tokens), default=0).named(\"initial_result\")\n        \n        # Check for n (n^1)\n        is_n = rasp.Select(tokens, tokens, lambda x, y: x == n).named(\"is_n\")\n        result = rasp.SequenceMap(lambda x, y: max(x, y), result, rasp.Aggregate(is_n, rasp.numerical(tokens), default=0)).named(\"result_with_n\")\n\n        # Initialize current value for division\n        current = rasp.numerical(tokens).named(\"current\")\n\n        # Iterate 32 times (assuming no number in the input requires more than 32 divisions)\n        for _ in range(32):\n            # Check if current is divisible by n\n            is_divisible = rasp.Map(lambda x: x % n == 0 and x != 0, current).named(\"is_divisible\")\n            \n            # Update result: keep 1 if it was 1 before and is still divisible by n\n            result = rasp.SequenceMap(lambda x, y: x * y, result, is_divisible).named(\"updated_result\")\n            \n            # Update current: divide by n if divisible, otherwise set to 0\n            current = rasp.Map(lambda x: x // n if x % n == 0 and x != 0 else 0, current).named(\"updated_current\")\n\n        # Final check: result is 1 if the element was a power of n\n        return rasp.Map(lambda x: 1 if x == 1 else 0, result).named(\"final_result\")\n\n    return rasp.Map(check_power, rasp.tokens).named(\"check_power_of_n\")",
                "failure stage": 0,
                "error": "test_run_op timed out"
            }
        ],
        "make_binarize": [],
        "make_average_first_last": [],
        "make_check_increasing": [
            {
                "generated rasp code": "def make_check_increasing() -> rasp.SOp:\n    # Create a selector that compares each element with its previous element,\n    # starting from the second element (index 1)\n    geq_selector = rasp.Select(\n        rasp.tokens,\n        rasp.Map(lambda x: x-1, rasp.indices),\n        lambda curr, prev: curr >= prev if prev > 0 else True\n    ).named(\"geq_selector\")\n\n    # Count the number of elements that are greater than or equal to their previous element\n    geq_count = rasp.SelectorWidth(geq_selector).named(\"geq_count\")\n\n    # Create a sequence of length - 1 for each element\n    sequence_length_minus_one = rasp.Map(lambda x: len(x) - 1, rasp.tokens).named(\"sequence_length_minus_one\")\n\n    # Compare geq_count with sequence_length_minus_one\n    # If they're equal, all elements (except the first) are greater than or equal to their previous element\n    is_increasing = rasp.SequenceMap(\n        lambda count, length: 1 if count == length else 0,\n        geq_count,\n        sequence_length_minus_one\n    ).named(\"is_increasing\")\n\n    return is_increasing",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def shift_by(offset: int, sop: rasp.SOp, fill: rasp.Value) -> rasp.SOp:\n    \"\"\"Returns the sop, shifted by `offset`, filled with `fill` value.\"\"\"\n    select_off_by_offset = rasp.Select(rasp.indices, rasp.indices,\n                                       lambda k, q: q == k + offset)\n    out = rasp.Aggregate(select_off_by_offset, sop, default=fill)\n    return out.named(f\"shift_by({offset})\")\n\ndef make_check_increasing() -> rasp.SOp:\n    # Shift the input sequence by 1 to the right, filling with the first element\n    shifted = shift_by(1, rasp.tokens, fill=None).named(\"shifted\")\n    \n    # Create a selector that compares each element with its previous one\n    # We use None as the first element of shifted, so we need to handle it separately\n    comparison_selector = rasp.Select(\n        rasp.tokens, \n        shifted, \n        lambda x, y: x >= y if y is not None else True\n    ).named(\"comparison_selector\")\n    \n    # Count the number of True values in the selector\n    true_count = rasp.SelectorWidth(comparison_selector).named(\"true_count\")\n    \n    # Create a sequence of the expected count (length - 1)\n    expected_count = rasp.Map(lambda x: len(x) - 1, rasp.tokens).named(\"expected_count\")\n    \n    # Compare the true count with the expected count\n    # If they're equal, output 1; otherwise, output 0\n    result = rasp.SequenceMap(\n        lambda x, y: 1 if x == y else 0,\n        true_count,\n        expected_count\n    ).named(\"result\")\n    \n    return result",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def shift_by(offset: int, sop: rasp.SOp, fill: rasp.Value) -> rasp.SOp:\n    \"\"\"Returns the sop, shifted by `offset`, filled with `fill` value.\"\"\"\n    select_off_by_offset = rasp.Select(rasp.indices, rasp.indices,\n                                       lambda k, q: q == k + offset)\n    out = rasp.Aggregate(select_off_by_offset, sop, default=fill)\n    return out.named(f\"shift_by({offset})\")\n\ndef make_check_increasing() -> rasp.SOp:\n    # Shift the sequence by 1, filling with the minimum possible value\n    shifted = shift_by(1, rasp.tokens, float('-inf')).named(\"shifted\")\n\n    # Compare each element with its previous (shifted) element\n    comparison = rasp.SequenceMap(lambda x, y: x >= y, rasp.tokens, shifted).named(\"comparison\")\n\n    # Create a selector based on the comparison\n    selector = rasp.Select(comparison, comparison, lambda x, y: x).named(\"selector\")\n\n    # Count how many times the condition is met\n    count = rasp.SelectorWidth(selector).named(\"count\")\n\n    # Create a sequence of length - 1\n    length_minus_one = rasp.Map(lambda x: len(x) - 1, rasp.tokens).named(\"length_minus_one\")\n\n    # Compare the count with length - 1 and output 1 if equal, 0 otherwise\n    output = rasp.SequenceMap(lambda x, y: 1 if x == y else 0, count, length_minus_one).named(\"output\")\n\n    return output",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def shift_by(offset: int, sop: rasp.SOp, fill: rasp.Value) -> rasp.SOp:\n    \"\"\"Returns the sop, shifted by `offset`, filled with `fill` value.\"\"\"\n    select_off_by_offset = rasp.Select(rasp.indices, rasp.indices,\n                                       lambda k, q: q == k + offset)\n    out = rasp.Aggregate(select_off_by_offset, sop, default=fill)\n    return out.named(f\"shift_by({offset})\")\n\ndef make_check_increasing() -> rasp.SOp:\n    # Shift the sequence by 1, filling with the first element\n    shifted = shift_by(1, rasp.tokens, fill=rasp.tokens).named(\"shifted\")\n    \n    # Compare each element with its previous (shifted) element\n    comparison = rasp.SequenceMap(\n        lambda x, y: 1 if x >= y else 0,\n        rasp.tokens,\n        shifted\n    ).named(\"comparison\")\n    \n    # Count the number of times the condition is met\n    condition_count = rasp.SelectorWidth(\n        rasp.Select(comparison, comparison, lambda x, y: x == 1)\n    ).named(\"condition_count\")\n    \n    # Get the sequence length\n    length = rasp.SelectorWidth(\n        rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE)\n    ).named(\"length\")\n    \n    # Check if the condition count equals length - 1\n    is_increasing = rasp.SequenceMap(\n        lambda count, len: 1 if (count == len - 1) or (len == 1) else 0,\n        condition_count,\n        length\n    ).named(\"is_increasing\")\n    \n    # Map the result to the entire sequence\n    return rasp.Map(lambda x: x, is_increasing).named(\"check_increasing\")",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def shift_by(offset: int, sop: rasp.SOp, fill: rasp.Value) -> rasp.SOp:\n    \"\"\"Returns the sop, shifted by `offset`, filled with `fill` value.\"\"\"\n    select_off_by_offset = rasp.Select(rasp.indices, rasp.indices,\n                                       lambda k, q: q == k + offset)\n    out = rasp.Aggregate(select_off_by_offset, sop, default=fill)\n    return out.named(f\"shift_by({offset})\")\n\ndef make_check_increasing() -> rasp.SOp:\n    # Shift the sequence by 1, filling with the minimum possible value\n    shifted = shift_by(1, rasp.tokens, fill=float('-inf')).named(\"shifted\")\n    \n    # Create a selector that identifies where an element is less than its previous element\n    violation_selector = rasp.Select(rasp.tokens, shifted, rasp.Comparison.LT).named(\"violation_selector\")\n    \n    # Count the number of violations\n    violation_count = rasp.SelectorWidth(violation_selector).named(\"violation_count\")\n    \n    # Check if the count of violations is zero for the entire sequence\n    is_increasing = rasp.Map(lambda x: 1 if x == 0 else 0, violation_count).named(\"is_increasing\")\n    \n    return is_increasing",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [1, 0, 0, 0, 1, 0]. (0.827 error rate)"
            }
        ],
        "make_identity": [],
        "make_apply_threshold": [
            {
                "generated rasp code": "def make_apply_threshold(threshold: float = 3) -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that applies a threshold to a sequence, \n    setting elements below the threshold to zero.\n\n    Args:\n    threshold (float): The threshold value. Default is 3.\n\n    Returns:\n    rasp.SOp: A RASP program that applies the threshold.\n    \"\"\"\n    # Create a constant sequence of the threshold value\n    threshold_seq = rasp.Map(lambda x: threshold, rasp.indices).named(\"threshold_seq\")\n\n    # Create a selector that compares each element with the threshold\n    above_threshold = rasp.Select(rasp.tokens, threshold_seq, rasp.Comparison.GEQ).named(\"above_threshold\")\n\n    # Convert the selector to 0 and 1\n    selector_01 = rasp.Map(lambda x: 1 if x else 0, above_threshold).named(\"selector_01\")\n\n    # Multiply the original sequence with the selector\n    thresholded = rasp.SequenceMap(lambda x, y: x * y, rasp.tokens, selector_01).named(\"thresholded\")\n\n    return thresholded",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_apply_threshold(threshold: float = 3) -> rasp.SOp:\n    # Create a constant sequence of the threshold value\n    threshold_sequence = rasp.Map(lambda x: threshold, rasp.indices).named(\"threshold_sequence\")\n    \n    # Create a selector that compares each element with the threshold\n    above_threshold_selector = rasp.Select(rasp.tokens, threshold_sequence, rasp.Comparison.GEQ).named(\"above_threshold_selector\")\n    \n    # Use Aggregate to replace elements below the threshold with zero\n    thresholded_sequence = rasp.Aggregate(above_threshold_selector, rasp.tokens, default=None).named(\"thresholded_sequence\")\n    \n    # Combine the original sequence with the thresholded sequence\n    result = rasp.SequenceMap(\n        lambda x, y: x if y is not None else 0,\n        rasp.tokens,\n        thresholded_sequence\n    ).named(\"apply_threshold_result\")\n    \n    return result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3, 8, 2, 1, 5, 4]. (0.664 error rate)"
            },
            {
                "generated rasp code": "def make_apply_threshold(threshold: float = 3) -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that applies a threshold to a sequence, \n    setting elements below the threshold to zero.\n\n    Args:\n        threshold (float): The threshold value. Default is 3.\n\n    Returns:\n        rasp.SOp: A RASP program that applies the threshold.\n    \"\"\"\n    # Create a sequence of the threshold value\n    threshold_seq = rasp.Map(lambda x: threshold, rasp.tokens).named(\"threshold_seq\")\n\n    # Create a selector that compares each element with the threshold\n    above_threshold = rasp.Select(rasp.tokens, threshold_seq, rasp.Comparison.GEQ).named(\"above_threshold\")\n\n    # Apply the threshold: keep elements above or equal to threshold, set others to zero\n    thresholded = rasp.Aggregate(above_threshold, rasp.tokens).named(\"thresholded\")\n\n    return thresholded",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [5.0, 5.0, 5.0, 5.0, 5.0, 5.0]. (0.925 error rate)"
            }
        ],
        "make_replace_small_tokens": [
            {
                "generated rasp code": "def make_replace_small_tokens(threshold: float = 2) -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that replaces tokens smaller than a threshold with zero.\n    \n    Args:\n    threshold (float): The threshold value. Tokens smaller than this will be replaced with zero. Default is 2.\n    \n    Returns:\n    rasp.SOp: A RASP program that replaces small tokens with zero.\n    \"\"\"\n    # Create a selector that identifies tokens smaller than the threshold\n    small_token_selector = rasp.Select(\n        rasp.tokens,\n        rasp.Map(lambda x: threshold, rasp.tokens),\n        rasp.Comparison.LT\n    ).named(\"small_token_selector\")\n    \n    # Use Aggregate to replace small tokens with zero and keep others unchanged\n    replaced_tokens = rasp.Aggregate(\n        ~small_token_selector,  # Invert the selector to keep tokens >= threshold\n        rasp.tokens,\n        default=0  # Replace small tokens with 0\n    ).named(\"replaced_tokens\")\n    \n    return replaced_tokens",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [4.4, 4.4, 4.4, 4.4, 4.4, 4.4]. (0.881 error rate)"
            },
            {
                "generated rasp code": "def make_replace_small_tokens(threshold: int = 2) -> rasp.SOp:\n    # Create a constant sequence of the threshold value\n    threshold_sequence = rasp.Map(lambda x: threshold, rasp.indices).named(\"threshold_sequence\")\n\n    # Create a selector that compares each token with the threshold\n    geq_selector = rasp.Select(rasp.tokens, threshold_sequence, rasp.Comparison.GEQ).named(\"geq_selector\")\n\n    # Apply the mask to the original sequence:\n    # If the token is greater than or equal to the threshold, keep it; otherwise, replace with 0\n    replaced_sequence = rasp.SequenceMap(\n        lambda x, y: x if y else 0,\n        rasp.tokens,\n        geq_selector\n    ).named(\"replaced_sequence\")\n\n    return replaced_sequence",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_replace_small_tokens(threshold: float = 2) -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that replaces tokens smaller than a threshold with zero.\n    \n    Args:\n    threshold (float): The threshold value. Tokens smaller than this will be replaced with zero. Default is 2.\n    \n    Returns:\n    rasp.SOp: A RASP program that replaces small tokens with zero.\n    \"\"\"\n    # Create a selector for tokens smaller than the threshold\n    small_token_selector = rasp.Select(\n        rasp.tokens,\n        rasp.Map(lambda x: threshold, rasp.tokens),\n        rasp.Comparison.LT\n    ).named(\"small_token_selector\")\n    \n    # Create a sequence of zeros\n    zero_sequence = rasp.Map(lambda x: 0, rasp.tokens).named(\"zero_sequence\")\n    \n    # Replace small tokens with zero, keep others as they are\n    replaced_sequence = rasp.Aggregate(\n        small_token_selector,\n        zero_sequence,\n    ).named(\"replaced_sequence\")\n    \n    # Combine replaced small tokens with original tokens\n    return rasp.SequenceMap(\n        lambda x, y: y if x is None else x,\n        replaced_sequence,\n        rasp.tokens\n    ).named(\"replace_small_tokens\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]. (0.971 error rate)"
            },
            {
                "generated rasp code": "def make_replace_small_tokens(threshold: float = 2) -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that replaces tokens smaller than a threshold with zero.\n    \n    Args:\n    threshold (float): The threshold value. Defaults to 2.\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that replaces small tokens with zero.\n    \"\"\"\n    # Create a constant sequence of the threshold value\n    threshold_sequence = rasp.Map(lambda x: threshold, rasp.tokens).named(\"threshold_sequence\")\n    \n    # Create a selector that identifies tokens smaller than the threshold\n    small_token_selector = rasp.Select(rasp.tokens, threshold_sequence, rasp.Comparison.LT).named(\"small_token_selector\")\n    \n    # Replace small tokens with zero, keep others unchanged\n    replaced_sequence = rasp.SequenceMap(\n        lambda x, y: 0 if y else x,\n        rasp.tokens,\n        small_token_selector\n    ).named(\"replaced_sequence\")\n    \n    return replaced_sequence\n\n# Example usage:\n# replace_small = make_replace_small_tokens()\n# result = replace_small([1, 2, 3, 4, 5])  # Would return [0, 2, 3, 4, 5]",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_replace_small_tokens(threshold: float = 2) -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that replaces tokens smaller than a threshold with zero.\n\n    Args:\n    threshold (float): The threshold value. Defaults to 2.\n\n    Returns:\n    rasp.SOp: A RASP program that replaces small tokens with zero.\n    \"\"\"\n    # Create a selector for tokens smaller than the threshold\n    small_token_selector = rasp.Select(\n        rasp.tokens, \n        rasp.Map(lambda x: threshold, rasp.tokens),\n        rasp.Comparison.LT\n    ).named(\"small_token_selector\")\n\n    # Create a sequence of zeros\n    zero_sequence = rasp.Map(lambda x: 0, rasp.tokens).named(\"zero_sequence\")\n\n    # Combine original tokens and zero sequence based on the selector\n    replaced_sequence = rasp.Aggregate(\n        ~small_token_selector,  # Invert selector to keep large tokens\n        rasp.tokens,\n        default=None  # Use default None as per guidelines\n    ).named(\"replaced_sequence\")\n\n    return replaced_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [4.4, 4.4, 4.4, 4.4, 4.4, 4.4]. (0.91 error rate)"
            }
        ],
        "make_swap_odd_index": [
            {
                "generated rasp code": "def make_swap_odd_index() -> rasp.SOp:\n    # Create a selector for odd indices (excluding the first element)\n    odd_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 1 and x > 0).named(\"odd_selector\")\n    \n    # Create a selector for even indices (excluding the last element if the sequence length is odd)\n    even_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 0 and x > 0).named(\"even_selector\")\n    \n    # Create a selector for the first element\n    first_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == 0).named(\"first_selector\")\n    \n    # Shift odd-indexed elements one position forward\n    shifted_odd = rasp.Aggregate(odd_selector, rasp.Map(lambda x: x, rasp.tokens)).named(\"shifted_odd\")\n    \n    # Shift even-indexed elements one position backward\n    shifted_even = rasp.Aggregate(even_selector, rasp.Map(lambda x: x, rasp.tokens)).named(\"shifted_even\")\n    \n    # Keep the first element unchanged\n    first_element = rasp.Aggregate(first_selector, rasp.tokens).named(\"first_element\")\n    \n    # Combine the shifted sequences and the first element\n    def combine(f, o, e):\n        if f is not None:\n            return f\n        elif o is not None:\n            return o\n        else:\n            return e\n    \n    return rasp.SequenceMap(combine, first_element, shifted_odd, shifted_even).named(\"swap_odd_index\")",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            },
            {
                "generated rasp code": "def make_swap_odd_index() -> rasp.SOp:\n    # Create a selector for odd-indexed elements\n    odd_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 1).named(\"odd_selector\")\n\n    # Create a selector for even-indexed elements (inverse of odd_selector)\n    even_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 0).named(\"even_selector\")\n\n    # Shift odd-indexed elements to the right by 1\n    shifted_odd = rasp.Aggregate(\n        rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y - 1),\n        rasp.Aggregate(odd_selector, rasp.tokens)\n    ).named(\"shifted_odd\")\n\n    # Keep even-indexed elements in place\n    kept_even = rasp.Aggregate(even_selector, rasp.tokens).named(\"kept_even\")\n\n    # Combine the shifted odd-indexed elements and the kept even-indexed elements\n    swapped_sequence = rasp.SequenceMap(\n        lambda x, y: x if x is not None else y,\n        shifted_odd,\n        kept_even\n    ).named(\"swapped_sequence\")\n\n    return swapped_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, 4.333333333333333, 4.333333333333333, 4.333333333333333, 4.333333333333333, 4.333333333333333]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_swap_odd_index() -> rasp.SOp:\n    # Create a selector for odd-indexed positions\n    odd_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 1).named(\"odd_selector\")\n    \n    # Create a selector for even-indexed positions\n    even_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 0).named(\"even_selector\")\n    \n    # Shift odd-indexed elements one position to the right\n    shifted_odd = rasp.Aggregate(\n        rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y - 1),\n        rasp.Aggregate(odd_selector, rasp.tokens)\n    ).named(\"shifted_odd\")\n    \n    # Keep even-indexed elements in place\n    unchanged_even = rasp.Aggregate(even_selector, rasp.tokens).named(\"unchanged_even\")\n    \n    # Combine shifted odd-indexed elements and unchanged even-indexed elements\n    swapped_sequence = rasp.SequenceMap(\n        lambda x, y: x if x is not None else y,\n        shifted_odd,\n        unchanged_even\n    ).named(\"swapped_sequence\")\n    \n    return swapped_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, 4.333333333333333, 4.333333333333333, 4.333333333333333, 4.333333333333333, 4.333333333333333]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_swap_odd_index() -> rasp.SOp:\n    # Create a selector for odd indices (1-based, so even indices in 0-based counting)\n    odd_index_selector = rasp.Select(\n        rasp.indices,\n        rasp.indices,\n        lambda x, y: x % 2 == 0\n    ).named(\"odd_index_selector\")\n\n    # Create a selector for the elements following odd indices\n    next_element_selector = rasp.Select(\n        rasp.indices,\n        rasp.indices,\n        lambda x, y: x % 2 == 1\n    ).named(\"next_element_selector\")\n\n    # Swap elements at odd indices with their following elements\n    swapped_sequence = rasp.SequenceMap(\n        lambda x, y: y if x else x,\n        odd_index_selector,\n        rasp.Aggregate(next_element_selector, rasp.tokens)\n    ).named(\"swapped_sequence\")\n\n    return swapped_sequence",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_swap_odd_index() -> rasp.SOp:\n    # Create a selector for odd-indexed positions\n    odd_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 1).named(\"odd_selector\")\n    \n    # Create a selector for even-indexed positions\n    even_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 0).named(\"even_selector\")\n    \n    # Shift odd-indexed elements one position to the left\n    shift_odd_left = rasp.Aggregate(\n        rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y - 1),\n        rasp.Aggregate(odd_selector, rasp.tokens)\n    ).named(\"shift_odd_left\")\n    \n    # Shift even-indexed elements one position to the right\n    shift_even_right = rasp.Aggregate(\n        rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y + 1),\n        rasp.Aggregate(even_selector, rasp.tokens)\n    ).named(\"shift_even_right\")\n    \n    # Combine the shifted sequences\n    swapped_sequence = rasp.SequenceMap(\n        lambda x, y: x if x is not None else y,\n        shift_odd_left,\n        shift_even_right\n    ).named(\"swapped_sequence\")\n    \n    return swapped_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, 4.333333333333333, 4.333333333333333, 4.333333333333333, 4.333333333333333, None]. (1.0 error rate)"
            }
        ],
        "make_check_descending": [
            {
                "generated rasp code": "def make_check_descending() -> rasp.SOp:\n    # Create a shifted sequence for comparison\n    shifted_sequence = rasp.SequenceMap(lambda x, y: y, rasp.tokens, rasp.Map(lambda x: None, rasp.tokens)).named(\"shifted_sequence\")\n    \n    # Selector that compares each element with its next element\n    geq_selector = rasp.Select(rasp.tokens, shifted_sequence, rasp.Comparison.GEQ).named(\"geq_selector\")\n    \n    # Count the number of true comparisons\n    geq_count = rasp.SelectorWidth(geq_selector).named(\"geq_count\")\n    \n    # Create a sequence of length - 1\n    length_minus_one = rasp.Map(lambda x: len(x) - 1, rasp.tokens).named(\"length_minus_one\")\n    \n    # Check if all comparisons are true\n    all_descending = rasp.Select(geq_count, length_minus_one, rasp.Comparison.EQ).named(\"all_descending\")\n    \n    # Aggregate to check if any comparison is false\n    any_false = rasp.Aggregate(all_descending, rasp.Map(lambda x: False, rasp.tokens), default=None).named(\"any_false\")\n    \n    # Convert boolean result to 1 (descending) or 0 (not descending)\n    return rasp.Map(lambda x: 1 if x else 0, any_false).named(\"check_descending\")",
                "failure stage": 1,
                "error": "query is None!"
            },
            {
                "generated rasp code": "def shift_by(offset: int, sop: rasp.SOp, fill: rasp.Value) -> rasp.SOp:\n    \"\"\"Returns the sop, shifted by `offset`, filled with `fill` value.\"\"\"\n    select_off_by_offset = rasp.Select(rasp.indices, rasp.indices,\n                                       lambda k, q: q == k + offset)\n    out = rasp.Aggregate(select_off_by_offset, sop, default=fill)\n    return out.named(f\"shift_by({offset})\")\n\ndef make_check_descending() -> rasp.SOp:\n    # Create a selector that compares each element with its next element\n    geq_selector = rasp.Select(rasp.tokens, shift_by(1, rasp.tokens, float('-inf')), rasp.Comparison.GEQ).named(\"geq_selector\")\n\n    # Shift the selector by 1 to align with the original sequence\n    shifted_selector = shift_by(-1, geq_selector, True).named(\"shifted_selector\")\n\n    # Count the number of correct comparisons for each position\n    correct_comparisons = rasp.SelectorWidth(shifted_selector).named(\"correct_comparisons\")\n\n    # Create a sequence of expected comparisons (length - 1)\n    expected_comparisons = rasp.Map(lambda x: len(x) - 1, rasp.tokens).named(\"expected_comparisons\")\n\n    # Compare the count of correct comparisons with the expected count\n    is_descending = rasp.SequenceMap(lambda x, y: x >= y, correct_comparisons, expected_comparisons).named(\"is_descending\")\n\n    # Convert the comparison result to 1 (True) or 0 (False)\n    return rasp.Map(lambda x: 1 if x else 0, is_descending).named(\"check_descending\")",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_check_descending() -> rasp.SOp:\n    # Create a shifted version of the input sequence\n    # The first element is replaced with a value that ensures the comparison is always true\n    shifted_sequence = rasp.SequenceMap(\n        lambda x, y: x if y > 0 else float('inf'),\n        rasp.tokens,\n        rasp.indices\n    ).named(\"shifted_sequence\")\n\n    # Create a selector that compares each element with its predecessor\n    descending_selector = rasp.Select(\n        rasp.tokens,\n        shifted_sequence,\n        rasp.Comparison.GEQ\n    ).named(\"descending_selector\")\n\n    # Count the number of valid comparisons\n    descending_count = rasp.SelectorWidth(descending_selector).named(\"descending_count\")\n\n    # Compare the count with the indices\n    is_descending = rasp.SequenceMap(\n        lambda count, index: count == index + 1,\n        descending_count,\n        rasp.indices\n    ).named(\"is_descending\")\n\n    # Convert boolean to 1 (True) or 0 (False)\n    return rasp.Map(lambda x: 1 if x else 0, is_descending).named(\"check_descending\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0, 0, 0, 0, 0, 0]. (0.65 error rate)"
            },
            {
                "generated rasp code": "def shift_by(offset: int, sop: rasp.SOp, fill: rasp.Value) -> rasp.SOp:\n    \"\"\"Returns the sop, shifted by `offset`, filled with `fill` value.\"\"\"\n    select_off_by_offset = rasp.Select(rasp.indices, rasp.indices,\n                                       lambda k, q: q == k + offset)\n    out = rasp.Aggregate(select_off_by_offset, sop, default=fill)\n    return out.named(f\"shift_by({offset})\")\n\ndef make_running_product() -> rasp.SOp:\n    \"\"\"Creates an SOp that computes the running product of a sequence of 0s and 1s.\"\"\"\n    def running_product(x, y):\n        return x * y if y is not None else x\n    \n    all_true_selector = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.LEQ).named(\"all_true_selector\")\n    return rasp.Aggregate(all_true_selector, rasp.tokens, running_product).named(\"running_product\")\n\ndef make_check_descending() -> rasp.SOp:\n    \"\"\"Creates an SOp that checks if a sequence is in descending order.\"\"\"\n    \n    # Shift the sequence by 1 to the right, filling with a very small number\n    shifted = shift_by(1, rasp.tokens, fill=float('-inf')).named(\"shifted\")\n    \n    # Compare each element with its right neighbor\n    # The last element is always considered \"descending\" as it has no right neighbor\n    comparisons = rasp.SequenceMap(\n        lambda x, y: x >= y if y != float('-inf') else True,\n        rasp.tokens,\n        shifted\n    ).named(\"comparisons\")\n    \n    # Convert boolean comparisons to 1 (True) or 0 (False)\n    binary_comparisons = rasp.Map(lambda x: 1 if x else 0, comparisons).named(\"binary_comparisons\")\n    \n    # Compute the running product to check if all comparisons up to each point are True\n    running_product = make_running_product()\n    \n    return rasp.SequenceMap(lambda x, y: x * y, binary_comparisons, running_product).named(\"check_descending\")",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_check_descending() -> rasp.SOp:\n    # Create a selector that compares each element with its next element\n    geq_selector = rasp.Select(rasp.tokens, shift_by(1, rasp.tokens, fill=float('-inf')), rasp.Comparison.GEQ).named(\"geq_selector\")\n\n    # Count the number of comparisons that are true for each element\n    geq_count = rasp.SelectorWidth(geq_selector).named(\"geq_count\")\n\n    # Create a sequence where each element is the length of the sequence minus 1\n    length = make_length()\n    expected_count = rasp.Map(lambda x: x - 1, length).named(\"expected_count\")\n\n    # Compare the actual count with the expected count\n    is_descending = rasp.SequenceMap(lambda x, y: x >= y, geq_count, expected_count).named(\"is_descending\")\n\n    # Convert boolean result to 1 (true) or 0 (false)\n    result = rasp.Map(lambda x: 1 if x else 0, is_descending).named(\"result\")\n\n    return result\n\n# Helper functions\n\ndef make_length() -> rasp.SOp:\n    \"\"\"Creates the `length` SOp using selector width primitive.\"\"\"\n    all_true_selector = rasp.Select(\n        rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\ndef shift_by(offset: int, sop: rasp.SOp, fill: rasp.Value) -> rasp.SOp:\n    \"\"\"Returns the sop, shifted by `offset`, filled with `fill` value.\"\"\"\n    select_off_by_offset = rasp.Select(rasp.indices, rasp.indices,\n                                       lambda k, q: q == k + offset)\n    out = rasp.Aggregate(select_off_by_offset, sop, default=fill)\n    return out.named(f\"shift_by({offset})\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [1, 0, 0, 1, 1, 0]. (0.827 error rate)"
            }
        ],
        "make_rotate_left": [
            {
                "generated rasp code": "def make_rotate_left() -> rasp.SOp:\n    # Calculate the length of the sequence\n    all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    length = rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n    # Create a sequence of indices modulo the length of the sequence\n    modulo_indices = rasp.SequenceMap(lambda x, y: (x + 1) % y, rasp.indices, length).named(\"modulo_indices\")\n\n    # Create a selector that selects each element's right neighbor\n    rotate_selector = rasp.Select(modulo_indices, rasp.indices, rasp.Comparison.EQ).named(\"rotate_selector\")\n\n    # Use Aggregate to shift the elements based on the selector\n    rotated_sequence = rasp.Aggregate(rotate_selector, rasp.tokens).named(\"rotated_sequence\")\n\n    return rotated_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [4.0, 3.0, 8.0, 2.0, 1.0, 5.0]. (0.789 error rate)"
            },
            {
                "generated rasp code": "def make_rotate_left() -> rasp.SOp:\n    def make_length() -> rasp.SOp:\n        \"\"\"Creates the `length` SOp using selector width primitive.\"\"\"\n        all_true_selector = rasp.Select(\n            rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n        return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n    # Get the length of the sequence\n    length = make_length()\n\n    # Create a selector that shifts indices to the left by 1, wrapping around\n    rotate_selector = rasp.Select(\n        rasp.indices,\n        rasp.SequenceMap(lambda x, y: (x - 1) % y, rasp.indices, length),\n        rasp.Comparison.EQ\n    ).named(\"rotate_selector\")\n\n    # Use Aggregate to rearrange the elements based on the selector\n    rotated_sequence = rasp.Aggregate(rotate_selector, rasp.tokens).named(\"rotated_sequence\")\n\n    return rotated_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [4.0, 3.0, 8.0, 2.0, 1.0, 5.0]. (0.789 error rate)"
            },
            {
                "generated rasp code": "def make_rotate_left() -> rasp.SOp:\n    def make_length() -> rasp.SOp:\n        \"\"\"Creates the `length` SOp.\"\"\"\n        all_true_selector = rasp.Select(\n            rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n        return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n    # Get the length of the sequence\n    length = make_length()\n\n    # Create a selector that maps each index to the previous index (or the last index for the first element)\n    rotate_selector = rasp.Select(\n        rasp.indices,\n        rasp.SequenceMap(lambda x, y: (x - 1) % y, rasp.indices, length),\n        rasp.Comparison.EQ\n    ).named(\"rotate_selector\")\n\n    # Use Aggregate to rotate all elements in one step\n    rotated_sequence = rasp.Aggregate(rotate_selector, rasp.tokens, default=None).named(\"rotated_sequence\")\n\n    return rotated_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [4.0, 3.0, 8.0, 2.0, 1.0, 5.0]. (0.789 error rate)"
            },
            {
                "generated rasp code": "def make_rotate_left() -> rasp.SOp:\n    # Calculate the length of the sequence\n    all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    length = rasp.SelectorWidth(all_true_selector).named(\"length\")\n    \n    # Create a sequence of indices modulo the sequence length\n    # This creates the wraparound effect: [0, 1, 2, ..., n-1, 0]\n    modulo_indices = rasp.SequenceMap(lambda x, y: (x + 1) % y, rasp.indices, length).named(\"modulo_indices\")\n    \n    # Create a selector that selects each element's right neighbor\n    # (or the first element for the last position)\n    rotate_selector = rasp.Select(modulo_indices, rasp.indices, rasp.Comparison.EQ).named(\"rotate_selector\")\n    \n    # Use Aggregate to shift the elements based on the selector\n    rotated_sequence = rasp.Aggregate(rotate_selector, rasp.tokens).named(\"rotated_sequence\")\n    \n    return rotated_sequence\n\n# Example usage:\n# rotate_left = make_rotate_left()\n# rotate_left([1, 2, 3, 4]) would return [2, 3, 4, 1]",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [4.0, 3.0, 8.0, 2.0, 1.0, 5.0]. (0.789 error rate)"
            }
        ],
        "make_remove_duplicates": [],
        "make_scale_by_max": [
            {
                "generated rasp code": "def make_scale_by_max() -> rasp.SOp:\n    # Find the maximum value in the sequence\n    # Create a selector that compares each element with every other element\n    leq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LEQ).named(\"leq_selector\")\n    \n    # Count the number of elements that each element is less than or equal to\n    leq_count = rasp.SelectorWidth(leq_selector).named(\"leq_count\")\n    \n    # Create a sequence of the length of the input\n    length = rasp.SelectorWidth(rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE)).named(\"length\")\n    \n    # Select the maximum element (where leq_count equals length)\n    max_selector = rasp.Select(leq_count, length, rasp.Comparison.EQ).named(\"max_selector\")\n    \n    # Get the maximum value\n    max_value = rasp.Aggregate(max_selector, rasp.tokens).named(\"max_value\")\n    \n    # Check if max_value is zero\n    is_max_zero = rasp.SequenceMap(lambda x, y: x == 0, max_value, rasp.tokens).named(\"is_max_zero\")\n    \n    # If max_value is zero, return all zeros. Otherwise, divide each element by max_value\n    scaled_sequence = rasp.SequenceMap(\n        lambda x, y: 0 if x else (y / max_value[0] if max_value[0] is not None else None),\n        is_max_zero,\n        rasp.tokens\n    ).named(\"scaled_sequence\")\n    \n    return scaled_sequence",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_scale_by_max() -> rasp.SOp:\n    def make_max() -> rasp.SOp:\n        # Selector that creates a comparison matrix where each element is compared to every other element\n        leq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LEQ).named(\"leq_selector\")\n        \n        # Count the number of comparisons where each element is less than or equal to other elements\n        leq_count = rasp.SelectorWidth(leq_selector).named(\"leq_count\")\n        \n        # Create a sequence of the length of the input\n        length = rasp.Map(lambda x: 1, rasp.tokens).named(\"length\")\n        sequence_length = rasp.Aggregate(rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE), length).named(\"sequence_length\")\n        \n        # Selector that selects the element where the leq_count equals the sequence_length\n        max_element_selector = rasp.Select(leq_count, sequence_length, rasp.Comparison.EQ).named(\"max_element_selector\")\n        \n        # Use Aggregate to broadcast the maximum element across the entire sequence\n        max_sequence = rasp.Aggregate(max_element_selector, rasp.tokens).named(\"max_sequence\")\n        \n        return max_sequence\n\n    # Find the maximum value in the sequence\n    max_value = make_max()\n\n    # Replace zero with 1 if the maximum is zero to avoid division by zero\n    safe_max = rasp.Map(lambda x: 1 if x == 0 else x, max_value).named(\"safe_max\")\n\n    # Divide each element by the safe maximum value\n    scaled_sequence = rasp.SequenceMap(lambda x, y: x / y if y != 0 else 0, rasp.tokens, safe_max).named(\"scaled_sequence\")\n\n    return scaled_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3.0, 8.0, 2.0, 1.0, 5.0, 4.0]. (0.907 error rate)"
            },
            {
                "generated rasp code": "def make_scale_by_max() -> rasp.SOp:\n    # Find the maximum value in the sequence\n    \n    # Selector that creates a comparison matrix where each element is compared to every other element.\n    leq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LEQ).named(\"leq_selector\")\n\n    # Count the number of comparisons where each element is less than or equal to other elements.\n    leq_count = rasp.SelectorWidth(leq_selector).named(\"leq_count\")\n\n    # Create a sequence of the length of the input\n    sequence_length = rasp.Map(lambda x: 1, rasp.tokens).named(\"sequence_length\")\n\n    # Selector that selects the element where the leq_count equals the sequence_length.\n    max_element_selector = rasp.Select(leq_count, sequence_length, rasp.Comparison.EQ).named(\"max_element_selector\")\n\n    # Use Aggregate to broadcast the maximum element across the entire sequence.\n    max_sequence = rasp.Aggregate(max_element_selector, rasp.tokens).named(\"max_sequence\")\n\n    # Check if the maximum is zero\n    is_max_zero = rasp.Map(lambda x: x == 0, max_sequence).named(\"is_max_zero\")\n\n    # Create a sequence of zeros\n    zero_sequence = rasp.Map(lambda x: 0, rasp.tokens).named(\"zero_sequence\")\n\n    # Divide each element by the maximum, but return 0 if the maximum is 0\n    scaled_sequence = rasp.SequenceMap(\n        lambda x, y: 0 if y else (x / max_sequence[0] if max_sequence[0] != 0 else 0),\n        rasp.tokens,\n        is_max_zero\n    ).named(\"scaled_sequence\")\n\n    return scaled_sequence",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_scale_by_max() -> rasp.SOp:\n    # Find the maximum value in the sequence\n    def make_max() -> rasp.SOp:\n        # Selector that creates a comparison matrix where each element is compared to every other element\n        leq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LEQ).named(\"leq_selector\")\n        \n        # Count the number of comparisons where each element is less than or equal to other elements\n        leq_count = rasp.SelectorWidth(leq_selector).named(\"leq_count\")\n        \n        # Create a sequence of the length of the input\n        sequence_length = rasp.Map(lambda x: 1, rasp.tokens).named(\"sequence_length\")\n        \n        # Selector that selects the element where the leq_count equals the sequence_length\n        max_element_selector = rasp.Select(leq_count, sequence_length, rasp.Comparison.EQ).named(\"max_element_selector\")\n        \n        # Use Aggregate to broadcast the maximum element across the entire sequence\n        max_sequence = rasp.Aggregate(max_element_selector, rasp.tokens).named(\"max_sequence\")\n        \n        return max_sequence\n\n    max_value = make_max()\n\n    # Check if max_value is zero\n    is_zero = rasp.Select(max_value, max_value, lambda x, y: x == 0).named(\"is_zero\")\n    \n    # If max_value is zero, return a sequence of zeros\n    zero_sequence = rasp.Map(lambda x: 0, rasp.tokens).named(\"zero_sequence\")\n    \n    # If max_value is not zero, divide each element by max_value\n    scaled_sequence = rasp.SequenceMap(lambda x, y: x / y if y != 0 else 0, rasp.tokens, max_value).named(\"scaled_sequence\")\n    \n    # Use Aggregate to choose between zero_sequence and scaled_sequence based on is_zero\n    result = rasp.Aggregate(is_zero, zero_sequence, default=None).named(\"result\")\n    result = rasp.SequenceMap(lambda x, y: y if x is None else x, result, scaled_sequence).named(\"final_result\")\n\n    return result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, None, None, None, None, None]. (0.99 error rate)"
            },
            {
                "generated rasp code": "def make_scale_by_max() -> rasp.SOp:\n    # Create a selector that compares each element with every other element\n    leq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LEQ).named(\"leq_selector\")\n\n    # Count the number of elements that each element is less than or equal to\n    leq_count = rasp.SelectorWidth(leq_selector).named(\"leq_count\")\n\n    # Create a sequence of the length of the input\n    sequence_length = rasp.Map(lambda x: 1, rasp.tokens).named(\"sequence_length\")\n\n    # Select the maximum element (where leq_count equals sequence_length)\n    max_element_selector = rasp.Select(leq_count, sequence_length, rasp.Comparison.EQ).named(\"max_element_selector\")\n\n    # Get the maximum value\n    max_value = rasp.Aggregate(max_element_selector, rasp.tokens).named(\"max_value\")\n\n    # Check if max_value is 0\n    is_max_zero = rasp.Map(lambda x: x == 0, max_value).named(\"is_max_zero\")\n\n    # Create a sequence of zeros\n    zeros = rasp.Map(lambda x: 0, rasp.tokens).named(\"zeros\")\n\n    # Divide each element by the maximum value, but return 0 if max_value is 0\n    scaled_sequence = rasp.SequenceMap(\n        lambda x, y: 0 if y else (x / max_value if max_value != 0 else 0),\n        rasp.tokens,\n        is_max_zero\n    ).named(\"scaled_sequence\")\n\n    return scaled_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [<tracr.rasp.rasp.Map object at 0x34a7d8d30>, <tracr.rasp.rasp.Map object at 0x34a7d9db0>, <tracr.rasp.rasp.Map object at 0x34a7dbdf0>, <tracr.rasp.rasp.Map object at 0x34a7d9510>, <tracr.rasp.rasp.Map object at 0x34a7d9540>, <tracr.rasp.rasp.Map object at 0x34a7d8d00>]. (0.545 error rate)"
            }
        ],
        "make_sum_with_next": [
            {
                "generated rasp code": "def make_sum_with_next() -> rasp.SOp:\n    # Create a selector that shifts the sequence by one position to the left\n    shift_selector = rasp.Select(\n        rasp.indices,\n        rasp.indices,\n        lambda x, y: x == y + 1\n    ).named(\"shift_selector\")\n\n    # Create the shifted sequence\n    shifted_sequence = rasp.Aggregate(\n        shift_selector,\n        rasp.tokens,\n        default=None\n    ).named(\"shifted_sequence\")\n\n    # Create a selector for the last element\n    last_element_selector = rasp.Select(\n        rasp.indices,\n        rasp.SequenceMap(lambda x, y: x == y - 1, rasp.indices, make_length()),\n        rasp.Comparison.EQ\n    ).named(\"last_element_selector\")\n\n    # Get the last element\n    last_element = rasp.Aggregate(\n        last_element_selector,\n        rasp.tokens,\n        default=None\n    ).named(\"last_element\")\n\n    # Combine the shifted sequence with the last element\n    combined_sequence = rasp.SequenceMap(\n        lambda x, y: y if x is None else x,\n        shifted_sequence,\n        last_element\n    ).named(\"combined_sequence\")\n\n    # Sum the original sequence with the combined sequence\n    sum_with_next = rasp.SequenceMap(\n        lambda x, y: x + y,\n        rasp.tokens,\n        combined_sequence\n    ).named(\"sum_with_next\")\n\n    return sum_with_next\n\ndef make_length() -> rasp.SOp:\n    all_true_selector = rasp.Select(\n        rasp.tokens, rasp.tokens, rasp.Comparison.TRUE\n    ).named(\"all_true_selector\")\n    return rasp.SelectorWidth(all_true_selector).named(\"length\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [11.0, 10.0, 3.0, 6.0, 9.0, None]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_sum_with_next() -> rasp.SOp:\n    # Create a selector that shifts indices by 1 (selecting the next element)\n    shift_selector = rasp.Select(\n        rasp.indices,\n        rasp.indices,\n        lambda x, y: x == y + 1\n    ).named(\"shift_selector\")\n\n    # Create a selector for the last element\n    last_elem_selector = rasp.Select(\n        rasp.indices,\n        rasp.indices,\n        lambda x, y: x == y\n    ).named(\"last_elem_selector\")\n\n    # Combine the selectors to create a shifted sequence with repeated last element\n    shifted_sequence = rasp.Aggregate(\n        shift_selector | last_elem_selector,\n        rasp.tokens\n    ).named(\"shifted_sequence\")\n\n    # Sum the original sequence with the shifted sequence\n    sum_with_next = rasp.SequenceMap(\n        lambda x, y: x + y,\n        rasp.tokens,\n        shifted_sequence\n    ).named(\"sum_with_next\")\n\n    return sum_with_next",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [8.5, 13.0, 3.5, 4.0, 9.5, 8.0]. (0.887 error rate)"
            },
            {
                "generated rasp code": "def make_sum_with_next() -> rasp.SOp:\n    # Create a selector that shifts the sequence by one position to the left\n    shift_selector = rasp.Select(\n        rasp.indices,\n        rasp.indices,\n        lambda x, y: (x == y + 1) or (y == rasp.SelectorWidth(rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE)) - 1)\n    ).named(\"shift_selector\")\n\n    # Use Aggregate to create the shifted sequence\n    shifted_sequence = rasp.Aggregate(shift_selector, rasp.tokens, default=None).named(\"shifted_sequence\")\n\n    # Sum the original sequence with the shifted sequence\n    sum_with_next = rasp.SequenceMap(\n        lambda x, y: x + y,\n        rasp.tokens,\n        shifted_sequence\n    ).named(\"sum_with_next\")\n\n    return sum_with_next",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [6.833333333333334, 11.833333333333334, 5.833333333333334, 4.833333333333334, 8.833333333333334, 7.833333333333334]. (0.887 error rate)"
            },
            {
                "generated rasp code": "def make_sum_with_next() -> rasp.SOp:\n    # Create a selector that shifts the sequence by one position to the left\n    shift_selector = rasp.Select(\n        rasp.indices,\n        rasp.indices,\n        lambda x, y: x == y + 1\n    ).named(\"shift_selector\")\n\n    # Create the shifted sequence, duplicating the last element\n    shifted_sequence = rasp.Aggregate(\n        shift_selector,\n        rasp.tokens,\n        default=None  # Default must be None for compilation\n    ).named(\"shifted_sequence\")\n\n    # Create a selector for the last element\n    last_elem_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: len(x) - 1, rasp.tokens),\n        rasp.Comparison.EQ\n    ).named(\"last_elem_selector\")\n\n    # Get the last element\n    last_elem = rasp.Aggregate(last_elem_selector, rasp.tokens).named(\"last_elem\")\n\n    # Replace None values (which will only be in the last position) with the last element\n    shifted_sequence_fixed = rasp.SequenceMap(\n        lambda x, y: y if x is None else x,\n        shifted_sequence,\n        last_elem\n    ).named(\"shifted_sequence_fixed\")\n\n    # Add the original sequence and the shifted sequence\n    return rasp.SequenceMap(\n        lambda x, y: x + y,\n        rasp.tokens,\n        shifted_sequence_fixed\n    ).named(\"sum_with_next\")",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_sum_with_next() -> rasp.SOp:\n    # Create a selector that shifts indices by 1 to the left\n    shift_selector = rasp.Select(\n        rasp.indices,\n        rasp.indices,\n        lambda x, y: (x == y + 1) or (x == y and y == rasp.SelectorWidth(rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.TRUE)) - 1)\n    ).named(\"shift_selector\")\n\n    # Create the shifted sequence\n    shifted_sequence = rasp.Aggregate(shift_selector, rasp.tokens, default=None).named(\"shifted_sequence\")\n\n    # Add the original sequence with the shifted sequence\n    sum_with_next = rasp.SequenceMap(\n        lambda x, y: x + y,\n        rasp.tokens,\n        shifted_sequence\n    ).named(\"sum_with_next\")\n\n    return sum_with_next",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [8.5, 13.0, 3.5, 4.0, 9.5, 8.0]. (0.887 error rate)"
            }
        ],
        "make_swap_elements": [
            {
                "generated rasp code": "def make_swap_elements(swap_indices=[0, 1]):\n    def swap(tokens):\n        # Create a sequence containing the length of the input\n        length = rasp.SequenceMap(lambda x, y: len(x), tokens, tokens).named(\"length\")\n        \n        # Check if the sequence has only one element\n        single_element_check = rasp.Select(length, rasp.Map(lambda x: 1, rasp.indices), rasp.Comparison.EQ).named(\"single_element_check\")\n        \n        # Create selectors for the indices to be swapped\n        selector1 = rasp.Select(rasp.indices, rasp.Map(lambda x: swap_indices[0], rasp.indices), rasp.Comparison.EQ).named(\"selector1\")\n        selector2 = rasp.Select(rasp.indices, rasp.Map(lambda x: swap_indices[1], rasp.indices), rasp.Comparison.EQ).named(\"selector2\")\n        \n        # Swap the elements\n        element1 = rasp.Aggregate(selector2, tokens, default=None).named(\"element1\")\n        element2 = rasp.Aggregate(selector1, tokens, default=None).named(\"element2\")\n        \n        # Combine the swapped elements with the original sequence\n        swapped = rasp.SequenceMap(\n            lambda x, y, z: y if z == swap_indices[0] else (x if z == swap_indices[1] else z),\n            element1, element2, tokens\n        ).named(\"swapped\")\n        \n        # Return [None] if the input has only one element, otherwise return the swapped sequence\n        return rasp.SequenceMap(\n            lambda x, y: None if x else y,\n            single_element_check, swapped\n        ).named(\"result\")\n    \n    return swap\n\n# Usage:\n# swap_elements = make_swap_elements()\n# or\n# swap_elements = make_swap_elements([2, 3])",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_swap_elements(index1=0, index2=1):\n    def swap_elements(tokens):\n        # Get the length of the sequence\n        all_true_selector = rasp.Select(tokens, tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n        length = rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n        # Handle single-element input\n        single_element_case = rasp.Select(length, rasp.Map(lambda x: 1, tokens), rasp.Comparison.EQ).named(\"single_element_case\")\n        none_sequence = rasp.Map(lambda x: None, tokens).named(\"none_sequence\")\n\n        # Create selectors for the swap indices\n        selector1 = rasp.Select(rasp.indices, rasp.Map(lambda x: index1, tokens), rasp.Comparison.EQ).named(\"selector1\")\n        selector2 = rasp.Select(rasp.indices, rasp.Map(lambda x: index2, tokens), rasp.Comparison.EQ).named(\"selector2\")\n\n        # Broadcast the elements to be swapped\n        element1 = rasp.Aggregate(selector1, tokens).named(\"element1\")\n        element2 = rasp.Aggregate(selector2, tokens).named(\"element2\")\n\n        # Create a selector for all positions except the swap indices\n        other_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x != index1 and x != index2).named(\"other_selector\")\n\n        # Combine the swapped elements with the original sequence\n        swapped_sequence = rasp.SequenceMap(\n            lambda x, y, z, w: y if w == index1 else (x if w == index2 else z),\n            element2, element1, tokens, rasp.indices\n        ).named(\"swapped_sequence\")\n\n        # Return the swapped sequence or [None] for single-element input\n        return rasp.SequenceMap(\n            lambda x, y: x if y else None,\n            swapped_sequence, ~single_element_case\n        ).named(\"result\")\n\n    return swap_elements",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_swap_elements(swap_index1: int = 0, swap_index2: int = 1) -> rasp.SOp:\n    \"\"\"\n    Creates a RASP SOp that swaps two elements at specified indices.\n    Default indices are 0 and 1.\n    \"\"\"\n    def swap_elements(tokens: rasp.SOp) -> rasp.SOp:\n        # Create selectors for the swap indices\n        selector1 = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == swap_index1).named(\"selector1\")\n        selector2 = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == swap_index2).named(\"selector2\")\n\n        # Aggregate to swap the elements\n        swapped1 = rasp.Aggregate(selector2, tokens).named(\"swapped1\")\n        swapped2 = rasp.Aggregate(selector1, tokens).named(\"swapped2\")\n\n        # Combine the swapped elements with the original sequence\n        result = rasp.SequenceMap(\n            lambda orig, s1, s2: s1 if orig == tokens[swap_index1] else (s2 if orig == tokens[swap_index2] else orig),\n            tokens, swapped1, swapped2\n        ).named(\"result\")\n\n        # Handle single-element input case\n        length = rasp.SelectorWidth(rasp.Select(tokens, tokens, rasp.Comparison.TRUE)).named(\"length\")\n        return rasp.SequenceMap(\n            lambda x, l: None if l == 1 else x,\n            result, length\n        ).named(\"final_result\")\n\n    return swap_elements(rasp.tokens)",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            },
            {
                "generated rasp code": "def make_swap_elements() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that swaps the first two elements of a sequence.\n    If the sequence has only one element, it returns [None].\n    \"\"\"\n    # Get the length of the input sequence\n    all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    sequence_length = rasp.SelectorWidth(all_true_selector).named(\"sequence_length\")\n\n    # Create selectors for the elements to be swapped (indices 0 and 1)\n    swap_selector_0 = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == 0).named(\"swap_selector_0\")\n    swap_selector_1 = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == 1).named(\"swap_selector_1\")\n\n    # Get the elements to be swapped\n    element_0 = rasp.Aggregate(swap_selector_0, rasp.tokens).named(\"element_0\")\n    element_1 = rasp.Aggregate(swap_selector_1, rasp.tokens).named(\"element_1\")\n\n    # Create the swapped sequence\n    swapped_sequence = rasp.SequenceMap(\n        lambda x, y, z: y if z == 0 else (x if z == 1 else z),\n        element_1, element_0, rasp.tokens\n    ).named(\"swapped_sequence\")\n\n    # Handle the case of a single-element input\n    result = rasp.SequenceMap(\n        lambda x, y: None if y == 1 else x,\n        swapped_sequence, sequence_length\n    ).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            },
            {
                "generated rasp code": "def make_swap_elements(index1: int = 0, index2: int = 1) -> rasp.SOp:\n    \"\"\"\n    Creates a RASP SOp that swaps two elements at specified indices.\n    \n    Args:\n    index1 (int): First index to swap (default 0)\n    index2 (int): Second index to swap (default 1)\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that performs the swap\n    \"\"\"\n    def swap_elements_sop(tokens: rasp.SOp) -> rasp.SOp:\n        # Create a selector for the first swap index\n        selector1 = rasp.Select(rasp.indices, tokens, lambda x, y: x == index1).named(\"selector1\")\n        \n        # Create a selector for the second swap index\n        selector2 = rasp.Select(rasp.indices, tokens, lambda x, y: x == index2).named(\"selector2\")\n        \n        # Get the values at the swap indices\n        value1 = rasp.Aggregate(selector1, tokens).named(\"value1\")\n        value2 = rasp.Aggregate(selector2, tokens).named(\"value2\")\n        \n        # Create a new sequence where the values at the swap indices are swapped\n        swapped = rasp.SequenceMap(\n            lambda x, y, z, w: (y if x == index1 else (z if x == index2 else w)),\n            rasp.indices, value2, value1, tokens\n        ).named(\"swapped\")\n        \n        # Check if the input sequence has only one element\n        length = rasp.SelectorWidth(rasp.Select(tokens, tokens, rasp.Comparison.TRUE)).named(\"length\")\n        is_single_element = rasp.Select(length, tokens, lambda x, y: x == 1).named(\"is_single_element\")\n        \n        # If the sequence has only one element, return [None], otherwise return the swapped sequence\n        return rasp.Aggregate(is_single_element, rasp.Map(lambda x: None, tokens), default=swapped).named(\"result\")\n    \n    return swap_elements_sop\n\n# Example usage:\n# swap_elements = make_swap_elements()\n# swap_elements([1, 2, 3, 4])  # returns [2, 1, 3, 4]\n# swap_elements = make_swap_elements(1, 3)\n# swap_elements([1, 2, 3, 4])  # returns [1, 4, 3, 2]\n# swap_elements([5])  # returns [None]",
                "failure stage": 0,
                "error": "test_run_op timed out"
            }
        ],
        "make_one_if_equal_to_next": [
            {
                "generated rasp code": "def make_one_if_equal_to_next() -> rasp.SOp:\n    # Create a selector that shifts the sequence by one position\n    shift_selector = rasp.Select(\n        rasp.indices,\n        rasp.indices,\n        lambda x, y: (x + 1) % rasp.SelectorWidth(rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE)) == y\n    ).named(\"shift_selector\")\n\n    # Use Aggregate to create the shifted sequence\n    shifted_sequence = rasp.Aggregate(shift_selector, rasp.tokens, default=None).named(\"shifted_sequence\")\n\n    # Compare original sequence with shifted sequence and set to 1 if equal\n    result = rasp.SequenceMap(\n        lambda x, y: 1 if x == y else x,\n        rasp.tokens,\n        shifted_sequence\n    ).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_one_if_equal_to_next() -> rasp.SOp:\n    # Create a selector to shift the sequence by 1 position\n    shift_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: (y + 1) % len(x) == x).named(\"shift_selector\")\n    \n    # Create the shifted sequence\n    shifted_sequence = rasp.Aggregate(shift_selector, rasp.tokens, default=None).named(\"shifted_sequence\")\n    \n    # Compare the original sequence with the shifted sequence\n    comparison_selector = rasp.Select(rasp.tokens, shifted_sequence, rasp.Comparison.EQ).named(\"comparison_selector\")\n    \n    # Convert True/False to 1/original value\n    result = rasp.SequenceMap(lambda x, y: 1 if y else x, rasp.tokens, comparison_selector).named(\"result\")\n    \n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_one_if_equal_to_next() -> rasp.SOp:\n    # Create a selector to shift the sequence\n    shift_selector = rasp.Select(\n        rasp.indices,\n        rasp.indices,\n        lambda x, y: (x + 1) % y == 0\n    ).named(\"shift_selector\")\n\n    # Create the shifted sequence\n    shifted_sequence = rasp.Aggregate(shift_selector, rasp.tokens).named(\"shifted_sequence\")\n\n    # Create a selector for equality comparison\n    equality_selector = rasp.Select(\n        rasp.tokens,\n        shifted_sequence,\n        rasp.Comparison.EQ\n    ).named(\"equality_selector\")\n\n    # Create the final sequence\n    result = rasp.SequenceMap(\n        lambda x, y: 1 if y else x,\n        rasp.tokens,\n        equality_selector\n    ).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_one_if_equal_to_next() -> rasp.SOp:\n    # Define shift_by function\n    def shift_by(offset: int, sop: rasp.SOp, fill: rasp.Value) -> rasp.SOp:\n        \"\"\"Returns the sop, shifted by `offset`, filled with `fill` value.\"\"\"\n        select_off_by_offset = rasp.Select(rasp.indices, rasp.indices,\n                                           lambda k, q: q == k + offset)\n        out = rasp.Aggregate(select_off_by_offset, sop, default=fill)\n        return out.named(f\"shift_by({offset})\")\n\n    # Create a shifted version of the input sequence\n    shifted_sequence = shift_by(-1, rasp.tokens, None).named(\"shifted_sequence\")\n\n    # Compare the original sequence with the shifted sequence\n    comparison = rasp.SequenceMap(lambda x, y: x == y, rasp.tokens, shifted_sequence).named(\"comparison\")\n\n    # Convert comparison results to desired output format\n    output = rasp.Map(lambda x: 1 if x else x, comparison).named(\"output\")\n\n    return output",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [False, False, False, False, False, None]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def shift_by(offset: int, sop: rasp.SOp, fill: rasp.Value) -> rasp.SOp:\n    \"\"\"Returns the sop, shifted by `offset`, filled with `fill` value.\"\"\"\n    select_off_by_offset = rasp.Select(rasp.indices, rasp.indices,\n                                       lambda k, q: q == k + offset)\n    out = rasp.Aggregate(select_off_by_offset, sop, default=fill)\n    return out.named(f\"shift_by({offset})\")\n\ndef make_one_if_equal_to_next() -> rasp.SOp:\n    # Shift the sequence by -1 (which is equivalent to 1 to the left)\n    shifted_sequence = shift_by(-1, rasp.tokens, fill=None).named(\"shifted_sequence\")\n    \n    # Create a selector that identifies where elements are equal to the next (shifted) element\n    equal_to_next_selector = rasp.Select(rasp.tokens, shifted_sequence, rasp.Comparison.EQ).named(\"equal_to_next_selector\")\n    \n    # Create the final sequence: 1 where elements are equal, original value otherwise\n    result = rasp.SequenceMap(\n        lambda x, y: 1 if y else x,\n        rasp.tokens,\n        equal_to_next_selector\n    ).named(\"result\")\n    \n    return result",
                "failure stage": 0,
                "error": ""
            }
        ],
        "make_swap_consecutive": [
            {
                "generated rasp code": "def make_swap_consecutive() -> rasp.SOp:\n    # Create a selector for even-indexed elements\n    even_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 0).named(\"even_selector\")\n    \n    # Create a selector for odd-indexed elements\n    odd_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 1).named(\"odd_selector\")\n    \n    # Shift even-indexed elements one position to the right\n    shift_even = rasp.Aggregate(\n        rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y + 1),\n        rasp.tokens\n    ).named(\"shift_even\")\n    \n    # Shift odd-indexed elements two positions to the right\n    shift_odd = rasp.Aggregate(\n        rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y + 2),\n        rasp.tokens\n    ).named(\"shift_odd\")\n    \n    # Combine the shifted sequences\n    swapped = rasp.SequenceMap(\n        lambda x, y: x if x is not None else y,\n        rasp.Aggregate(even_selector, shift_even),\n        rasp.Aggregate(odd_selector, shift_odd)\n    ).named(\"swapped\")\n    \n    return swapped",
                "failure stage": 1,
                "error": "Unsupported type for aggregation: [7.0, 7.0, None]"
            },
            {
                "generated rasp code": "def make_swap_consecutive() -> rasp.SOp:\n    # Create a selector for even-indexed elements\n    even_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 0).named(\"even_selector\")\n    \n    # Create a selector for odd-indexed elements\n    odd_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 1).named(\"odd_selector\")\n    \n    # Shift even-indexed elements one position to the right\n    shift_even = rasp.Aggregate(\n        rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y + 1),\n        rasp.Aggregate(even_selector, rasp.tokens)\n    ).named(\"shift_even\")\n    \n    # Shift odd-indexed elements two positions to the right\n    shift_odd = rasp.Aggregate(\n        rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y + 2),\n        rasp.Aggregate(odd_selector, rasp.tokens)\n    ).named(\"shift_odd\")\n    \n    # Combine the shifted sequences\n    swapped = rasp.SequenceMap(\n        lambda x, y: x if x is not None else y,\n        shift_even,\n        shift_odd\n    ).named(\"swapped\")\n    \n    return swapped",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, None, None]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_swap_consecutive() -> rasp.SOp:\n    # Create a selector for even-indexed elements\n    even_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 0).named(\"even_selector\")\n    \n    # Create a selector for odd-indexed elements\n    odd_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 1).named(\"odd_selector\")\n    \n    # Shift even-indexed elements one position to the right\n    shift_even = rasp.Aggregate(\n        rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y + 1),\n        rasp.Aggregate(even_selector, rasp.tokens)\n    ).named(\"shift_even\")\n    \n    # Shift odd-indexed elements one position to the right\n    shift_odd = rasp.Aggregate(\n        rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y - 1),\n        rasp.Aggregate(odd_selector, rasp.tokens)\n    ).named(\"shift_odd\")\n    \n    # Combine the shifted sequences\n    swapped = rasp.SequenceMap(\n        lambda x, y: x if x is not None else y,\n        shift_even,\n        shift_odd\n    ).named(\"swapped\")\n    \n    return swapped",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, None]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_swap_consecutive() -> rasp.SOp:\n    # Create a selector for even-indexed elements\n    even_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 0).named(\"even_selector\")\n    \n    # Create a selector for odd-indexed elements\n    odd_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 != 0).named(\"odd_selector\")\n    \n    # Shift even-indexed elements one position to the right\n    shifted_even = rasp.Aggregate(\n        rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y + 1),\n        rasp.Aggregate(even_selector, rasp.tokens)\n    ).named(\"shifted_even\")\n    \n    # Shift odd-indexed elements two positions to the right\n    shifted_odd = rasp.Aggregate(\n        rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y + 2),\n        rasp.Aggregate(odd_selector, rasp.tokens)\n    ).named(\"shifted_odd\")\n    \n    # Combine the shifted sequences\n    swapped = rasp.SequenceMap(\n        lambda x, y: x if x is not None else y,\n        shifted_even,\n        shifted_odd\n    ).named(\"swapped\")\n    \n    return swapped",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, None, None]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_swap_consecutive() -> rasp.SOp:\n    # Create a selector for even-indexed elements\n    even_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 0).named(\"even_selector\")\n    \n    # Create a selector for odd-indexed elements\n    odd_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 1).named(\"odd_selector\")\n    \n    # Shift even-indexed elements one position to the right\n    shifted_even = rasp.Aggregate(rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y + 1), rasp.tokens).named(\"shifted_even\")\n    \n    # Shift odd-indexed elements two positions to the right\n    shifted_odd = rasp.Aggregate(rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y + 2), rasp.tokens).named(\"shifted_odd\")\n    \n    # Combine the shifted sequences\n    swapped = rasp.SequenceMap(\n        lambda x, y: x if x is not None else y,\n        rasp.Aggregate(even_selector, shifted_even),\n        rasp.Aggregate(odd_selector, shifted_odd)\n    ).named(\"swapped\")\n    \n    return swapped",
                "failure stage": 1,
                "error": "Unsupported type for aggregation: [7.0, 7.0, None]"
            }
        ],
        "make_check_palindrome": [
            {
                "generated rasp code": "def make_check_palindrome() -> rasp.SOp:\n    # Create a selector to reverse the sequence\n    reverse_selector = rasp.Select(rasp.indices, rasp.indices, \n                                   lambda x, y: x + y == len(rasp.tokens) - 1).named(\"reverse_selector\")\n    \n    # Create the reversed sequence\n    reversed_sequence = rasp.Aggregate(reverse_selector, rasp.tokens).named(\"reversed_sequence\")\n    \n    # Compare the original sequence with the reversed sequence\n    comparison = rasp.SequenceMap(lambda x, y: x == y, rasp.tokens, reversed_sequence).named(\"comparison\")\n    \n    # Check if any element doesn't match (i.e., sequence is not a palindrome)\n    any_mismatch = rasp.Aggregate(\n        rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE),\n        rasp.Map(lambda x: not x, comparison)\n    ).named(\"any_mismatch\")\n    \n    # Create the final output sequence\n    return rasp.Map(lambda x: 0 if x else 1, any_mismatch).named(\"is_palindrome\")",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_check_palindrome() -> rasp.SOp:\n    # Create a selector to reverse the sequence\n    reverse_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x + y + 1 == len(x)).named(\"reverse_selector\")\n    \n    # Create the reversed sequence\n    reversed_sequence = rasp.Aggregate(reverse_selector, rasp.tokens).named(\"reversed_sequence\")\n    \n    # Compare the original sequence with the reversed sequence\n    mismatch = rasp.SequenceMap(lambda x, y: 0 if x == y else 1, rasp.tokens, reversed_sequence).named(\"mismatch\")\n    \n    # Check if any elements don't match\n    any_mismatch = rasp.Aggregate(rasp.Select(mismatch, mismatch, lambda x, y: x == 1), mismatch).named(\"any_mismatch\")\n    \n    # Create the final output: 1 if palindrome, 0 if not\n    return rasp.Map(lambda x: 1 if x is None else 0, any_mismatch).named(\"is_palindrome\")",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_check_palindrome() -> rasp.SOp:\n    # Create a selector to reverse the sequence\n    reverse_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: -x, rasp.indices),\n        rasp.Comparison.EQ\n    ).named(\"reverse_selector\")\n\n    # Create the reversed sequence\n    reversed_sequence = rasp.Aggregate(reverse_selector, rasp.tokens).named(\"reversed_sequence\")\n\n    # Compare the original sequence with the reversed sequence\n    comparison = rasp.SequenceMap(\n        lambda x, y: 0 if x != y else 1,\n        rasp.tokens,\n        reversed_sequence\n    ).named(\"comparison\")\n\n    # Check if any element is not equal (0)\n    any_not_equal = rasp.Aggregate(\n        rasp.Select(comparison, comparison, lambda x, y: x == 0),\n        comparison,\n        default=1\n    ).named(\"any_not_equal\")\n\n    # Create the final output: 1 if palindrome, 0 if not\n    return rasp.Map(lambda x: 1 - x, any_not_equal).named(\"check_palindrome\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0, 0, 0, 0, 0, 0]. (0.128 error rate)"
            },
            {
                "generated rasp code": "def make_check_palindrome() -> rasp.SOp:\n    # Create a selector to reverse the sequence\n    reverse_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: -x, rasp.indices),\n        rasp.Comparison.EQ\n    ).named(\"reverse_selector\")\n\n    # Create the reversed sequence\n    reversed_sequence = rasp.Aggregate(reverse_selector, rasp.tokens).named(\"reversed_sequence\")\n\n    # Compare the original sequence with the reversed sequence\n    comparison = rasp.SequenceMap(\n        lambda x, y: 1 if x == y else 0,\n        rasp.tokens,\n        reversed_sequence\n    ).named(\"comparison\")\n\n    # Count the number of matching elements\n    match_count = rasp.SelectorWidth(\n        rasp.Select(comparison, comparison, lambda x, y: x == 1)\n    ).named(\"match_count\")\n\n    # Get the length of the sequence\n    length = rasp.SelectorWidth(\n        rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE)\n    ).named(\"length\")\n\n    # Check if all elements match (i.e., if match_count equals length)\n    is_palindrome = rasp.SequenceMap(\n        lambda x, y: 1 if x == y else 0,\n        match_count,\n        length\n    ).named(\"is_palindrome\")\n\n    # Broadcast the result to all elements of the sequence\n    result = rasp.Aggregate(\n        rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE),\n        is_palindrome\n    ).named(\"result\")\n\n    return result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]. (0.025 error rate)"
            },
            {
                "generated rasp code": "def make_check_palindrome() -> rasp.SOp:\n    # Create a sequence of indices\n    indices = rasp.indices.named(\"indices\")\n    \n    # Get the length of the sequence\n    length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"length\")\n    \n    # Create reversed indices\n    reversed_indices = rasp.SequenceMap(lambda l, i: l - i - 1, length, indices).named(\"reversed_indices\")\n    \n    # Create a selector for reversing the sequence\n    reverse_selector = rasp.Select(indices, reversed_indices, rasp.Comparison.EQ).named(\"reverse_selector\")\n    \n    # Create the reversed sequence\n    reversed_sequence = rasp.Aggregate(reverse_selector, rasp.tokens).named(\"reversed_sequence\")\n    \n    # Compare original and reversed sequences\n    is_equal = rasp.SequenceMap(lambda x, y: x == y, rasp.tokens, reversed_sequence).named(\"is_equal\")\n    \n    # Count the number of matching elements\n    match_count = rasp.SelectorWidth(rasp.Select(is_equal, is_equal, lambda x, y: x)).named(\"match_count\")\n    \n    # Check if all elements match\n    is_palindrome = rasp.SequenceMap(lambda count, l: count == l, match_count, length).named(\"is_palindrome\")\n    \n    # Convert boolean to 1 (True) or 0 (False)\n    return rasp.Map(lambda x: 1 if x else 0, is_palindrome).named(\"palindrome_check\")",
                "failure stage": 0,
                "error": "test_run_op timed out"
            }
        ],
        "make_next_prime": [
            {
                "generated rasp code": "def make_next_prime(max_prime=100) -> rasp.SOp:\n    # Create a sequence of numbers from 2 to max_prime\n    numbers = rasp.Map(lambda x: x + 2, rasp.indices).named(\"numbers\")\n    \n    # Create a selector for primality check\n    # A number is prime if it's not divisible by any smaller number greater than 1\n    divisibility_check = rasp.Select(numbers, numbers, lambda x, y: (x > y) and (x % y == 0)).named(\"divisibility_check\")\n    \n    # Count the number of divisors for each number\n    divisor_count = rasp.SelectorWidth(divisibility_check).named(\"divisor_count\")\n    \n    # A number is prime if it has no divisors other than 1 and itself\n    is_prime = rasp.Map(lambda x: x == 0, divisor_count).named(\"is_prime\")\n    \n    # Create a selector for numbers greater than the input\n    greater_than_input = rasp.Select(numbers, rasp.tokens, rasp.Comparison.GT).named(\"greater_than_input\")\n    \n    # Combine the greater_than_input selector with the is_prime check\n    next_prime_selector = rasp.SequenceMap(lambda x, y: x and y, greater_than_input, is_prime).named(\"next_prime_selector\")\n    \n    # Find the next prime for each input number\n    next_prime = rasp.Aggregate(next_prime_selector, numbers).named(\"next_prime\")\n    \n    # If the input is already prime, keep it as is; otherwise, use the next prime\n    result = rasp.SequenceMap(\n        lambda x, y, z: x if y else z,\n        rasp.tokens,\n        rasp.SequenceMap(lambda x, y: x and (y == x), is_prime, rasp.tokens),\n        next_prime\n    ).named(\"result\")\n    \n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_next_prime(max_prime=100) -> rasp.SOp:\n    def make_length() -> rasp.SOp:\n        all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n        return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n    length = make_length()\n\n    # Create a sequence of numbers from 2 to max_prime\n    numbers = rasp.SequenceMap(lambda x, y: x + 2, rasp.indices, rasp.Map(lambda x: 0, rasp.tokens)).named(\"numbers\")\n\n    # Create a selector for prime numbers\n    prime_selector = rasp.Select(numbers, numbers, lambda x, y: (y % x != 0) | (x == y)).named(\"prime_selector\")\n    prime_count = rasp.SelectorWidth(prime_selector).named(\"prime_count\")\n    is_prime = rasp.Select(prime_count, length - 2, rasp.Comparison.EQ).named(\"is_prime\")\n\n    # Find the next prime for each number\n    next_prime = rasp.Aggregate(is_prime, numbers).named(\"next_prime\")\n\n    # Create a selector for numbers greater than the input\n    greater_selector = rasp.Select(next_prime, rasp.tokens, rasp.Comparison.GT).named(\"greater_selector\")\n\n    # Find the smallest prime greater than the input\n    result = rasp.Aggregate(greater_selector, next_prime).named(\"result\")\n\n    # If the input is already prime, keep it unchanged\n    final_result = rasp.SequenceMap(\n        lambda x, y: x if y else z,\n        rasp.tokens,\n        rasp.Aggregate(is_prime, rasp.tokens),\n        result\n    ).named(\"final_result\")\n\n    return final_result",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            }
        ],
        "make_mask_sequence": [
            {
                "generated rasp code": "def make_mask_sequence(index: int = 1) -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that masks a sequence, replacing every element with 0\n    except the one at the specified index (default index is 1).\n    \n    Args:\n    index (int): The index of the element to keep (default is 1).\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that performs the masking.\n    \"\"\"\n    # Create a sequence of the specified index for comparison\n    index_sequence = rasp.SequenceMap(lambda x, y: index, rasp.tokens, rasp.indices).named(\"index_sequence\")\n    \n    # Create a selector that identifies the element at the specified index\n    index_selector = rasp.Select(rasp.indices, index_sequence, rasp.Comparison.EQ).named(\"index_selector\")\n    \n    # Use Aggregate to keep the element at the specified index and replace others with 0\n    masked_sequence = rasp.Aggregate(index_selector, rasp.tokens, default=None).named(\"masked_sequence\")\n    \n    # Replace None values (which represent non-selected elements) with 0\n    return rasp.Map(lambda x: x if x is not None else 0, masked_sequence).named(\"final_masked_sequence\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [8.0, 8.0, 8.0, 8.0, 8.0, 8.0]. (0.91 error rate)"
            },
            {
                "generated rasp code": "def make_mask_sequence(index: int = 1) -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that masks a sequence, replacing every element with 0\n    except the one at the specified index (default index is 1).\n    \n    Args:\n    index (int): The index of the element to keep (default is 1).\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that performs the masking.\n    \"\"\"\n    # Create a sequence where each element is the specified index\n    index_sequence = rasp.Map(lambda x: index, rasp.indices).named(\"index_sequence\")\n    \n    # Create a selector that is True only for the specified index\n    index_selector = rasp.Select(rasp.indices, index_sequence, rasp.Comparison.EQ).named(\"index_selector\")\n    \n    # Use Aggregate to keep the element at the specified index and replace others with 0\n    masked_sequence = rasp.Aggregate(index_selector, rasp.tokens, default=None).named(\"masked_sequence\")\n    \n    # Replace None values (which occur where the selector was False) with 0\n    return rasp.Map(lambda x: x if x is not None else 0, masked_sequence).named(\"final_masked_sequence\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [8.0, 8.0, 8.0, 8.0, 8.0, 8.0]. (0.91 error rate)"
            },
            {
                "generated rasp code": "def make_mask_sequence(index: int = 1) -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that masks a sequence, replacing every element with 0\n    except the one at the specified index (default index is 1).\n    \n    Args:\n    index (int): The index of the element to keep (default is 1).\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that applies the masking.\n    \"\"\"\n    # Create a sequence of indices\n    indices = rasp.SequenceMap(lambda x, y: y, rasp.tokens, rasp.indices).named(\"indices\")\n    \n    # Create a selector that selects only the element at the specified index\n    mask_selector = rasp.Select(indices, indices, lambda x, y: x == index).named(\"mask_selector\")\n    \n    # Use Aggregate to keep the value at the specified index and replace others with 0\n    masked_sequence = rasp.Aggregate(mask_selector, rasp.tokens, default=None).named(\"masked_sequence\")\n    \n    # Replace None values with 0\n    return rasp.Map(lambda x: x if x is not None else 0, masked_sequence).named(\"final_masked_sequence\")\n\n# Example usage:\n# mask_sequence = make_mask_sequence()\n# result = mask_sequence([1, 2, 3, 4, 5])  # returns [0, 2, 0, 0, 0]\n# result = make_mask_sequence(index=3)([1, 2, 3, 4, 5])  # returns [0, 0, 0, 4, 0]",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [8.0, 8.0, 8.0, 8.0, 8.0, 8.0]. (0.91 error rate)"
            },
            {
                "generated rasp code": "def make_mask_sequence(index: int = 1) -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that masks a sequence, replacing every element with 0\n    except the one at the specified index (default index is 1).\n    \n    Args:\n    index (int): The index of the element to keep (default is 1).\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that performs the masking.\n    \"\"\"\n    # Create a selector that identifies the element at the specified index\n    index_selector = rasp.Select(\n        rasp.indices,  # Use built-in rasp.indices for the sequence indices\n        rasp.Map(lambda x: index, rasp.indices),  # Create a sequence filled with the specified index\n        rasp.Comparison.EQ  # Compare for equality\n    ).named(\"index_selector\")\n    \n    # Use Aggregate to keep the selected element and replace others with 0\n    masked_sequence = rasp.Aggregate(\n        index_selector,  # Use the selector we created\n        rasp.tokens,  # The original sequence\n        default=0  # Replace non-selected elements with 0\n    ).named(\"masked_sequence\")\n    \n    return masked_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [8.0, 8.0, 8.0, 8.0, 8.0, 8.0]. (0.822 error rate)"
            },
            {
                "generated rasp code": "def make_mask_sequence(index: int = 1) -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that masks a sequence, replacing every element with 0\n    except the one at the specified index (default index is 1).\n    \n    Args:\n    index (int): The index of the element to keep (default is 1).\n    \n    Returns:\n    rasp.SOp: A RASP program that masks the input sequence.\n    \"\"\"\n    # Create a constant sequence of the specified index\n    constant_index = rasp.Map(lambda x: index, rasp.indices).named(\"constant_index\")\n    \n    # Create a selector that identifies the element at the specified index\n    index_selector = rasp.Select(rasp.indices, constant_index, rasp.Comparison.EQ).named(\"index_selector\")\n    \n    # Use Aggregate to keep the element at the specified index and replace others with 0\n    masked_sequence = rasp.Aggregate(index_selector, rasp.tokens, default=None).named(\"masked_sequence\")\n    \n    # Replace None values with 0 using Map\n    return rasp.Map(lambda x: x if x is not None else 0, masked_sequence).named(\"final_masked_sequence\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [8.0, 8.0, 8.0, 8.0, 8.0, 8.0]. (0.91 error rate)"
            }
        ],
        "make_wrap": [],
        "make_alternate_elements": [
            {
                "generated rasp code": "def make_alternate_elements() -> rasp.SOp:\n    # Create a selector for even-indexed positions (0-based indexing)\n    even_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 0).named(\"even_selector\")\n    \n    # Create a sequence with original elements at even positions and None at odd positions\n    even_sequence = rasp.Aggregate(even_selector, rasp.tokens).named(\"even_sequence\")\n    \n    # Create a sequence with indices (1-based) at odd positions and None at even positions\n    odd_sequence = rasp.Aggregate(~even_selector, rasp.Map(lambda x: x + 1, rasp.indices)).named(\"odd_sequence\")\n    \n    # Combine the two sequences, choosing the non-None value at each position\n    return rasp.SequenceMap(lambda x, y: x if x is not None else y, even_sequence, odd_sequence).named(\"alternate_elements\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335]. (0.988 error rate)"
            },
            {
                "generated rasp code": "def make_alternate_elements() -> rasp.SOp:\n    # Create a selector for odd-indexed positions (1-based, which is even in 0-based)\n    odd_index_selector = rasp.Select(\n        rasp.indices,\n        rasp.indices,\n        lambda x, y: x % 2 == 1\n    ).named(\"odd_index_selector\")\n\n    # Create a sequence of indices\n    index_sequence = rasp.indices.named(\"index_sequence\")\n\n    # Combine the original sequence with the index sequence based on the selector\n    alternated_sequence = rasp.SequenceMap(\n        lambda x, y: y if x else x,  # If selector is True (odd index), use index; else use original\n        odd_index_selector,\n        rasp.SequenceMap(lambda x, y: x if y else y, rasp.tokens, index_sequence)\n    ).named(\"alternated_sequence\")\n\n    return alternated_sequence",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_alternate_elements() -> rasp.SOp:\n    # Create a selector for odd-indexed positions (1-based)\n    odd_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: (x + 1) % 2 == 1).named(\"odd_selector\")\n    \n    # Create a sequence of indices\n    indices_sequence = rasp.indices.named(\"indices_sequence\")\n    \n    # Use SequenceMap to choose between original elements and indices\n    alternated_sequence = rasp.SequenceMap(\n        lambda orig, idx, sel: idx if sel else orig,\n        rasp.tokens,\n        indices_sequence,\n        odd_selector\n    ).named(\"alternated_sequence\")\n    \n    return alternated_sequence",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            },
            {
                "generated rasp code": "def make_alternate_elements() -> rasp.SOp:\n    # Create a selector for odd-indexed positions (1-based indexing)\n    odd_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 1).named(\"odd_selector\")\n\n    # Create a sequence of indices (0-based)\n    indices_sequence = rasp.indices.named(\"indices_sequence\")\n\n    # Create a sequence where odd-indexed positions contain their indices\n    odd_indices = rasp.Aggregate(odd_selector, indices_sequence).named(\"odd_indices\")\n\n    # Create a sequence where even-indexed positions contain the original elements\n    even_elements = rasp.Aggregate(~odd_selector, rasp.tokens).named(\"even_elements\")\n\n    # Combine the two sequences, choosing the non-None value at each position\n    return rasp.SequenceMap(lambda x, y: x if x is not None else y, odd_indices, even_elements).named(\"alternate_elements\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3.0, 3.0, 3.0, 3.0, 3.0, 3.0]. (0.988 error rate)"
            },
            {
                "generated rasp code": "def make_alternate_elements() -> rasp.SOp:\n    # Create a sequence of indices\n    indices = rasp.indices.named(\"indices\")\n    \n    # Create a selector for odd-indexed positions\n    odd_selector = rasp.Select(indices, indices, lambda x, y: x % 2 == 1).named(\"odd_selector\")\n    \n    # Create a sequence with original elements at even indices and zeros at odd indices\n    even_elements = rasp.Aggregate(~odd_selector, rasp.tokens).named(\"even_elements\")\n    \n    # Create a sequence with indices at odd positions and zeros at even positions\n    odd_indices = rasp.Aggregate(odd_selector, indices).named(\"odd_indices\")\n    \n    # Combine the two sequences by addition\n    alternated = rasp.SequenceMap(lambda x, y: x + y, even_elements, odd_indices).named(\"alternated\")\n    \n    return alternated\n\n# Example usage:\n# alternate = make_alternate_elements()\n# result = alternate([1, 2, 3, 4, 5])  # Returns [1, 1, 3, 3, 5]",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [6.333333333333334, 6.333333333333334, 6.333333333333334, 6.333333333333334, 6.333333333333334, 6.333333333333334]. (1.0 error rate)"
            }
        ],
        "make_check_last_two_equal": [
            {
                "generated rasp code": "def make_check_last_two_equal() -> rasp.SOp:\n    # Create length SOp\n    all_true_selector = rasp.Select(\n        rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    length = rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n    # Create selector for the last element\n    last_elem_selector = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\"last_elem_selector\")\n    \n    # Create selector for the second-to-last element\n    second_last_elem_selector = rasp.Select(rasp.indices, length - 2, rasp.Comparison.EQ).named(\"second_last_elem_selector\")\n\n    # Extract last and second-to-last elements\n    last_elem = rasp.Aggregate(last_elem_selector, rasp.tokens).named(\"last_elem\")\n    second_last_elem = rasp.Aggregate(second_last_elem_selector, rasp.tokens).named(\"second_last_elem\")\n\n    # Compare last two elements\n    are_equal = rasp.SequenceMap(lambda x, y: 1 if x == y else 0, last_elem, second_last_elem).named(\"are_equal\")\n\n    # Create a sequence of 0s for the case where length is 1\n    zeros = rasp.Map(lambda x: 0, rasp.tokens).named(\"zeros\")\n\n    # Select between 'are_equal' and 'zeros' based on length\n    result = rasp.SequenceMap(\n        lambda l, eq: eq if l > 1 else 0,\n        length,\n        are_equal\n    ).named(\"result\")\n\n    return result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0, 0, 0, 0, 0, 0]. (0.092 error rate)"
            },
            {
                "generated rasp code": "def make_check_last_two_equal() -> rasp.SOp:\n    # Get the length of the sequence\n    all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    length = rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n    # Create a selector for the last element\n    last_elem_selector = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\"last_elem_selector\")\n\n    # Create a selector for the second-to-last element\n    second_last_elem_selector = rasp.Select(rasp.indices, length - 2, rasp.Comparison.EQ).named(\"second_last_elem_selector\")\n\n    # Get the values of the last and second-to-last elements\n    last_elem = rasp.Aggregate(last_elem_selector, rasp.tokens).named(\"last_elem\")\n    second_last_elem = rasp.Aggregate(second_last_elem_selector, rasp.tokens).named(\"second_last_elem\")\n\n    # Compare the last two elements\n    are_equal = rasp.SequenceMap(lambda x, y: 1 if x == y else 0, last_elem, second_last_elem).named(\"are_equal\")\n\n    # Handle single-element case and create final output\n    def check_and_output(length_val, equal_val):\n        if length_val == 1:\n            return 0\n        elif length_val >= 2:\n            return equal_val\n        else:\n            return None  # This should never happen, but we need to handle all cases\n\n    final_output = rasp.SequenceMap(check_and_output, length, are_equal).named(\"final_output\")\n\n    return final_output",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0, 0, 0, 0, 0, 0]. (0.092 error rate)"
            },
            {
                "generated rasp code": "def make_check_last_two_equal() -> rasp.SOp:\n    # Create a function to get the length of the sequence\n    def make_length() -> rasp.SOp:\n        all_true_selector = rasp.Select(\n            rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n        return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n    length = make_length()\n\n    # Create a selector for the last element\n    last_elem_selector = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\"last_elem_selector\")\n\n    # Create a selector for the second-to-last element\n    second_last_elem_selector = rasp.Select(rasp.indices, length - 2, rasp.Comparison.EQ).named(\"second_last_elem_selector\")\n\n    # Extract the last element\n    last_elem = rasp.Aggregate(last_elem_selector, rasp.tokens, default=None).named(\"last_elem\")\n\n    # Extract the second-to-last element\n    second_last_elem = rasp.Aggregate(second_last_elem_selector, rasp.tokens, default=None).named(\"second_last_elem\")\n\n    # Create a selector for sequences with only one element\n    single_elem_selector = rasp.Select(length, rasp.Map(lambda x: 1, rasp.indices), rasp.Comparison.EQ).named(\"single_elem_selector\")\n\n    # Compare the last two elements, handling the single-element case\n    def compare_elements(last, second_last, is_single):\n        if is_single:\n            return 0\n        elif last is None or second_last is None:\n            return 0\n        else:\n            return 1 if last == second_last else 0\n\n    comparison_result = rasp.SequenceMap(compare_elements, last_elem, second_last_elem, single_elem_selector).named(\"comparison_result\")\n\n    # Broadcast the result across the entire sequence\n    result = rasp.Map(lambda x: x, comparison_result).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            },
            {
                "generated rasp code": "def make_check_last_two_equal() -> rasp.SOp:\n    # Create a function to get the length of the sequence\n    def make_length() -> rasp.SOp:\n        all_true_selector = rasp.Select(\n            rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n        return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n    # Get the length of the sequence\n    length = make_length()\n\n    # Create selectors for the last two elements\n    last_element_selector = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\"last_element_selector\")\n    second_last_element_selector = rasp.Select(rasp.indices, length - 2, rasp.Comparison.EQ).named(\"second_last_element_selector\")\n\n    # Get the values of the last two elements\n    last_element = rasp.Aggregate(last_element_selector, rasp.tokens).named(\"last_element\")\n    second_last_element = rasp.Aggregate(second_last_element_selector, rasp.tokens).named(\"second_last_element\")\n\n    # Compare the last two elements for equality\n    are_equal = rasp.SequenceMap(lambda x, y: 1 if x == y else 0, last_element, second_last_element).named(\"are_equal\")\n\n    # Handle the case when the sequence has only one element\n    is_single_element = rasp.SequenceMap(lambda x, y: 1 if x == 1 else 0, length, rasp.tokens).named(\"is_single_element\")\n\n    # Combine the results\n    result = rasp.SequenceMap(\n        lambda eq, single: 0 if single == 1 else eq,\n        are_equal,\n        is_single_element\n    ).named(\"result\")\n\n    return result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0, 0, 0, 0, 0, 0]. (0.092 error rate)"
            },
            {
                "generated rasp code": "def make_check_last_two_equal() -> rasp.SOp:\n    # Get the length of the sequence\n    all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    length = rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n    # Create selectors for the last two elements\n    last_element_selector = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\"last_element_selector\")\n    second_last_element_selector = rasp.Select(rasp.indices, length - 2, rasp.Comparison.EQ).named(\"second_last_element_selector\")\n\n    # Extract the last two elements\n    last_element = rasp.Aggregate(last_element_selector, rasp.tokens, default=None).named(\"last_element\")\n    second_last_element = rasp.Aggregate(second_last_element_selector, rasp.tokens, default=None).named(\"second_last_element\")\n\n    # Compare the last two elements and handle the single-element case\n    def compare_elements(last, second_last, seq_length):\n        if seq_length == 1:\n            return 0\n        elif last == second_last:\n            return 1\n        else:\n            return 0\n\n    result = rasp.SequenceMap(compare_elements, last_element, second_last_element, length).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            }
        ],
        "make_insert_zeros": [
            {
                "generated rasp code": "def make_insert_zeros() -> rasp.SOp:\n    # Create a selector for even-indexed positions\n    even_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 0).named(\"even_selector\")\n    \n    # Create a selector for odd-indexed positions\n    odd_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 1).named(\"odd_selector\")\n    \n    # Use Aggregate to place original elements at even positions\n    even_elements = rasp.Aggregate(even_selector, rasp.tokens).named(\"even_elements\")\n    \n    # Create a sequence of zeros\n    zeros = rasp.Map(lambda x: 0, rasp.tokens).named(\"zeros\")\n    \n    # Use Aggregate to place zeros at odd positions\n    odd_zeros = rasp.Aggregate(odd_selector, zeros).named(\"odd_zeros\")\n    \n    # Combine even_elements and odd_zeros using SequenceMap\n    result = rasp.SequenceMap(lambda x, y: x if x is not None else y, even_elements, odd_zeros).named(\"result\")\n    \n    return result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335]. (0.989 error rate)"
            },
            {
                "generated rasp code": "def make_insert_zeros() -> rasp.SOp:\n    # Create a selector for even-indexed positions\n    even_selector = rasp.Select(\n        rasp.indices,\n        rasp.indices,\n        lambda x, y: x % 2 == 0\n    ).named(\"even_selector\")\n\n    # Use SequenceMap to insert zeros between original elements\n    insert_zeros = rasp.SequenceMap(\n        lambda x, y: x if y else 0,\n        rasp.tokens,\n        even_selector\n    ).named(\"insert_zeros\")\n\n    return insert_zeros",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_insert_zeros() -> rasp.SOp:\n    # Create a selector for even-indexed positions in the output\n    even_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: y % 2 == 0).named(\"even_selector\")\n    \n    # Create a selector for odd-indexed positions in the output\n    odd_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: y % 2 == 1).named(\"odd_selector\")\n    \n    # Combine the selectors\n    combined_selector = rasp.SelectorOr(even_selector, odd_selector).named(\"combined_selector\")\n    \n    # Create a sequence of alternating input elements and zeros\n    def alternating_sequence(x, i):\n        if i % 2 == 0:\n            return x\n        else:\n            return 0\n    \n    alternating = rasp.SequenceMap(alternating_sequence, rasp.tokens, rasp.indices).named(\"alternating\")\n    \n    # Use Aggregate to place the alternating sequence elements in their correct positions\n    result = rasp.Aggregate(combined_selector, alternating).named(\"result\")\n    \n    return result\n\n# Example usage:\n# insert_zeros = make_insert_zeros()\n# output = insert_zeros([1, 2, 3, 4, 5])  # Returns [1, 0, 2, 0, 3]",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [1.6666666666666667, 1.6666666666666667, 1.6666666666666667, 1.6666666666666667, 1.6666666666666667, 1.6666666666666667]. (0.882 error rate)"
            },
            {
                "generated rasp code": "def make_insert_zeros() -> rasp.SOp:\n    # Create a selector for even-indexed positions\n    even_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 0).named(\"even_selector\")\n\n    # Place original elements in even-indexed positions\n    even_elements = rasp.Aggregate(even_selector, rasp.tokens).named(\"even_elements\")\n\n    # Fill remaining (odd-indexed) positions with zeros\n    result = rasp.Map(lambda x: 0 if x is None else x, even_elements).named(\"insert_zeros\")\n\n    return result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335]. (0.882 error rate)"
            },
            {
                "generated rasp code": "def make_insert_zeros() -> rasp.SOp:\n    # Create a selector for even-indexed positions\n    even_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 0).named(\"even_selector\")\n    \n    # Create a selector for odd-indexed positions\n    odd_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 != 0).named(\"odd_selector\")\n    \n    # Combine the selectors: select original elements at even positions and zeros at odd positions\n    combined_selector = rasp.SelectorOr(even_selector, odd_selector).named(\"combined_selector\")\n    \n    # Use Aggregate to insert zeros and keep original elements\n    def select_or_zero(x, y):\n        return x if y % 2 == 0 else 0\n    \n    result = rasp.Aggregate(combined_selector, rasp.SequenceMap(select_or_zero, rasp.tokens, rasp.indices)).named(\"insert_zeros\")\n    \n    return result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [1.6666666666666667, 1.6666666666666667, 1.6666666666666667, 1.6666666666666667, 1.6666666666666667, 1.6666666666666667]. (0.882 error rate)"
            }
        ],
        "make_last_element": [
            {
                "generated rasp code": "def make_last_element() -> rasp.SOp:\n    # Get the length of the sequence\n    all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    length = rasp.SelectorWidth(all_true_selector).named(\"length\")\n    \n    # Create a selector for the last element\n    last_element_selector = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\"last_element_selector\")\n    \n    # Extract the last element and broadcast it\n    last_element = rasp.Aggregate(last_element_selector, rasp.tokens).named(\"last_element\")\n    \n    # Create a selector for all elements except the last one\n    not_last_selector = rasp.Select(rasp.indices, length - 1, rasp.Comparison.LT).named(\"not_last_selector\")\n    \n    # Replace all but the last element with zeros\n    result = rasp.Aggregate(not_last_selector, rasp.Map(lambda x: 0, rasp.tokens), default=None).named(\"result\")\n    \n    # Combine the last element with the zeros\n    final_result = rasp.SequenceMap(lambda x, y: x if y is None else y, last_element, result).named(\"final_result\")\n    \n    return final_result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]. (0.916 error rate)"
            },
            {
                "generated rasp code": "def make_last_element() -> rasp.SOp:\n    # Create a selector for the last element\n    length = rasp.SelectorWidth(rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE)).named(\"length\")\n    last_index = rasp.Map(lambda x: x - 1, length).named(\"last_index\")\n    last_element_selector = rasp.Select(rasp.indices, last_index, rasp.Comparison.EQ).named(\"last_element_selector\")\n\n    # Extract and broadcast the last element\n    last_element_broadcast = rasp.Aggregate(last_element_selector, rasp.tokens).named(\"last_element_broadcast\")\n\n    # Create a sequence of zeros\n    zero_sequence = rasp.Map(lambda x: 0, rasp.tokens).named(\"zero_sequence\")\n\n    # Combine last element with zeros\n    result = rasp.SequenceMap(\n        lambda x, y: x if y != 0 else 0,\n        last_element_broadcast,\n        last_element_selector\n    ).named(\"result\")\n\n    return result\n\n# Example usage:\n# last_element = make_last_element()\n# Output for [1, 2, 3, 4, 5] would be [5, 0, 0, 0, 0]\n# Output for [10, 20] would be [20, 0]",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_last_element() -> rasp.SOp:\n    # Create a selector that identifies the last element\n    last_element_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: len(x) - 1, rasp.tokens),\n        rasp.Comparison.EQ\n    ).named(\"last_element_selector\")\n\n    # Extract and broadcast the last element\n    last_element = rasp.Aggregate(last_element_selector, rasp.tokens).named(\"last_element\")\n\n    # Create a sequence of zeros\n    zeros = rasp.Map(lambda x: 0, rasp.tokens).named(\"zeros\")\n\n    # Combine the last element with zeros\n    result = rasp.SequenceMap(\n        lambda x, y: y if x else 0,\n        last_element_selector,\n        last_element\n    ).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_length() -> rasp.SOp:\n    \"\"\"Creates the `length` SOp using selector width primitive.\"\"\"\n    all_true_selector = rasp.Select(\n        rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\ndef make_last_element() -> rasp.SOp:\n    \"\"\"Returns the last element of the sequence and pads the rest with zeros.\"\"\"\n    # Get the length of the sequence\n    length = make_length()\n\n    # Create a selector that selects only the last element\n    last_elem_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: x - 1, length),\n        rasp.Comparison.EQ\n    ).named(\"last_elem_selector\")\n\n    # Extract the last element and broadcast it\n    last_elem = rasp.Aggregate(last_elem_selector, rasp.tokens, default=None).named(\"last_elem\")\n\n    # Create a sequence of zeros\n    zeros = rasp.Map(lambda x: 0, rasp.tokens).named(\"zeros\")\n\n    # Combine the last element with the zero sequence\n    result = rasp.SequenceMap(\n        lambda x, y: y if x else 0,\n        last_elem_selector,\n        last_elem\n    ).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_last_element() -> rasp.SOp:\n    # Get the length of the sequence\n    length = rasp.SelectorWidth(rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE)).named(\"length\")\n    \n    # Create a selector for the last element\n    last_elem_selector = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\"last_elem_selector\")\n    \n    # Extract the last element\n    last_elem = rasp.Aggregate(last_elem_selector, rasp.tokens).named(\"last_elem\")\n    \n    # Create the output sequence: last element in the last position, zeros elsewhere\n    output = rasp.SequenceMap(\n        lambda x, y: y if x == 0 else 0,  # x is the difference between length and index, y is the last element\n        length - rasp.indices - 1,  # This will be 0 for the last element\n        last_elem\n    ).named(\"output\")\n    \n    return output",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0, 0, 0, 0, 0, 4.0]. (0.82 error rate)"
            }
        ],
        "make_difference_to_next": [
            {
                "generated rasp code": "def make_difference_to_next() -> rasp.SOp:\n    # Create a selector for shifting the sequence left by one position\n    shift_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y + 1).named(\"shift_selector\")\n    \n    # Create the shifted sequence, with the last element defaulting to None\n    shifted_sequence = rasp.Aggregate(shift_selector, rasp.tokens).named(\"shifted_sequence\")\n    \n    # Calculate the differences between the shifted sequence and the original sequence\n    differences = rasp.SequenceMap(\n        lambda x, y: x - y if x is not None else 0,\n        shifted_sequence,\n        rasp.tokens\n    ).named(\"differences\")\n    \n    # Create a selector for the last element\n    last_element_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: len(x) - 1, rasp.tokens),\n        rasp.Comparison.EQ\n    ).named(\"last_element_selector\")\n    \n    # Create a sequence with 0 for the last element and 1 for others\n    last_element_mask = rasp.Map(\n        lambda x: 0 if x else 1,\n        last_element_selector\n    ).named(\"last_element_mask\")\n    \n    # Apply the mask to set the last difference to 0\n    final_differences = rasp.SequenceMap(\n        lambda x, y: x * y,\n        differences,\n        last_element_mask\n    ).named(\"final_differences\")\n    \n    return final_differences",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_difference_to_next() -> rasp.SOp:\n    # Create a selector to shift the sequence left by one position\n    shift_selector = rasp.Select(\n        rasp.indices,\n        rasp.indices,\n        lambda x, y: x == y + 1\n    ).named(\"shift_selector\")\n\n    # Shift the sequence left by one position, repeating the last element\n    shifted_sequence = rasp.Aggregate(\n        shift_selector,\n        rasp.tokens,\n        default=None\n    ).named(\"shifted_sequence\")\n\n    # Calculate the difference between each element and the next\n    difference_sequence = rasp.SequenceMap(\n        lambda x, y: y - x,\n        rasp.tokens,\n        shifted_sequence\n    ).named(\"difference_sequence\")\n\n    # Create a sequence of the same length as the input\n    length = rasp.SelectorWidth(\n        rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE)\n    ).named(\"length\")\n\n    # Set the last element to 0 and keep the rest as is\n    final_sequence = rasp.SequenceMap(\n        lambda diff, idx: 0 if idx == length - 1 else diff,\n        difference_sequence,\n        rasp.indices\n    ).named(\"final_sequence\")\n\n    return final_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0, 0, 0, 0, 0, None]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_difference_to_next() -> rasp.SOp:\n    # Create a selector to shift the sequence by 1 position to the right\n    shift_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y + 1).named(\"shift_selector\")\n\n    # Create the shifted sequence, using the last element to fill the last position\n    shifted_sequence = rasp.Aggregate(shift_selector, rasp.tokens, default=None).named(\"shifted_sequence\")\n\n    # Calculate the difference between the shifted sequence and the original sequence\n    difference_sequence = rasp.SequenceMap(lambda x, y: y - x, rasp.tokens, shifted_sequence).named(\"difference_sequence\")\n\n    # Create a sequence of the same length as the input, filled with the length value\n    length_sequence = rasp.Map(lambda x: len(x), rasp.tokens).named(\"length_sequence\")\n\n    # Set the last element to 0 and keep the rest as they are\n    final_sequence = rasp.SequenceMap(\n        lambda x, y, z: 0 if x == y - 1 else z,\n        rasp.indices,\n        length_sequence,\n        difference_sequence\n    ).named(\"final_sequence\")\n\n    return final_sequence",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            },
            {
                "generated rasp code": "def make_difference_to_next() -> rasp.SOp:\n    # Helper function to shift the sequence by 1 to the right\n    def shift_by_one(sop: rasp.SOp) -> rasp.SOp:\n        select_shifted = rasp.Select(rasp.indices, rasp.indices, lambda k, q: q == k - 1)\n        return rasp.Aggregate(select_shifted, sop).named(\"shifted_sequence\")\n\n    # Shift the sequence by 1 to the right\n    shifted_sequence = shift_by_one(rasp.tokens)\n\n    # Calculate the difference between the shifted sequence and the original sequence\n    difference = rasp.SequenceMap(lambda x, y: x - y, shifted_sequence, rasp.tokens).named(\"difference\")\n\n    # Create a selector for the last element\n    last_element_selector = rasp.Select(rasp.indices, rasp.indices, lambda k, q: k == q)\n    sequence_length = rasp.SelectorWidth(last_element_selector)\n    is_last_element = rasp.Select(rasp.indices, sequence_length, rasp.Comparison.EQ).named(\"is_last_element\")\n\n    # Set the last element to 0\n    result = rasp.SequenceMap(lambda x, y: 0 if y else x, difference, is_last_element).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_difference_to_next() -> rasp.SOp:\n    # Create a selector to shift the sequence left by one position\n    shift_selector = rasp.Select(\n        rasp.indices,\n        rasp.indices,\n        lambda x, y: x == y + 1\n    ).named(\"shift_selector\")\n\n    # Use Aggregate to shift the sequence, using None as the default for the last position\n    shifted_sequence = rasp.Aggregate(shift_selector, rasp.tokens).named(\"shifted_sequence\")\n\n    # Create a sequence of the same length as input, with all elements being the length\n    length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"length\")\n\n    # Use SequenceMap to calculate the difference and adjust the last element\n    difference_sequence = rasp.SequenceMap(\n        lambda x, y, z, i: y - x if i + 1 < z else 0,\n        rasp.tokens,\n        shifted_sequence,\n        length,\n        rasp.indices\n    ).named(\"difference_sequence\")\n\n    return difference_sequence",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 6 were given"
            }
        ],
        "make_invert_if_sorted": [
            {
                "generated rasp code": "def make_length() -> rasp.SOp:\n    \"\"\"Returns an SOp that computes the length of the input sequence.\"\"\"\n    all_true_selector = rasp.Select(\n        rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\ndef make_is_sorted() -> rasp.SOp:\n    \"\"\"Returns an SOp that checks if the input sequence is sorted in ascending order.\"\"\"\n    # Shift the sequence by 1 to compare each element with its predecessor\n    length = make_length()\n    shifted = rasp.Aggregate(\n        rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y + 1),\n        rasp.tokens,\n        default=None\n    ).named(\"shifted\")\n    \n    # Compare each element with its predecessor\n    is_ge = rasp.SequenceMap(\n        lambda x, y: 1 if (y is None or x >= y) else 0,\n        rasp.tokens,\n        shifted\n    ).named(\"is_ge\")\n    \n    # Check if all comparisons are true\n    all_ge = rasp.Aggregate(\n        rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE),\n        is_ge,\n        default=None\n    ).named(\"all_ge\")\n    \n    # Propagate the result across the entire sequence\n    return rasp.Map(lambda x: x == 1, all_ge).named(\"is_sorted\")\n\ndef make_reverse() -> rasp.SOp:\n    \"\"\"Returns an SOp that reverses the input sequence.\"\"\"\n    length = make_length()\n    reverse_indices = rasp.SequenceMap(lambda l, i: l - i - 1, length, rasp.indices).named(\"reverse_indices\")\n    reverse_selector = rasp.Select(reverse_indices, rasp.indices, rasp.Comparison.EQ).named(\"reverse_selector\")\n    return rasp.Aggregate(reverse_selector, rasp.tokens, default=None).named(\"reverse\")\n\ndef make_invert_if_sorted() -> rasp.SOp:\n    \"\"\"Returns an SOp that inverts the sequence if it's sorted in ascending order, otherwise leaves it unchanged.\"\"\"\n    is_sorted = make_is_sorted()\n    reverse = make_reverse()\n    \n    # Combine the original sequence and the reversed sequence based on the sorting check\n    return rasp.SequenceMap(\n        lambda sorted, orig, rev: rev if sorted else orig,\n        is_sorted,\n        rasp.tokens,\n        reverse\n    ).named(\"invert_if_sorted\")",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            },
            {
                "generated rasp code": "def make_invert_if_sorted() -> rasp.SOp:\n    # Create a selector to check if each element is less than or equal to the next element\n    sorting_check = rasp.Select(rasp.tokens, shift_by(1, rasp.tokens, float('inf')), rasp.Comparison.LEQ).named(\"sorting_check\")\n\n    # Count how many elements satisfy the sorting condition\n    sort_count = rasp.SelectorWidth(sorting_check).named(\"sort_count\")\n\n    # Get the length of the sequence\n    length = make_length()\n\n    # Check if the sequence is sorted (sort_count should equal length * (length - 1))\n    is_sorted = rasp.SequenceMap(lambda x, y: x == y * (y - 1), sort_count, length).named(\"is_sorted\")\n\n    # Create a reverse selector\n    reverse_selector = rasp.Select(rasp.indices, length - rasp.indices - 1, rasp.Comparison.EQ).named(\"reverse_selector\")\n\n    # Create the inverted sequence\n    inverted_sequence = rasp.Aggregate(reverse_selector, rasp.tokens).named(\"inverted_sequence\")\n\n    # Choose between original and inverted sequence based on whether it's sorted\n    result = rasp.SequenceMap(lambda x, y, z: y if x else z, is_sorted, inverted_sequence, rasp.tokens).named(\"result\")\n\n    return result\n\ndef make_length() -> rasp.SOp:\n    all_true_selector = rasp.Select(\n        rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\ndef shift_by(offset: int, sop: rasp.SOp, fill: rasp.Value) -> rasp.SOp:\n    \"\"\"Returns the sop, shifted by `offset`, filled with `fill` value.\"\"\"\n    select_off_by_offset = rasp.Select(rasp.indices, rasp.indices,\n                                       lambda k, q: q == k + offset)\n    out = rasp.Aggregate(select_off_by_offset, sop, default=None)\n    return out.named(f\"shift_by({offset})\")",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            },
            {
                "generated rasp code": "def make_length() -> rasp.SOp:\n    \"\"\"Creates an SOp that returns the length of the input sequence.\"\"\"\n    all_true_selector = rasp.Select(\n        rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\ndef make_invert_if_sorted() -> rasp.SOp:\n    \"\"\"Creates an SOp that inverts the sequence if it's sorted in ascending order, otherwise leaves it unchanged.\"\"\"\n    \n    # Get the length of the sequence\n    length = make_length()\n    \n    # Create a selector for adjacent elements in ascending order\n    adjacent_selector = rasp.Select(\n        rasp.indices, rasp.indices, lambda x, y: x + 1 == y\n    ).named(\"adjacent_selector\")\n    \n    # Check if each element is less than or equal to the next\n    ascending_check = rasp.Select(\n        rasp.tokens, rasp.tokens, rasp.Comparison.LEQ\n    ).named(\"ascending_check\")\n    \n    # Combine selectors to check ascending order of adjacent elements\n    ascending_adjacent = (adjacent_selector & ascending_check).named(\"ascending_adjacent\")\n    \n    # Count how many adjacent pairs are in ascending order\n    ascending_count = rasp.SelectorWidth(ascending_adjacent).named(\"ascending_count\")\n    \n    # Check if the count equals length - 1 (fully sorted)\n    is_sorted = rasp.SequenceMap(\n        lambda count, len: count == len - 1, ascending_count, length\n    ).named(\"is_sorted\")\n    \n    # Create a reverse selector\n    reverse_selector = rasp.Select(\n        rasp.indices, rasp.indices, lambda x, y: x + y + 1 == length\n    ).named(\"reverse_selector\")\n    \n    # Reverse the sequence\n    reversed_sequence = rasp.Aggregate(reverse_selector, rasp.tokens).named(\"reversed_sequence\")\n    \n    # Choose between original and reversed sequence based on sorting condition\n    return rasp.SequenceMap(\n        lambda orig, rev, cond: rev if cond else orig,\n        rasp.tokens, reversed_sequence, is_sorted\n    ).named(\"invert_if_sorted\")",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            },
            {
                "generated rasp code": "def make_invert_if_sorted() -> rasp.SOp:\n    # Create a selector that checks if each element is less than or equal to the next element\n    leq_next_selector = rasp.Select(rasp.tokens, rasp.tokens, lambda x, y: x <= y).named(\"leq_next_selector\")\n\n    # Shift the selector by 1 to align with the correct pairs\n    shifted_selector = rasp.SequenceMap(lambda x, y: y, rasp.indices, leq_next_selector).named(\"shifted_selector\")\n\n    # Count how many elements satisfy the condition\n    sorted_count = rasp.SelectorWidth(shifted_selector).named(\"sorted_count\")\n\n    # Check if the count equals the sequence length minus 1 (which would indicate a sorted sequence)\n    is_sorted = rasp.SequenceMap(lambda x, y: x == y, sorted_count, rasp.indices).named(\"is_sorted\")\n\n    # Create a selector for reversing the sequence\n    reverse_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x + y + 1 == len(rasp.tokens)).named(\"reverse_selector\")\n\n    # Reverse the sequence if it's sorted, otherwise keep it as is\n    reversed_sequence = rasp.Aggregate(reverse_selector, rasp.tokens).named(\"reversed_sequence\")\n    \n    return rasp.SequenceMap(lambda x, y: y if x else rasp.tokens, is_sorted, reversed_sequence).named(\"invert_if_sorted\")",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_invert_if_sorted() -> rasp.SOp:\n    # Create a selector that checks if each element is less than or equal to the next element\n    adjacent_leq_selector = rasp.Select(rasp.tokens, shift_by(1, rasp.tokens, None), rasp.Comparison.LEQ).named(\"adjacent_leq_selector\")\n\n    # Count how many times the adjacent less than or equal condition is true\n    sort_count = rasp.SelectorWidth(adjacent_leq_selector).named(\"sort_count\")\n\n    # Create a sequence of the length of the input\n    def make_length() -> rasp.SOp:\n        all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n        return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n    # Subtract 1 from the length to compare with sort_count\n    length_minus_one = rasp.SequenceMap(lambda x, y: x - 1, make_length(), rasp.Map(lambda x: 1, rasp.tokens)).named(\"length_minus_one\")\n\n    # Check if the sequence is sorted (sort_count should equal length - 1)\n    is_sorted = rasp.Select(sort_count, length_minus_one, rasp.Comparison.EQ).named(\"is_sorted\")\n\n    # Create a reversed version of the sequence\n    def shift_by(offset: int, sop: rasp.SOp, fill: rasp.Value) -> rasp.SOp:\n        select_off_by_offset = rasp.Select(rasp.indices, rasp.indices, lambda k, q: q == k + offset)\n        out = rasp.Aggregate(select_off_by_offset, sop, default=fill)\n        return out.named(f\"shift_by({offset})\")\n\n    reversed_sequence = shift_by(-1, rasp.tokens, None).named(\"reversed_sequence\")\n\n    # Combine the original and reversed sequences based on whether the sequence is sorted\n    return rasp.SequenceMap(\n        lambda original, reversed, sorted: reversed if sorted else original,\n        rasp.tokens,\n        reversed_sequence,\n        rasp.Aggregate(is_sorted, rasp.Map(lambda x: True, rasp.tokens))\n    ).named(\"invert_if_sorted\")",
                "failure stage": 0,
                "error": "local variable 'shift_by' referenced before assignment"
            }
        ],
        "make_logarithm": [
            {
                "generated rasp code": "def make_logarithm() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP SOp that applies logarithm base 10 to each element of the input sequence.\n    Non-positive numbers are handled by returning None for those elements.\n    The result is rounded to 6 decimal places to avoid floating-point precision issues.\n    \"\"\"\n    return rasp.Map(\n        lambda x: round(__import__('math').log10(x), 6) if x > 0 else None,\n        rasp.tokens\n    ).named(\"logarithm_base_10\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0.477121, 0.90309, 0.30103, 0.0, 0.69897, 0.60206]. (0.988 error rate)"
            },
            {
                "generated rasp code": "def make_logarithm() -> rasp.SOp:\n    def log10_approx(x):\n        if x <= 0:\n            return -1e6  # Return a very large negative number for non-positive inputs\n        \n        # Approximate natural logarithm using Taylor series\n        y = (x - 1) / (x + 1)\n        ln_x = 2 * (y + y**3/3 + y**5/5 + y**7/7 + y**9/9)\n        \n        # Use change of base formula to get log base 10\n        return ln_x / 2.30258509  # 2.30258509 is an approximation of ln(10)\n\n    return rasp.Map(log10_approx, rasp.tokens).named(\"logarithm_base_10\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0.47707227356720777, 0.8926575780701718, 0.301029503926314, 0.0, 0.6974950898269934, 0.6016462390228416]. (0.988 error rate)"
            },
            {
                "generated rasp code": "def make_logarithm() -> rasp.SOp:\n    def approximate_ln(x):\n        # Taylor series approximation of ln(1+x) up to 5th term\n        # Valid for -1 < x <= 1\n        return x - x**2/2 + x**3/3 - x**4/4 + x**5/5\n\n    def log10_approximation(x):\n        # Ensure x > 0 by adding a small number\n        x = x + 1e-10\n        # Scale x to be close to 1\n        scale = 0\n        while x > 2:\n            x /= 10\n            scale += 1\n        while x <= 0.2:\n            x *= 10\n            scale -= 1\n        # Apply ln approximation and change of base formula\n        return (approximate_ln(x - 1) / approximate_ln(9)) + scale\n\n    return rasp.Map(log10_approximation, rasp.tokens).named(\"logarithm_base_10\")",
                "failure stage": 0,
                "error": "Error in defining op"
            },
            {
                "generated rasp code": "def make_logarithm() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP SOp that applies logarithm base 10 to each element of the input sequence.\n    \n    Returns:\n    rasp.SOp: A sequence operation that computes log10 of each element.\n    \"\"\"\n    \n    def log10(x):\n        \"\"\"\n        Compute log base 10 of x using natural logarithm.\n        \n        Args:\n        x (float): The input value\n        \n        Returns:\n        float: log10(x) or None if x <= 0\n        \"\"\"\n        if x <= 0:\n            return None\n        return 2.302585092994046 * x.ln()  # ln(10) * ln(x) = log10(x)\n    \n    return rasp.Map(lambda x: log10(x), rasp.tokens).named(\"logarithm_base_10\")",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_logarithm() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP SOp that applies logarithm base 10 to each element of the input sequence.\n    \n    Returns:\n    rasp.SOp: A sequence operation that computes log base 10 of each element.\n    \"\"\"\n    \n    # Define a helper function to compute log base 10\n    def log10(x):\n        if x <= 0:\n            return -1e6  # Return a very small number for non-positive inputs\n        try:\n            return _builtins__.log(x) / _builtins__.log(10)\n        except:\n            return -1e6  # Return a very small number if computation fails (e.g., for very small positive numbers)\n\n    # Use rasp.Map to apply the logarithm function to each element\n    return rasp.Map(log10, rasp.tokens).named(\"logarithm_base_10\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [-1000000.0, -1000000.0, -1000000.0, -1000000.0, -1000000.0, -1000000.0]. (1.0 error rate)"
            }
        ],
        "make_product_with_next": [
            {
                "generated rasp code": "def make_product_with_next() -> rasp.SOp:\n    # Create a selector that shifts the sequence by one position to the left\n    shift_selector = rasp.Select(\n        rasp.indices,\n        rasp.indices,\n        lambda x, y: x == y + 1\n    ).named(\"shift_selector\")\n\n    # Create a selector for the last element\n    last_element_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: len(x) - 1, rasp.tokens),\n        rasp.Comparison.EQ\n    ).named(\"last_element_selector\")\n\n    # Combine the selectors\n    combined_selector = rasp.Select(\n        rasp.indices,\n        rasp.indices,\n        lambda x, y: (x == y + 1) or (y == len(rasp.tokens) - 1)\n    ).named(\"combined_selector\")\n\n    # Create the shifted sequence, where the last element is repeated\n    shifted_sequence = rasp.Aggregate(combined_selector, rasp.tokens).named(\"shifted_sequence\")\n\n    # Multiply the original sequence with the shifted sequence element-wise\n    product_sequence = rasp.SequenceMap(\n        lambda x, y: x * y,\n        rasp.tokens,\n        shifted_sequence\n    ).named(\"product_sequence\")\n\n    return product_sequence",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_product_with_next() -> rasp.SOp:\n    # Create a selector that shifts the sequence by one position to the left\n    shift_selector = rasp.Select(\n        rasp.indices,\n        rasp.indices,\n        lambda x, y: x == y + 1\n    ).named(\"shift_selector\")\n\n    # Create the shifted sequence\n    shifted_sequence = rasp.Aggregate(\n        shift_selector,\n        rasp.tokens,\n        default=None\n    ).named(\"shifted_sequence\")\n\n    # Create a selector for the last element\n    last_elem_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: len(x) - 1, rasp.tokens),\n        rasp.Comparison.EQ\n    ).named(\"last_elem_selector\")\n\n    # Replace the last element of the shifted sequence with the last element of the original sequence\n    shifted_sequence_with_last = rasp.SequenceMap(\n        lambda x, y: y if x else x,\n        last_elem_selector,\n        rasp.tokens\n    ).named(\"shifted_sequence_with_last\")\n\n    # Combine the shifted sequence with the original sequence\n    final_shifted_sequence = rasp.SequenceMap(\n        lambda x, y: x if x is not None else y,\n        shifted_sequence,\n        shifted_sequence_with_last\n    ).named(\"final_shifted_sequence\")\n\n    # Multiply the original sequence with the shifted sequence\n    product_sequence = rasp.SequenceMap(\n        lambda x, y: x * y,\n        rasp.tokens,\n        final_shifted_sequence\n    ).named(\"product_sequence\")\n\n    return product_sequence",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_product_with_next() -> rasp.SOp:\n    # Create a selector for the last element\n    last_elem_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: len(x) - 1, rasp.tokens),\n        rasp.Comparison.EQ\n    ).named(\"last_elem_selector\")\n\n    # Create a shifted sequence where each element is the next element,\n    # and the last element is duplicated\n    shifted_sequence = rasp.SequenceMap(\n        lambda x, y: y,\n        rasp.tokens,\n        rasp.Aggregate(last_elem_selector, rasp.tokens)\n    ).named(\"shifted_sequence\")\n\n    # Multiply each element with its next element (or itself for the last element)\n    product_sequence = rasp.SequenceMap(\n        lambda x, y: x * y,\n        rasp.tokens,\n        shifted_sequence\n    ).named(\"product_sequence\")\n\n    return product_sequence",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_product_with_next() -> rasp.SOp:\n    # Create a selector that shifts indices by 1 (to the left)\n    shift_selector = rasp.Select(\n        rasp.indices,\n        rasp.indices,\n        lambda x, y: x == y + 1\n    ).named(\"shift_selector\")\n\n    # Create a shifted sequence using the shift_selector\n    # The default=None ensures that the last element remains unchanged\n    shifted_sequence = rasp.Aggregate(shift_selector, rasp.tokens, default=None).named(\"shifted_sequence\")\n\n    # Multiply the original sequence with the shifted sequence element-wise\n    # If the shifted element is None (for the last position), use the original element\n    product_sequence = rasp.SequenceMap(\n        lambda x, y: x * (y if y is not None else x),\n        rasp.tokens,\n        shifted_sequence\n    ).named(\"product_sequence\")\n\n    return product_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [24.0, 16.0, 2.0, 5.0, 20.0, None]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_product_with_next() -> rasp.SOp:\n    # Create a selector that shifts the sequence by one position to the left\n    shift_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y + 1).named(\"shift_selector\")\n    \n    # Create a selector for the last element\n    last_elem_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y).named(\"last_elem_selector\")\n    \n    # Combine the selectors: use shift_selector for all but the last element, and last_elem_selector for the last\n    combined_selector = (shift_selector | last_elem_selector).named(\"combined_selector\")\n    \n    # Create the shifted sequence using the combined selector\n    shifted_sequence = rasp.Aggregate(combined_selector, rasp.tokens).named(\"shifted_sequence\")\n    \n    # Multiply each element with its next (or itself for the last element)\n    product_sequence = rasp.SequenceMap(lambda x, y: x * y, rasp.tokens, shifted_sequence).named(\"product_sequence\")\n    \n    return product_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [16.5, 40.0, 3.0, 3.0, 22.5, 16.0]. (0.89 error rate)"
            }
        ],
        "make_check_multiple_of_first": [
            {
                "generated rasp code": "def make_check_multiple_of_first() -> rasp.SOp:\n    # Select the first element\n    first_elem_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == 0).named(\"first_elem_selector\")\n    first_elem = rasp.Aggregate(first_elem_selector, rasp.tokens).named(\"first_elem\")\n\n    # Check if first element is zero\n    is_first_zero = rasp.SequenceMap(lambda x, y: x == 0, first_elem, first_elem).named(\"is_first_zero\")\n\n    # Create a sequence of 1 for the first element and 0 for others (used when first element is 0)\n    zero_case = rasp.SequenceMap(lambda x, y: 1 if x == 0 else 0, rasp.indices, rasp.indices).named(\"zero_case\")\n\n    # Divide each element by the first element\n    division_result = rasp.SequenceMap(lambda x, y: x / y if y != 0 else None, rasp.tokens, first_elem).named(\"division_result\")\n\n    # Check if each element is a multiple of the first (i.e., if the division result is an integer)\n    is_multiple = rasp.Map(lambda x: 1 if x is not None and x.is_integer() else 0, division_result).named(\"is_multiple\")\n\n    # Combine the zero case and the general case\n    result = rasp.SequenceMap(lambda x, y: y if x else z, is_first_zero, zero_case, is_multiple).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            },
            {
                "generated rasp code": "def make_check_multiple_of_first() -> rasp.SOp:\n    # Select the first element\n    first_elem_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == 0).named(\"first_elem_selector\")\n    first_elem = rasp.Aggregate(first_elem_selector, rasp.tokens).named(\"first_elem\")\n\n    # Divide each element by the first element\n    divided = rasp.SequenceMap(lambda x, y: x / y if y != 0 else None, rasp.tokens, first_elem).named(\"divided\")\n\n    # Check if each element is a multiple of the first element\n    def is_multiple(x, i):\n        if i == 0:  # First element is always a multiple of itself\n            return 1\n        elif x is None:  # Handle division by zero\n            return 0\n        else:\n            return 1 if x.is_integer() else 0\n\n    return rasp.SequenceMap(is_multiple, divided, rasp.indices).named(\"check_multiple_of_first\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [1, 0, 0, 0, 0, 0]. (0.104 error rate)"
            },
            {
                "generated rasp code": "def make_check_multiple_of_first() -> rasp.SOp:\n    # Select the first element\n    first_elem_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == 0).named(\"first_elem_selector\")\n    first_elem = rasp.Aggregate(first_elem_selector, rasp.tokens).named(\"first_elem\")\n\n    # Check if first element is zero\n    is_first_zero = rasp.SequenceMap(lambda x, y: x == 0, first_elem, rasp.tokens).named(\"is_first_zero\")\n\n    # Divide each element by the first element\n    division_result = rasp.SequenceMap(\n        lambda x, y: y / x if x != 0 else float('inf'),\n        first_elem,\n        rasp.tokens\n    ).named(\"division_result\")\n\n    # Check if each element is a multiple of the first\n    is_multiple = rasp.Map(\n        lambda x: 1 if x.is_integer() else 0,\n        division_result\n    ).named(\"is_multiple\")\n\n    # If first element is zero, return all 1's, otherwise return is_multiple\n    return rasp.SequenceMap(\n        lambda x, y: 1 if x else y,\n        is_first_zero,\n        is_multiple\n    ).named(\"check_multiple_of_first\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [1, 0, 0, 0, 0, 0]. (0.104 error rate)"
            },
            {
                "generated rasp code": "def make_check_multiple_of_first() -> rasp.SOp:\n    # Select the first element\n    first_elem_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == 0).named(\"first_elem_selector\")\n    first_elem = rasp.Aggregate(first_elem_selector, rasp.tokens).named(\"first_elem\")\n\n    # Check if first element is zero\n    is_first_zero = rasp.SequenceMap(lambda x, y: x == 0, first_elem, rasp.tokens).named(\"is_first_zero\")\n\n    # Create a sequence of 1 for first element, 0 for others (used when first element is 0)\n    zero_case = rasp.SequenceMap(lambda x, y: 1 if x == 0 else 0, rasp.indices, rasp.tokens).named(\"zero_case\")\n\n    # Perform division and check if result is integer\n    division_result = rasp.SequenceMap(lambda x, y: y / x if x != 0 else 0, first_elem, rasp.tokens).named(\"division_result\")\n    is_multiple = rasp.Map(lambda x: 1 if x.is_integer() else 0, division_result).named(\"is_multiple\")\n\n    # Combine results: use zero_case if first element is 0, otherwise use is_multiple\n    return rasp.SequenceMap(lambda x, y: y if x else z, is_first_zero, zero_case, is_multiple).named(\"check_multiple_of_first\")",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            },
            {
                "generated rasp code": "def make_check_multiple_of_first() -> rasp.SOp:\n    # Select the first element\n    first_elem_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == 0).named(\"first_elem_selector\")\n    first_elem = rasp.Aggregate(first_elem_selector, rasp.tokens, default=None).named(\"first_elem\")\n\n    # Check if the first element is zero\n    is_zero = rasp.SequenceMap(lambda x, y: x == 0, first_elem, rasp.tokens).named(\"is_zero\")\n\n    # Divide each element by the first element\n    # If the first element is zero, we'll divide by 1 to avoid division by zero\n    safe_first_elem = rasp.Map(lambda x: 1 if x == 0 else x, first_elem).named(\"safe_first_elem\")\n    division_result = rasp.SequenceMap(lambda x, y: y / x if x != 0 else 0, safe_first_elem, rasp.tokens).named(\"division_result\")\n\n    # Check if the division result is an integer\n    is_multiple = rasp.Map(lambda x: 1 if x.is_integer() else 0, division_result).named(\"is_multiple\")\n\n    # If the first element is zero, return all 1s, otherwise return the is_multiple result\n    return rasp.SequenceMap(lambda x, y: 1 if x else y, is_zero, is_multiple).named(\"check_multiple_of_first\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [1, 0, 0, 0, 0, 0]. (0.104 error rate)"
            }
        ],
        "make_sum_of_last_two": [
            {
                "generated rasp code": "def make_sum_of_last_two() -> rasp.SOp:\n    # Create a function to get the length of the sequence\n    def make_length() -> rasp.SOp:\n        all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n        return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n    length = make_length()\n\n    # Create a selector for the last element\n    last_elem_selector = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\"last_elem_selector\")\n\n    # Create a selector for the second-to-last element\n    second_last_elem_selector = rasp.Select(rasp.indices, length - 2, rasp.Comparison.EQ).named(\"second_last_elem_selector\")\n\n    # Extract the last element\n    last_elem = rasp.Aggregate(last_elem_selector, rasp.tokens).named(\"last_elem\")\n\n    # Extract the second-to-last element\n    second_last_elem = rasp.Aggregate(second_last_elem_selector, rasp.tokens).named(\"second_last_elem\")\n\n    # Sum the last two elements\n    sum_last_two = rasp.SequenceMap(lambda x, y: x + y if x is not None and y is not None else None, \n                                    last_elem, second_last_elem).named(\"sum_last_two\")\n\n    # Create a selector for sequences of length 1\n    length_one_selector = rasp.Select(length, rasp.Map(lambda x: 1, rasp.indices), rasp.Comparison.EQ).named(\"length_one_selector\")\n\n    # Return None for sequences of length 1, otherwise return the sum of last two\n    return rasp.Aggregate(length_one_selector, rasp.Map(lambda x: None, rasp.tokens), \n                          default=sum_last_two).named(\"sum_of_last_two\")",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_sum_of_last_two() -> rasp.SOp:\n    # Function to get the length of the sequence\n    def make_length() -> rasp.SOp:\n        all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n        return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n    # Get the length of the sequence\n    length = make_length()\n\n    # Create a selector for the last element\n    last_elem_selector = rasp.Select(rasp.indices, length - 1, rasp.Comparison.EQ).named(\"last_elem_selector\")\n\n    # Create a selector for the second-to-last element\n    second_last_elem_selector = rasp.Select(rasp.indices, length - 2, rasp.Comparison.EQ).named(\"second_last_elem_selector\")\n\n    # Extract the last element\n    last_elem = rasp.Aggregate(last_elem_selector, rasp.tokens).named(\"last_elem\")\n\n    # Extract the second-to-last element\n    second_last_elem = rasp.Aggregate(second_last_elem_selector, rasp.tokens).named(\"second_last_elem\")\n\n    # Sum the last two elements\n    sum_last_two = rasp.SequenceMap(lambda x, y: x + y if x is not None and y is not None else None, last_elem, second_last_elem).named(\"sum_last_two\")\n\n    # Create a selector for sequences with length > 1\n    length_gt_one_selector = rasp.Select(length, rasp.Map(lambda x: 1, rasp.indices), rasp.Comparison.GT).named(\"length_gt_one_selector\")\n\n    # Return the sum for sequences with length > 1, otherwise return None\n    return rasp.Aggregate(length_gt_one_selector, sum_last_two).named(\"sum_of_last_two\")",
                "failure stage": 1,
                "error": "Unsupported type for aggregation: [12.0, 12.0, 12.0, 12.0, 12.0, 12.0]"
            },
            {
                "generated rasp code": "def make_length() -> rasp.SOp:\n    \"\"\"Creates an SOp that returns the length of the input sequence.\"\"\"\n    all_true_selector = rasp.Select(\n        rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\ndef make_sum_of_last_two() -> rasp.SOp:\n    \"\"\"Creates an SOp that returns the sum of the last two elements in the sequence.\"\"\"\n    # Get the length of the sequence\n    length = make_length()\n\n    # Create a selector for the last element\n    last_elem_selector = rasp.Select(\n        rasp.indices, length - 1, rasp.Comparison.EQ).named(\"last_elem_selector\")\n\n    # Create a selector for the second to last element\n    second_last_elem_selector = rasp.Select(\n        rasp.indices, length - 2, rasp.Comparison.EQ).named(\"second_last_elem_selector\")\n\n    # Get the last element\n    last_elem = rasp.Aggregate(last_elem_selector, rasp.tokens).named(\"last_elem\")\n\n    # Get the second to last element\n    second_last_elem = rasp.Aggregate(second_last_elem_selector, rasp.tokens).named(\"second_last_elem\")\n\n    # Sum the last two elements\n    sum_last_two = rasp.SequenceMap(lambda x, y: x + y if x is not None and y is not None else None, \n                                    last_elem, second_last_elem).named(\"sum_last_two\")\n\n    # Create a selector for sequences of length 1\n    length_one_selector = rasp.Select(length, rasp.tokens, lambda x, y: x == 1).named(\"length_one_selector\")\n\n    # Return None for sequences of length 1, otherwise return the sum of last two\n    return rasp.Aggregate(length_one_selector, rasp.tokens, default=sum_last_two).named(\"sum_of_last_two\")",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_sum_of_last_two() -> rasp.SOp:\n    # Create a function to get the length of the sequence\n    def make_length() -> rasp.SOp:\n        all_true_selector = rasp.Select(\n            rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n        return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n    length = make_length()\n\n    # Create a selector for the last element\n    last_elem_selector = rasp.Select(\n        rasp.indices, length, rasp.Comparison.EQ).named(\"last_elem_selector\")\n\n    # Create a selector for the second to last element\n    second_last_elem_selector = rasp.Select(\n        rasp.indices, length - 1, rasp.Comparison.EQ).named(\"second_last_elem_selector\")\n\n    # Use Aggregate to get the last element\n    last_elem = rasp.Aggregate(last_elem_selector, rasp.tokens).named(\"last_elem\")\n\n    # Use Aggregate to get the second to last element\n    second_last_elem = rasp.Aggregate(second_last_elem_selector, rasp.tokens).named(\"second_last_elem\")\n\n    # Use SequenceMap to add these two elements\n    sum_last_two = rasp.SequenceMap(lambda x, y: x + y if x is not None and y is not None else None, \n                                    last_elem, second_last_elem).named(\"sum_last_two\")\n\n    # Create a selector to check if the sequence length is 1\n    length_one_selector = rasp.Select(length, rasp.Map(lambda x: 1, rasp.tokens), \n                                      rasp.Comparison.EQ).named(\"length_one_selector\")\n\n    # Use Aggregate to return None if the sequence length is 1, otherwise return the sum\n    result = rasp.Aggregate(length_one_selector, rasp.Map(lambda x: None, rasp.tokens), \n                            default=sum_last_two).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_sum_of_last_two() -> rasp.SOp:\n    # Create a function to get the length of the sequence\n    def make_length() -> rasp.SOp:\n        all_true_selector = rasp.Select(\n            rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n        return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n    # Get the length of the sequence\n    length = make_length()\n\n    # Create a selector for the last element\n    last_elem_selector = rasp.Select(\n        rasp.indices, length - 1, rasp.Comparison.EQ).named(\"last_elem_selector\")\n\n    # Create a selector for the second-to-last element\n    second_last_elem_selector = rasp.Select(\n        rasp.indices, length - 2, rasp.Comparison.EQ).named(\"second_last_elem_selector\")\n\n    # Extract the last element\n    last_elem = rasp.Aggregate(last_elem_selector, rasp.tokens).named(\"last_elem\")\n\n    # Extract the second-to-last element\n    second_last_elem = rasp.Aggregate(second_last_elem_selector, rasp.tokens).named(\"second_last_elem\")\n\n    # Sum the last two elements\n    sum_last_two = rasp.SequenceMap(lambda x, y: x + y if x is not None and y is not None else None, \n                                    last_elem, second_last_elem).named(\"sum_last_two\")\n\n    # Create a selector for sequences with length > 1\n    length_gt_one = rasp.Select(length, rasp.Map(lambda x: 1, rasp.indices), rasp.Comparison.GT).named(\"length_gt_one\")\n\n    # Return sum_last_two for sequences with length > 1, otherwise return None\n    return rasp.Aggregate(length_gt_one, sum_last_two).named(\"sum_of_last_two\")",
                "failure stage": 1,
                "error": "Unsupported type for aggregation: [12.0, 12.0, 12.0, 12.0, 12.0, 12.0]"
            }
        ],
        "make_pairwise_sum": [
            {
                "generated rasp code": "def make_pairwise_sum() -> rasp.SOp:\n    # Define shift_by function\n    def shift_by(offset: int, sop: rasp.SOp, fill: rasp.Value) -> rasp.SOp:\n        \"\"\"Returns the sop, shifted by `offset`, filled with `fill` value.\"\"\"\n        select_off_by_offset = rasp.Select(rasp.indices, rasp.indices,\n                                           lambda k, q: q == k + offset)\n        out = rasp.Aggregate(select_off_by_offset, sop, default=fill)\n        return out.named(f\"shift_by({offset})\")\n\n    # Shift the sequence by 1 to the right, filling with 0\n    shifted_sequence = shift_by(1, rasp.tokens, fill=0).named(\"shifted_sequence\")\n\n    # Add each element with its previous (shifted) element\n    summed_sequence = rasp.SequenceMap(lambda x, y: x + y, rasp.tokens, shifted_sequence).named(\"summed_sequence\")\n\n    # Create a selector for the first element\n    first_elem_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == 0).named(\"first_elem_selector\")\n\n    # Replace the first element of the summed sequence with the original first element\n    result = rasp.Aggregate(first_elem_selector, rasp.tokens, default=None).named(\"first_elem\") + \\\n             rasp.Aggregate(~first_elem_selector, summed_sequence, default=None).named(\"rest_of_sequence\")\n\n    return result.named(\"pairwise_sum\")",
                "failure stage": 1,
                "error": "Unsupported type for aggregation: [10.0, 4.0, 12.0, 9.0, 8.0, 17.0, 9.0, 3.0, 10.0]"
            },
            {
                "generated rasp code": "def shift_by(offset: int, sop: rasp.SOp, fill: rasp.Value) -> rasp.SOp:\n    \"\"\"Returns the sop, shifted by `offset`, filled with `fill` value.\"\"\"\n    select_off_by_offset = rasp.Select(rasp.indices, rasp.indices,\n                                       lambda k, q: q == k + offset)\n    out = rasp.Aggregate(select_off_by_offset, sop, default=fill)\n    return out.named(f\"shift_by({offset})\")\n\ndef make_pairwise_sum() -> rasp.SOp:\n    # Shift the sequence by 1 to the right, filling with 0\n    shifted_sequence = shift_by(1, rasp.tokens, fill=0).named(\"shifted_sequence\")\n    \n    # Add the original sequence with the shifted sequence\n    pairwise_sum = rasp.SequenceMap(lambda x, y: x + y, rasp.tokens, shifted_sequence).named(\"pairwise_sum\")\n    \n    # Create a selector for the first element\n    first_elem_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == 0).named(\"first_elem_selector\")\n    \n    # Keep the first element unchanged\n    first_elem = rasp.Aggregate(first_elem_selector, rasp.tokens).named(\"first_elem\")\n    \n    # Combine the pairwise sum with the unchanged first element\n    result = rasp.SequenceMap(\n        lambda x, y: y if y is not None else x,\n        pairwise_sum,\n        first_elem\n    ).named(\"result\")\n    \n    return result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3.0, 3.0, 3.0, 3.0, 3.0, 3.0]. (0.884 error rate)"
            },
            {
                "generated rasp code": "def make_pairwise_sum() -> rasp.SOp:\n    def shift_by_one(sop: rasp.SOp, fill: rasp.Value) -> rasp.SOp:\n        \"\"\"Returns the sop, shifted by 1 to the right, filled with `fill` value.\"\"\"\n        select_previous = rasp.Select(rasp.indices, rasp.indices,\n                                      lambda k, q: q == k + 1)\n        return rasp.Aggregate(select_previous, sop, default=None).named(\"shift_by_one\")\n\n    # Shift the sequence by 1 to the right, filling with 0\n    shifted_sequence = shift_by_one(rasp.tokens, 0).named(\"shifted_sequence\")\n\n    # Add the original sequence and the shifted sequence\n    pairwise_sum = rasp.SequenceMap(lambda x, y: x + y, rasp.tokens, shifted_sequence).named(\"pairwise_sum\")\n\n    # Create a selector for the first element\n    first_elem_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == 0).named(\"first_elem_selector\")\n\n    # Combine the first element with the pairwise sum sequence\n    result = rasp.Aggregate(first_elem_selector, rasp.tokens, default=None).named(\"first_elem\") + \\\n             rasp.Aggregate(~first_elem_selector, pairwise_sum, default=None).named(\"rest_of_sequence\")\n\n    return result",
                "failure stage": 1,
                "error": "Unsupported type for aggregation: [10.0, 4.0, 12.0, 9.0, 8.0, 17.0, 9.0, 3.0, 10.0]"
            },
            {
                "generated rasp code": "def make_pairwise_sum() -> rasp.SOp:\n    def shift_by(offset: int, sop: rasp.SOp, fill: rasp.Value) -> rasp.SOp:\n        \"\"\"Returns the sop, shifted by `offset`, filled with `fill` value.\"\"\"\n        select_off_by_offset = rasp.Select(rasp.indices, rasp.indices,\n                                           lambda k, q: q == k + offset)\n        out = rasp.Aggregate(select_off_by_offset, sop, default=fill)\n        return out.named(f\"shift_by({offset})\")\n\n    # Shift the input sequence by 1 to the right, filling with 0\n    shifted_sequence = shift_by(1, rasp.tokens, fill=0).named(\"shifted_sequence\")\n\n    # Add the original sequence and the shifted sequence element-wise\n    summed_sequence = rasp.SequenceMap(lambda x, y: x + y, rasp.tokens, shifted_sequence).named(\"summed_sequence\")\n\n    # Create a selector for the first element\n    first_element_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == 0).named(\"first_element_selector\")\n\n    # Replace the first element of the summed sequence with the original first element\n    result = rasp.Aggregate(first_element_selector, rasp.tokens, default=None).named(\"first_element\") + \\\n             rasp.Aggregate(~first_element_selector, summed_sequence, default=None).named(\"rest_of_sequence\")\n\n    return result.named(\"pairwise_sum\")",
                "failure stage": 1,
                "error": "Unsupported type for aggregation: [10.0, 4.0, 12.0, 9.0, 8.0, 17.0, 9.0, 3.0, 10.0]"
            },
            {
                "generated rasp code": "def shift_by(offset: int, sop: rasp.SOp, fill: rasp.Value) -> rasp.SOp:\n    \"\"\"Returns the sop, shifted by `offset`, filled with `fill` value.\"\"\"\n    select_off_by_offset = rasp.Select(rasp.indices, rasp.indices,\n                                       lambda k, q: q == k + offset)\n    out = rasp.Aggregate(select_off_by_offset, sop, default=fill)\n    return out.named(f\"shift_by({offset})\")\n\ndef make_pairwise_sum() -> rasp.SOp:\n    # Shift the sequence by 1 to the right, filling with 0\n    shifted_sequence = shift_by(1, rasp.tokens, fill=0).named(\"shifted_sequence\")\n\n    # Add the original sequence and the shifted sequence element-wise\n    sum_sequence = rasp.SequenceMap(lambda x, y: x + y, rasp.tokens, shifted_sequence).named(\"sum_sequence\")\n\n    # Create a selector for the first element\n    first_element_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == 0).named(\"first_element_selector\")\n\n    # Replace the first element of the sum sequence with the original first element\n    result = rasp.Aggregate(first_element_selector, rasp.tokens, default=None).named(\"first_element\")\n    \n    # Combine the original first element with the rest of the sum sequence\n    final_result = rasp.SequenceMap(lambda x, y: x if x is not None else y, result, sum_sequence).named(\"final_result\")\n\n    return final_result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3.0, 3.0, 3.0, 3.0, 3.0, 3.0]. (0.884 error rate)"
            }
        ],
        "make_polynomial": [
            {
                "generated rasp code": "def make_polynomial() -> rasp.SOp:\n    # Extract x (the first element of the input sequence)\n    x_selector = rasp.Select(rasp.indices, rasp.indices, lambda i, j: i == 0).named(\"x_selector\")\n    x = rasp.Aggregate(x_selector, rasp.tokens).named(\"x\")\n\n    # Create a sequence of indices (0, 1, 2, ...)\n    indices = rasp.indices.named(\"indices\")\n\n    # Create a sequence of powers of x (1, x, x^2, x^3, ...)\n    powers_of_x = rasp.SequenceMap(lambda i, x: x ** i, indices, x).named(\"powers_of_x\")\n\n    # Extract coefficients (all elements except the first one)\n    coeff_selector = rasp.Select(rasp.indices, rasp.indices, lambda i, j: i > 0).named(\"coeff_selector\")\n    coefficients = rasp.Aggregate(coeff_selector, rasp.tokens).named(\"coefficients\")\n\n    # Multiply powers of x with coefficients\n    terms = rasp.SequenceMap(lambda pow_x, coeff: pow_x * coeff, powers_of_x, coefficients).named(\"terms\")\n\n    # Sum up all terms\n    all_selector = rasp.Select(rasp.tokens, rasp.tokens, lambda i, j: True).named(\"all_selector\")\n    result = rasp.Aggregate(all_selector, terms).named(\"result\")\n\n    return result",
                "failure stage": 1,
                "error": "Unsupported type for aggregation: [4.0, 8.0, 16.0, 32.0, 64.0, 128.0, 256.0, 512.0, 1024.0, 2048.0, 4096.0, 8192.0]"
            },
            {
                "generated rasp code": "def make_polynomial() -> rasp.SOp:\n    # Extract x (the first element)\n    x_selector = rasp.Select(rasp.indices, rasp.indices, lambda i, j: i == 0).named(\"x_selector\")\n    x = rasp.Aggregate(x_selector, rasp.tokens).named(\"x\")\n\n    # Create a sequence of indices starting from 0\n    indices = rasp.indices.named(\"indices\")\n\n    # Create a sequence of powers of x: [1, x, x^2, x^3, ...]\n    powers = rasp.Map(lambda i: x ** i, indices).named(\"powers\")\n\n    # Create a selector for all elements except the first one (coefficients)\n    coef_selector = rasp.Select(rasp.indices, rasp.indices, lambda i, j: i > 0).named(\"coef_selector\")\n    \n    # Extract coefficients\n    coefficients = rasp.Aggregate(coef_selector, rasp.tokens, default=0).named(\"coefficients\")\n\n    # Multiply powers with coefficients\n    terms = rasp.SequenceMap(lambda p, c: p * c, powers, coefficients).named(\"terms\")\n\n    # Sum up all terms\n    sum_selector = rasp.Select(rasp.tokens, rasp.tokens, lambda x, y: True).named(\"sum_selector\")\n    result = rasp.Aggregate(sum_selector, terms).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_polynomial() -> rasp.SOp:\n    # Extract x (the first element)\n    x_selector = rasp.Select(rasp.indices, rasp.indices, lambda i, j: i == 0).named(\"x_selector\")\n    x = rasp.Aggregate(x_selector, rasp.tokens).named(\"x\")\n\n    # Create a sequence of indices starting from 0\n    indices = rasp.indices.named(\"indices\")\n\n    # Create a sequence of powers of x: [1, x, x^2, x^3, ...]\n    powers = rasp.SequenceMap(lambda i, x: x ** i, indices, x).named(\"powers\")\n\n    # Create a selector for coefficients (all elements except the first)\n    coeff_selector = rasp.Select(rasp.indices, rasp.indices, lambda i, j: i > 0).named(\"coeff_selector\")\n    \n    # Extract coefficients\n    coefficients = rasp.Aggregate(coeff_selector, rasp.tokens, default=0).named(\"coefficients\")\n\n    # Multiply powers with coefficients\n    terms = rasp.SequenceMap(lambda p, c: p * c, powers, coefficients).named(\"terms\")\n\n    # Sum up all terms\n    sum_selector = rasp.Select(rasp.tokens, rasp.tokens, lambda x, y: True).named(\"sum_selector\")\n    result = rasp.Aggregate(sum_selector, terms).named(\"result\")\n\n    return result",
                "failure stage": 1,
                "error": "Unsupported type for aggregation: [4.0, 8.0, 16.0, 32.0, 64.0, 128.0, 256.0, 512.0, 1024.0, 2048.0, 4096.0, 8192.0]"
            },
            {
                "generated rasp code": "def make_polynomial() -> rasp.SOp:\n    # Extract x (first element)\n    x_selector = rasp.Select(rasp.indices, rasp.indices, lambda i, j: i == 0).named(\"x_selector\")\n    x = rasp.Aggregate(x_selector, rasp.tokens, default=None).named(\"x\")\n\n    # Create a sequence of indices starting from 0\n    indices = rasp.indices.named(\"indices\")\n\n    # Create a sequence of powers of x: [1, x, x^2, x^3, ...]\n    powers_of_x = rasp.SequenceMap(lambda i, x: x**i, indices, x).named(\"powers_of_x\")\n\n    # Create a selector for coefficients (all elements except the first)\n    coef_selector = rasp.Select(rasp.indices, rasp.indices, lambda i, j: i > 0).named(\"coef_selector\")\n\n    # Extract coefficients\n    coefficients = rasp.Aggregate(coef_selector, rasp.tokens, default=None).named(\"coefficients\")\n\n    # Multiply coefficients by corresponding powers of x\n    terms = rasp.SequenceMap(lambda coef, power: coef * power, coefficients, powers_of_x).named(\"terms\")\n\n    # Sum up the terms cumulatively\n    def cumulative_sum(sop: rasp.SOp) -> rasp.SOp:\n        return rasp.SequenceMap(lambda x, y: x + y, sop, shift_by(1, sop, 0))\n\n    result = terms\n    for _ in range(len(rasp.tokens) - 1):  # Apply cumulative sum for each term\n        result = cumulative_sum(result)\n\n    # Create a selector for the last element\n    last_selector = rasp.Select(rasp.indices, make_length() - 1, rasp.Comparison.EQ).named(\"last_selector\")\n\n    # Extract the final sum\n    final_sum = rasp.Aggregate(last_selector, result, default=None).named(\"final_sum\")\n\n    # Broadcast the final sum to a sequence of the same length as the input\n    return rasp.Map(lambda x: x, final_sum).named(\"polynomial_result\")\n\ndef make_length() -> rasp.SOp:\n    \"\"\"Creates the `length` SOp using selector width primitive.\"\"\"\n    all_true_selector = rasp.Select(\n        rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\ndef shift_by(offset: int, sop: rasp.SOp, fill: rasp.Value) -> rasp.SOp:\n    \"\"\"Returns the sop, shifted by `offset`, filled with `fill` value.\"\"\"\n    select_off_by_offset = rasp.Select(rasp.indices, rasp.indices,\n                                       lambda k, q: q == k + offset)\n    out = rasp.Aggregate(select_off_by_offset, sop, default=None)\n    return out.named(f\"shift_by({offset})\")",
                "failure stage": 0,
                "error": "object of type 'TokensType' has no len()"
            },
            {
                "generated rasp code": "def make_polynomial() -> rasp.SOp:\n    # Extract x (the first element of the sequence)\n    x_selector = rasp.Select(rasp.indices, rasp.tokens, lambda i, _: i == 0).named(\"x_selector\")\n    x = rasp.Aggregate(x_selector, rasp.tokens).named(\"x\")\n\n    # Create a sequence of indices starting from 0\n    indices = rasp.indices.named(\"indices\")\n\n    # Calculate x^i for each index i\n    powers_of_x = rasp.SequenceMap(lambda i, x: x ** i, indices, x).named(\"powers_of_x\")\n\n    # Multiply each power of x with its corresponding coefficient\n    terms = rasp.SequenceMap(lambda power, coeff: power * coeff, powers_of_x, rasp.tokens).named(\"terms\")\n\n    # Sum up all the terms\n    all_selector = rasp.Select(rasp.tokens, rasp.tokens, lambda _, __: True).named(\"all_selector\")\n    result = rasp.Aggregate(all_selector, terms).named(\"result\")\n\n    return result",
                "failure stage": 1,
                "error": "Unsupported type for aggregation: [2.0, 0.0, 16.0, 40.0, 96.0, 64.0, 384.0, 512.0, 0.0, 512.0, 7168.0, 18432.0]"
            }
        ],
        "make_flip_halves": [
            {
                "generated rasp code": "def make_flip_halves() -> rasp.SOp:\n    # Calculate the length of the sequence\n    all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    length = rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n    # Calculate the midpoint (floor division by 2)\n    midpoint = rasp.Map(lambda x: x // 2, length).named(\"midpoint\")\n\n    # Create a selector for the first half of the sequence\n    first_half_selector = rasp.Select(rasp.indices, midpoint, rasp.Comparison.LT).named(\"first_half_selector\")\n\n    # Create a selector for the second half of the sequence (including the middle element for odd-length sequences)\n    second_half_selector = rasp.Select(rasp.indices, midpoint, rasp.Comparison.GEQ).named(\"second_half_selector\")\n\n    # Calculate the new positions for the elements\n    new_pos_first_half = rasp.SequenceMap(lambda x, y: x + y, midpoint, rasp.indices).named(\"new_pos_first_half\")\n    new_pos_second_half = rasp.SequenceMap(lambda x, y: y - x, midpoint, rasp.indices).named(\"new_pos_second_half\")\n\n    # Create selectors for the new positions\n    new_pos_first_half_selector = rasp.Select(rasp.indices, new_pos_first_half, rasp.Comparison.EQ).named(\"new_pos_first_half_selector\")\n    new_pos_second_half_selector = rasp.Select(rasp.indices, new_pos_second_half, rasp.Comparison.EQ).named(\"new_pos_second_half_selector\")\n\n    # Rearrange the sequence\n    first_half_rearranged = rasp.Aggregate(new_pos_first_half_selector, rasp.Aggregate(first_half_selector, rasp.tokens)).named(\"first_half_rearranged\")\n    second_half_rearranged = rasp.Aggregate(new_pos_second_half_selector, rasp.Aggregate(second_half_selector, rasp.tokens)).named(\"second_half_rearranged\")\n\n    # Combine the rearranged halves\n    flipped_sequence = rasp.SequenceMap(lambda x, y: x if x is not None else y, second_half_rearranged, first_half_rearranged).named(\"flipped_sequence\")\n\n    return flipped_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, None, None, None, None, None]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_flip_halves() -> rasp.SOp:\n    # Calculate the length of the sequence\n    all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    length = rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n    # Calculate the midpoint (floor division by 2)\n    midpoint = rasp.Map(lambda x: x // 2, length).named(\"midpoint\")\n\n    # Create a selector for the first half of the sequence\n    first_half_selector = rasp.Select(rasp.indices, midpoint, rasp.Comparison.LT).named(\"first_half_selector\")\n\n    # Create a selector for the second half of the sequence (including middle element for odd-length sequences)\n    second_half_selector = rasp.Select(rasp.indices, midpoint, rasp.Comparison.GEQ).named(\"second_half_selector\")\n\n    # Calculate the offset for repositioning elements\n    offset = rasp.Map(lambda x: x // 2 + x % 2, length).named(\"offset\")\n\n    # Reposition the second half to the first half positions\n    second_half_first = rasp.Aggregate(\n        rasp.Select(rasp.indices, rasp.SequenceMap(lambda x, y: x - y, rasp.indices, offset), rasp.Comparison.EQ),\n        rasp.Aggregate(second_half_selector, rasp.tokens)\n    ).named(\"second_half_first\")\n\n    # Reposition the first half to the second half positions\n    first_half_second = rasp.Aggregate(\n        rasp.Select(rasp.indices, rasp.SequenceMap(lambda x, y: x + y, rasp.indices, offset), rasp.Comparison.EQ),\n        rasp.Aggregate(first_half_selector, rasp.tokens)\n    ).named(\"first_half_second\")\n\n    # Combine the repositioned halves\n    flipped_sequence = rasp.SequenceMap(\n        lambda x, y: x if x is not None else y,\n        second_half_first,\n        first_half_second\n    ).named(\"flipped_sequence\")\n\n    return flipped_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, None, None, None, None, None]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_length() -> rasp.SOp:\n    \"\"\"Creates an SOp that returns the length of the input sequence for each position.\"\"\"\n    all_true_selector = rasp.Select(\n        rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\ndef make_flip_halves() -> rasp.SOp:\n    \"\"\"\n    Creates an SOp that flips the order of the first and second half of the sequence.\n    For odd-length sequences, it divides them into [first half of size n, second half of size n+1].\n    \"\"\"\n    # Get the length of the sequence\n    length = make_length()\n\n    # Calculate the midpoint (for both even and odd lengths)\n    midpoint = rasp.Map(lambda x: (x + 1) // 2, length).named(\"midpoint\")\n\n    # Create selectors for the first and second halves\n    first_half_selector = rasp.Select(rasp.indices, midpoint, rasp.Comparison.LT).named(\"first_half_selector\")\n    second_half_selector = rasp.Select(rasp.indices, midpoint, rasp.Comparison.GEQ).named(\"second_half_selector\")\n\n    # Move the second half to the first half positions\n    second_half_to_first = rasp.Aggregate(first_half_selector, \n                                          rasp.Aggregate(second_half_selector, rasp.tokens)).named(\"second_half_to_first\")\n\n    # Move the first half to the second half positions\n    first_half_to_second = rasp.Aggregate(second_half_selector, \n                                          rasp.Aggregate(first_half_selector, rasp.tokens)).named(\"first_half_to_second\")\n\n    # Combine the two halves\n    return rasp.SequenceMap(\n        lambda x, y: x if x is not None else y,\n        second_half_to_first,\n        first_half_to_second\n    ).named(\"flipped_halves\")",
                "failure stage": 1,
                "error": "Unsupported type for aggregation: [6.75, 6.75, 6.75, 6.75]"
            },
            {
                "generated rasp code": "def make_flip_halves() -> rasp.SOp:\n    # Calculate the length of the sequence\n    all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    length = rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n    # Calculate the midpoint (floored division for odd-length sequences)\n    midpoint = rasp.Map(lambda x: x // 2, length).named(\"midpoint\")\n\n    # Create selectors for the first and second halves\n    first_half_selector = rasp.Select(rasp.indices, midpoint, rasp.Comparison.LT).named(\"first_half_selector\")\n    second_half_selector = rasp.Select(rasp.indices, midpoint, rasp.Comparison.GEQ).named(\"second_half_selector\")\n\n    # Select the second half (including the middle element for odd-length sequences)\n    second_half = rasp.Aggregate(second_half_selector, rasp.tokens).named(\"second_half\")\n\n    # Select the first half\n    first_half = rasp.Aggregate(first_half_selector, rasp.tokens).named(\"first_half\")\n\n    # Combine the flipped halves\n    flipped_sequence = rasp.SequenceMap(\n        lambda x, y: x if x is not None else y,\n        second_half,\n        first_half\n    ).named(\"flipped_sequence\")\n\n    return flipped_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335]. (0.985 error rate)"
            },
            {
                "generated rasp code": "def make_flip_halves() -> rasp.SOp:\n    # Calculate the length of the sequence\n    def make_length() -> rasp.SOp:\n        all_true_selector = rasp.Select(\n            rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n        return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n    length = make_length()\n\n    # Calculate the midpoint (floor division by 2)\n    midpoint = rasp.Map(lambda x: x // 2, length).named(\"midpoint\")\n\n    # Create selectors for the first and second halves\n    first_half_selector = rasp.Select(rasp.indices, midpoint, rasp.Comparison.LT).named(\"first_half_selector\")\n    second_half_selector = rasp.Select(rasp.indices, midpoint, rasp.Comparison.GEQ).named(\"second_half_selector\")\n\n    # Move the second half to the first half positions\n    first_half_flipped = rasp.Aggregate(first_half_selector, rasp.tokens).named(\"first_half_flipped\")\n\n    # Move the first half to the second half positions\n    second_half_flipped = rasp.Aggregate(second_half_selector, rasp.tokens).named(\"second_half_flipped\")\n\n    # Combine the flipped halves\n    flipped_sequence = rasp.SequenceMap(\n        lambda x, y: y if x is None else x,\n        first_half_flipped,\n        second_half_flipped\n    ).named(\"flipped_sequence\")\n\n    return flipped_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [4.333333333333333, 4.333333333333333, 4.333333333333333, 4.333333333333333, 4.333333333333333, 4.333333333333333]. (0.985 error rate)"
            }
        ],
        "make_arcsine": [
            {
                "generated rasp code": "def make_arcsine() -> rasp.SOp:\n    # Define pi constant\n    pi = 3.141592653589793\n\n    # Define our own asin function using Taylor series approximation\n    def asin(x):\n        if x < -1 or x > 1:\n            return float('nan')\n        # Taylor series approximation of asin\n        a = x\n        b = x**3 / 6\n        c = 3 * x**5 / 40\n        d = 5 * x**7 / 112\n        return a + b + c + d\n\n    # Function to convert radians to multiples of pi\n    def to_pi_multiple(x):\n        if x == 0:\n            return 0\n        elif x == pi/2:\n            return 0.5\n        elif x == -pi/2:\n            return -0.5\n        elif x == pi/6:\n            return 1/6\n        elif x == -pi/6:\n            return -1/6\n        else:\n            return x / pi\n\n    # Apply arcsine function to each element\n    return rasp.Map(\n        lambda x: to_pi_multiple(asin(max(min(x, 1), -1))),\n        rasp.tokens\n    ).named(\"arcsine\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0.4094450381209355, 0.4094450381209355, 0.4094450381209355, 0.4094450381209355, 0.4094450381209355, 0.4094450381209355]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_arcsine() -> rasp.SOp:\n    # Define pi constant\n    pi = 3.141592653589793\n\n    def custom_asin(x):\n        # Taylor series approximation of asin\n        # This works well for small x, we'll use it as a building block\n        return x + (x**3)/6 + (3*x**5)/40 + (5*x**7)/112 + (35*x**9)/1152 + (63*x**11)/2816\n\n    def safe_asin(x):\n        # Handle the full range [-1, 1] and convert to multiples of pi\n        # Use mathematical identities to avoid conditionals\n        # asin(x) = pi/2 - asin(sqrt(1-x^2)) for x in [0, 1]\n        # asin(-x) = -asin(x)\n        sign = (x >= 0) * 2 - 1  # 1 if x >= 0, -1 if x < 0\n        x_abs = abs(x)\n        y = (pi/2 - custom_asin((1 - x_abs * x_abs)**0.5)) * (x_abs <= 1)\n        return sign * y / (pi/2)  # Normalize to [-1, 1] range\n\n    return rasp.Map(safe_asin, rasp.tokens).named(\"arcsine\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0j, 0j, 0j, 1.0, 0j, 0j]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_arcsine() -> rasp.SOp:\n    # Define pi constant\n    PI = 3.141592653589793\n\n    def arcsine_approx(x):\n        # Check if x is within the valid domain [-1, 1]\n        if x < -1 or x > 1:\n            return None\n\n        # Special cases\n        if x == -1:\n            return -PI / 2\n        if x == 1:\n            return PI / 2\n        if x == 0:\n            return 0\n\n        # Taylor series approximation for arcsine\n        result = x\n        term = x\n        x_squared = x * x\n        for n in range(1, 10):  # Limit to 10 terms for efficiency\n            term *= x_squared * (2*n - 1)**2 / ((2*n + 1) * 2*n)\n            result += term\n\n        return result\n\n    # Apply the arcsine approximation to each element\n    return rasp.Map(arcsine_approx, rasp.tokens).named(\"arcsine\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, None, None, 1.5707963267948966, None, None]. (0.917 error rate)"
            },
            {
                "generated rasp code": "def make_arcsine() -> rasp.SOp:\n    # Approximate value of \u03c0\n    PI = 3.14159265358979323846\n\n    def arcsine_approx(x):\n        # Handle edge cases\n        if x == -1:\n            return -PI / 2\n        elif x == 0:\n            return 0\n        elif x == 1:\n            return PI / 2\n        \n        # Taylor series approximation for arcsine\n        result = x\n        term = x\n        n = 1\n        while n < 10:  # Adjust the number of terms for better accuracy\n            term *= x * x * (2 * n - 1) * (2 * n - 1) / (2 * n * (2 * n + 1))\n            result += term\n            n += 1\n        \n        return result\n\n    # Apply the arcsine approximation to each element\n    return rasp.Map(lambda x: arcsine_approx(x), rasp.tokens).named(\"arcsine\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [13070074.745632436, 1433309616719671.5, 7304.587586476131, 1.5707963267948966, 195449761816.03787, 2897971008.108506]. (0.917 error rate)"
            },
            {
                "generated rasp code": "def make_arcsine() -> rasp.SOp:\n    def arcsine_approx(x):\n        # Check if x is within the valid domain\n        if x < -1 or x > 1:\n            return None\n        \n        # Taylor series approximation of arcsine\n        # asin(x) \u2248 x + (1/6)x^3 + (3/40)x^5 + (5/112)x^7 + ...\n        x2 = x * x\n        x3 = x2 * x\n        x5 = x3 * x2\n        x7 = x5 * x2\n        \n        return x + (1/6)*x3 + (3/40)*x5 + (5/112)*x7\n\n    return rasp.Map(lambda x: arcsine_approx(x), rasp.tokens).named(\"arcsine\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, None, None, 1.286309523809524, None, None]. (0.979 error rate)"
            }
        ],
        "make_check_divisibility": [],
        "make_arccosine": [
            {
                "generated rasp code": "def make_arccosine() -> rasp.SOp:\n    def custom_acos(x):\n        # Handle out-of-domain inputs\n        if x < -1 or x > 1:\n            return None\n        \n        # Special cases\n        if x == 1:\n            return 0\n        if x == -1:\n            return 3.141592653589793  # \u03c0\n        if x == 0:\n            return 1.5707963267948966  # \u03c0/2\n\n        # Taylor series approximation for arccosine\n        result = 1.5707963267948966  # \u03c0/2\n        term = x\n        n = 1\n        while abs(term) > 1e-10:  # Adjust precision as needed\n            result -= term / (2 * n - 1)\n            n += 1\n            term *= x * x * (2 * n - 3) / (2 * n - 2)\n\n        return result\n\n    # Apply the custom arccosine function to each element of the input sequence\n    return rasp.Map(lambda x: custom_acos(x), rasp.tokens).named(\"arccosine\")",
                "failure stage": 4,
                "error": "('Inputs {0.723102771013545, 0.5020895776770055} not found in encoding ', dict_keys([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 'BOS', 'compiler_pad']))"
            },
            {
                "generated rasp code": "def make_arccosine() -> rasp.SOp:\n    def make_sqrt() -> rasp.SOp:\n        \"\"\"Approximates the square root using Newton's method.\"\"\"\n        def newton_iteration(x, n):\n            return 0.5 * (x + n / x)\n\n        iterations = 5  # Number of iterations for Newton's method\n        sqrt_approx = rasp.tokens\n        for _ in range(iterations):\n            sqrt_approx = rasp.Map(lambda x: newton_iteration(x, 1) if x > 0 else 0, sqrt_approx)\n        \n        return sqrt_approx\n\n    def make_power_series(n: int) -> rasp.SOp:\n        \"\"\"Creates a power series approximation up to n terms.\"\"\"\n        def factorial(k):\n            if k == 0 or k == 1:\n                return 1\n            return k * factorial(k - 1)\n\n        def term(x, k):\n            numerator = factorial(2 * k) * x ** (2 * k + 1)\n            denominator = 4 ** k * (factorial(k) ** 2) * (2 * k + 1)\n            return numerator / denominator\n\n        power_series = rasp.tokens  # x\n        for k in range(1, n):\n            power_series = rasp.SequenceMap(\n                lambda x, y: x + term(y, k),\n                power_series,\n                rasp.tokens\n            )\n        \n        return power_series\n\n    def arccosine_approx(x):\n        if x < -1 or x > 1:\n            return None\n        if x == 1:\n            return 0\n        if x == -1:\n            return 3.141592653589793  # Approximation of \u03c0\n        \n        # Arccosine approximation using the formula: arccos(x) = \u03c0/2 - arcsin(x)\n        # We use the Taylor series for arcsin(x)\n        sqrt_approx = make_sqrt()\n        arcsin_approx = make_power_series(5)  # Using 5 terms for approximation\n        \n        y = rasp.SequenceMap(lambda s, a: 1.570796326794897 - a,  # \u03c0/2 - arcsin(x)\n                             sqrt_approx,\n                             arcsin_approx)\n        \n        return y\n\n    return rasp.Map(arccosine_approx, rasp.tokens).named(\"arccosine\")",
                "failure stage": 3,
                "error": "unhashable type: 'SequenceMap'"
            },
            {
                "generated rasp code": "def make_arccosine() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP SOp that applies an approximation of the arccosine function to each element of the input sequence.\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that approximates arccosine for each input element.\n    \"\"\"\n    \n    def arccosine_approx(x):\n        # Handle domain errors\n        if x < -1 or x > 1:\n            return None\n        # Handle edge cases\n        if x == 1:\n            return 0\n        if x == -1:\n            return 3.141592653589793  # Approximation of pi\n        \n        # Approximation using a polynomial expansion\n        # This is a simple approximation and may not be very accurate for all inputs\n        return 1.5707963267948966 - x - x**3/6 - 3*x**5/40 - 5*x**7/112\n    \n    return rasp.Map(lambda x: arccosine_approx(x), rasp.tokens).named(\"arccosine\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, None, None, 0, None, None]. (0.989 error rate)"
            },
            {
                "generated rasp code": "def make_arccosine() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP SOp that applies an approximate arccosine function to each element of the input sequence.\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that approximates arccosine for each element.\n    \"\"\"\n    \n    def approx_acos(x):\n        \"\"\"\n        Approximates arccosine using the formula: acos(x) \u2248 \u03c0/2 - x - x^3/6\n        This is a simple approximation and is not accurate for all inputs,\n        but serves to demonstrate the concept without using external libraries.\n        \"\"\"\n        if x < -1 or x > 1:\n            return None  # Return None for inputs outside the valid domain\n        pi = 3.14159265358979323846  # Approximation of pi\n        return pi/2 - x - (x**3)/6\n\n    return rasp.Map(lambda x: approx_acos(x), rasp.tokens).named(\"arccosine\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, None, None, 0.40412966012822993, None, None]. (0.999 error rate)"
            },
            {
                "generated rasp code": "def make_arccosine() -> rasp.SOp:\n    def arccosine_approx(x):\n        if x < -1 or x > 1:\n            return None\n        \n        # Taylor series approximation of arccosine\n        a0 = 1.5707963267948966  # \u03c0/2\n        a1 = -1.0\n        a2 = -0.1666666666666667\n        a3 = -0.0750000000000000\n        a4 = -0.0446428571428571\n        \n        x2 = x * x\n        return a0 + x * (a1 + x2 * (a2 + x2 * (a3 + x2 * a4)))\n\n    return rasp.Map(arccosine_approx, rasp.tokens).named(\"arccosine\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, None, None, 0.28448680298537266, None, None]. (0.989 error rate)"
            }
        ],
        "make_check_all_equal": [
            {
                "generated rasp code": "def make_check_all_equal() -> rasp.SOp:\n    # Create a selector that compares each element with every other element\n    eq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.EQ).named(\"eq_selector\")\n\n    # Count the number of elements each element is equal to\n    eq_count = rasp.SelectorWidth(eq_selector).named(\"eq_count\")\n\n    # Create a sequence of the length of the input sequence\n    sequence_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"sequence_length\")\n\n    # Compare the count with the length\n    all_equal = rasp.SequenceMap(lambda count, length: count == length, eq_count, sequence_length).named(\"all_equal\")\n\n    # Check if all elements are True (1)\n    all_true = rasp.Aggregate(\n        rasp.Select(all_equal, all_equal, rasp.Comparison.EQ),\n        rasp.Map(lambda x: 1, rasp.tokens),\n        default=None\n    ).named(\"all_true\")\n\n    # Map the result to 1 if all elements are equal, 0 otherwise\n    result = rasp.Map(lambda x: 1 if x == 1 else 0, all_true).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": "test_run_op timed out"
            }
        ],
        "make_position": [
            {
                "generated rasp code": "def make_position() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that replaces each element with its position in the sequence.\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that, when applied to a sequence, \n              returns a new sequence where each element is replaced by its 1-based position.\n    \n    Example:\n    position = make_position()\n    position([10, 20, 30]) # returns [1, 2, 3]\n    \"\"\"\n    # Use rasp.indices to get the 0-based index of each element\n    # Then use rasp.Map to add 1 to each index, converting to 1-based indexing\n    return rasp.Map(lambda x: x + 1, rasp.indices).named(\"position\")",
                "failure stage": 3,
                "error": "'tokens'"
            },
            {
                "generated rasp code": "def make_position() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that replaces each element with its position in the sequence.\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that, when applied to a sequence, \n              returns a new sequence where each element is replaced by its position (starting from 1).\n    \n    Example:\n    position = make_position()\n    position([10, 20, 30]) # returns [1, 2, 3]\n    \"\"\"\n    \n    # Use rasp.indices to get the zero-based index of each element\n    # Then use rasp.Map to add 1 to each index, converting to 1-based indexing\n    return rasp.Map(lambda x: x + 1, rasp.indices).named(\"position\")",
                "failure stage": 3,
                "error": "'tokens'"
            },
            {
                "generated rasp code": "def make_position() -> rasp.SOp:\n    # Use rasp.indices to get the zero-based index of each element\n    indices = rasp.indices.named(\"indices\")\n    \n    # Use rasp.Map to add 1 to each index, converting to one-based indexing\n    positions = rasp.Map(lambda x: x + 1, indices).named(\"positions\")\n    \n    return positions",
                "failure stage": 3,
                "error": "Expression indices cannot be translated to a model component."
            },
            {
                "generated rasp code": "def make_position() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that replaces each element with its position in the sequence.\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that, when applied to a sequence,\n              returns a new sequence where each element is replaced by its position (starting from 1).\n    \n    Example:\n    position = make_position()\n    position([10, 20, 30]) # returns [1, 2, 3]\n    \"\"\"\n    # Use rasp.indices to get the position of each element (0-based index)\n    # Then use rasp.Map to add 1 to each index, making it 1-based\n    return rasp.Map(lambda x: x + 1, rasp.indices).named(\"position\")",
                "failure stage": 3,
                "error": "'tokens'"
            },
            {
                "generated rasp code": "def make_position() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that replaces each element with its position in the sequence.\n    The positions start from 1.\n\n    Returns:\n    rasp.SOp: A RASP operation that transforms a sequence into a sequence of positions.\n\n    Example:\n    position = make_position()\n    position([10, 20, 30]) # returns [1, 2, 3]\n    \"\"\"\n    # Get the indices of each element in the sequence\n    indices = rasp.indices\n\n    # Add 1 to each index to get the position (1-based indexing)\n    positions = rasp.Map(lambda x: x + 1, indices).named(\"positions\")\n\n    return positions",
                "failure stage": 3,
                "error": "'tokens'"
            }
        ],
        "make_set_to_median": [
            {
                "generated rasp code": "def make_length() -> rasp.SOp:\n    \"\"\"Returns the length of the input sequence.\"\"\"\n    all_true_selector = rasp.Select(\n        rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\ndef make_sort(max_seq_len: int = 100, min_val: float = 0) -> rasp.SOp:\n    \"\"\"Returns a sorted version of the input sequence.\"\"\"\n    keys = rasp.SequenceMap(lambda x, i: x + min_val * i / max_seq_len, rasp.tokens, rasp.indices)\n    smaller = rasp.Select(keys, keys, rasp.Comparison.LT).named(\"smaller\")\n    target_pos = rasp.SelectorWidth(smaller).named(\"target_pos\")\n    sel_new = rasp.Select(target_pos, rasp.indices, rasp.Comparison.EQ)\n    return rasp.Aggregate(sel_new, rasp.tokens).named(\"sort\")\n\ndef make_set_to_median() -> rasp.SOp:\n    \"\"\"Replaces each element with the median of all elements.\"\"\"\n    # Sort the input sequence\n    sorted_seq = make_sort().named(\"sorted_seq\")\n    \n    # Get the length of the sequence\n    length = make_length().named(\"length\")\n    \n    # Calculate the middle index (for odd lengths) or indices (for even lengths)\n    middle_index = rasp.Map(lambda x: (x - 1) // 2, length).named(\"middle_index\")\n    next_index = rasp.Map(lambda x: x // 2, length).named(\"next_index\")\n    \n    # Select the middle element(s)\n    middle_selector = rasp.Select(middle_index, rasp.indices, rasp.Comparison.EQ).named(\"middle_selector\")\n    next_selector = rasp.Select(next_index, rasp.indices, rasp.Comparison.EQ).named(\"next_selector\")\n    \n    middle_element = rasp.Aggregate(middle_selector, sorted_seq).named(\"middle_element\")\n    next_element = rasp.Aggregate(next_selector, sorted_seq).named(\"next_element\")\n    \n    # Calculate the average of the two middle elements (this will be the same as the middle element for odd lengths)\n    median = rasp.SequenceMap(lambda x, y: (x + y) / 2, middle_element, next_element).named(\"median\")\n    \n    # Broadcast the median value across the entire sequence\n    all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    return rasp.Aggregate(all_true_selector, median).named(\"set_to_median\")",
                "failure stage": 1,
                "error": "Unsupported type for aggregation: [0.0, 1.0, 2.0, 5.0, None, 7.0]"
            },
            {
                "generated rasp code": "def make_length() -> rasp.SOp:\n    \"\"\"Returns the length of the input sequence.\"\"\"\n    all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\ndef make_sort(max_seq_len: int = 100, min_key: float = 0) -> rasp.SOp:\n    \"\"\"Returns a sorted version of the input sequence.\"\"\"\n    keys = rasp.SequenceMap(lambda x, i: x + min_key * i / max_seq_len, rasp.tokens, rasp.indices)\n    smaller = rasp.Select(keys, keys, rasp.Comparison.LT).named(\"smaller\")\n    target_pos = rasp.SelectorWidth(smaller).named(\"target_pos\")\n    sel_new = rasp.Select(target_pos, rasp.indices, rasp.Comparison.EQ)\n    return rasp.Aggregate(sel_new, rasp.tokens).named(\"sort\")\n\ndef make_set_to_median() -> rasp.SOp:\n    \"\"\"Replaces each element with the median of all elements.\"\"\"\n    \n    # Sort the input sequence\n    sorted_seq = make_sort().named(\"sorted_seq\")\n    \n    # Get the length of the sequence\n    length = make_length().named(\"length\")\n    \n    # Calculate the index of the middle element(s)\n    mid_index = rasp.Map(lambda x: (x - 1) / 2, length).named(\"mid_index\")\n    \n    # Select the middle element (for odd-length sequences)\n    odd_median_selector = rasp.Select(rasp.indices, mid_index, rasp.Comparison.EQ).named(\"odd_median_selector\")\n    odd_median = rasp.Aggregate(odd_median_selector, sorted_seq).named(\"odd_median\")\n    \n    # Select the two middle elements (for even-length sequences)\n    lower_mid_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: x - 0.5, mid_index), rasp.Comparison.EQ).named(\"lower_mid_selector\")\n    upper_mid_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: x + 0.5, mid_index), rasp.Comparison.EQ).named(\"upper_mid_selector\")\n    lower_mid = rasp.Aggregate(lower_mid_selector, sorted_seq).named(\"lower_mid\")\n    upper_mid = rasp.Aggregate(upper_mid_selector, sorted_seq).named(\"upper_mid\")\n    \n    # Calculate the average of the two middle elements\n    even_median = rasp.SequenceMap(lambda x, y: (x + y) / 2, lower_mid, upper_mid).named(\"even_median\")\n    \n    # Determine if the length is odd or even\n    is_odd = rasp.Map(lambda x: x % 2, length).named(\"is_odd\")\n    \n    # Choose between odd and even median based on sequence length\n    median = rasp.SequenceMap(lambda x, y, z: y if x else z, is_odd, odd_median, even_median).named(\"median\")\n    \n    # Broadcast the median to all positions\n    return rasp.Map(lambda x: x, median).named(\"set_to_median\")",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            },
            {
                "generated rasp code": "def make_length() -> rasp.SOp:\n    \"\"\"Creates an SOp that returns the length of the input sequence for each element.\"\"\"\n    all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\ndef make_sort(max_seq_len: int = 100, min_val: float = 0) -> rasp.SOp:\n    \"\"\"Creates an SOp that sorts the input sequence.\"\"\"\n    keys = rasp.SequenceMap(lambda x, i: x + min_val * i / max_seq_len, rasp.tokens, rasp.indices)\n    smaller = rasp.Select(keys, keys, rasp.Comparison.LT).named(\"smaller\")\n    target_pos = rasp.SelectorWidth(smaller).named(\"target_pos\")\n    sel_new = rasp.Select(target_pos, rasp.indices, rasp.Comparison.EQ)\n    return rasp.Aggregate(sel_new, rasp.tokens).named(\"sort\")\n\ndef make_set_to_median() -> rasp.SOp:\n    \"\"\"Creates an SOp that replaces each element with the median of all elements.\"\"\"\n    # Sort the input sequence\n    sorted_seq = make_sort().named(\"sorted_seq\")\n    \n    # Get the length of the sequence\n    length = make_length().named(\"length\")\n    \n    # Calculate the middle index (for both odd and even lengths)\n    middle_index = rasp.Map(lambda x: (x - 1) // 2, length).named(\"middle_index\")\n    \n    # Select the middle element(s)\n    middle_selector = rasp.Select(rasp.indices, middle_index, rasp.Comparison.EQ).named(\"middle_selector\")\n    lower_middle = rasp.Aggregate(middle_selector, sorted_seq).named(\"lower_middle\")\n    \n    # For even lengths, we need the upper middle element too\n    upper_middle_index = rasp.Map(lambda x: x // 2, length).named(\"upper_middle_index\")\n    upper_middle_selector = rasp.Select(rasp.indices, upper_middle_index, rasp.Comparison.EQ).named(\"upper_middle_selector\")\n    upper_middle = rasp.Aggregate(upper_middle_selector, sorted_seq).named(\"upper_middle\")\n    \n    # Calculate the average of lower and upper middle (which will be the same for odd lengths)\n    median = rasp.SequenceMap(lambda x, y: (x + y) / 2, lower_middle, upper_middle).named(\"median\")\n    \n    # Broadcast the median value across the entire sequence\n    return rasp.Map(lambda x: x, median).named(\"set_to_median\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3.5, 3.5, 3.5, 3.5, 3.5, 3.5]. (0.306 error rate)"
            },
            {
                "generated rasp code": "def make_length() -> rasp.SOp:\n    \"\"\"Returns the length of the input sequence.\"\"\"\n    all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\ndef make_sort(max_seq_len: int = 100, min_val: float = 0) -> rasp.SOp:\n    \"\"\"Returns a sorted version of the input sequence.\"\"\"\n    keys = rasp.SequenceMap(lambda x, i: x + min_val * i / max_seq_len, rasp.tokens, rasp.indices)\n    smaller = rasp.Select(keys, keys, rasp.Comparison.LT).named(\"smaller\")\n    target_pos = rasp.SelectorWidth(smaller).named(\"target_pos\")\n    sel_new = rasp.Select(target_pos, rasp.indices, rasp.Comparison.EQ)\n    return rasp.Aggregate(sel_new, rasp.tokens).named(\"sort\")\n\ndef make_set_to_median() -> rasp.SOp:\n    \"\"\"Replaces each element with the median of all elements.\"\"\"\n    # Sort the input sequence\n    sorted_seq = make_sort().named(\"sorted_seq\")\n    \n    # Get the length of the sequence\n    length = make_length().named(\"length\")\n    \n    # Calculate the index of the median element(s)\n    mid_index = rasp.Map(lambda x: (x - 1) / 2, length).named(\"mid_index\")\n    \n    # Create a selector for the median element(s)\n    median_selector = rasp.Select(\n        rasp.indices,\n        mid_index,\n        lambda x, y: x == int(y) or x == int(y) + 0.5\n    ).named(\"median_selector\")\n    \n    # Select the median element(s)\n    median_elements = rasp.Aggregate(median_selector, sorted_seq).named(\"median_elements\")\n    \n    # Calculate the median (average of two middle elements if even length)\n    median = rasp.SequenceMap(\n        lambda x, y: (x + y) / 2,\n        rasp.Aggregate(rasp.Select(rasp.indices, mid_index, lambda x, y: x == int(y)), median_elements),\n        rasp.Aggregate(rasp.Select(rasp.indices, mid_index, lambda x, y: x == int(y) + 0.5), median_elements)\n    ).named(\"median\")\n    \n    # Broadcast the median across the entire sequence\n    return rasp.Map(lambda x: x, median).named(\"set_to_median\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, None, None, None, None, None]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_length() -> rasp.SOp:\n    \"\"\"Creates an SOp that returns the length of the input sequence.\"\"\"\n    all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\ndef make_sort(max_seq_len: int = 100, min_key: float = 0) -> rasp.SOp:\n    \"\"\"Creates an SOp that sorts the input sequence.\"\"\"\n    keys = rasp.SequenceMap(lambda x, i: x + min_key * i / max_seq_len, rasp.tokens, rasp.indices)\n    smaller = rasp.Select(keys, keys, rasp.Comparison.LT).named(\"smaller\")\n    target_pos = rasp.SelectorWidth(smaller).named(\"target_pos\")\n    sel_new = rasp.Select(target_pos, rasp.indices, rasp.Comparison.EQ)\n    return rasp.Aggregate(sel_new, rasp.tokens).named(\"sort\")\n\ndef make_set_to_median() -> rasp.SOp:\n    \"\"\"Creates an SOp that replaces each element with the median of all elements.\"\"\"\n    \n    # Sort the input sequence\n    sorted_seq = make_sort().named(\"sorted_seq\")\n    \n    # Get the length of the sequence\n    length = make_length().named(\"length\")\n    \n    # Calculate the middle index\n    middle_index = rasp.SequenceMap(lambda l, i: (l - 1) // 2, length, rasp.indices).named(\"middle_index\")\n    \n    # Select the middle element(s)\n    middle_selector = rasp.Select(rasp.indices, middle_index, rasp.Comparison.EQ).named(\"middle_selector\")\n    next_middle_selector = rasp.Select(rasp.indices, middle_index + 1, rasp.Comparison.EQ).named(\"next_middle_selector\")\n    \n    # Extract the middle element(s)\n    middle_element = rasp.Aggregate(middle_selector, sorted_seq).named(\"middle_element\")\n    next_middle_element = rasp.Aggregate(next_middle_selector, sorted_seq).named(\"next_middle_element\")\n    \n    # Calculate the median (average of two middle elements for even-length sequences)\n    is_even = rasp.SequenceMap(lambda l, i: l % 2 == 0, length, rasp.indices).named(\"is_even\")\n    median = rasp.SequenceMap(\n        lambda m, n, e: (m + n) / 2 if e else m,\n        middle_element,\n        next_middle_element,\n        is_even\n    ).named(\"median\")\n    \n    # Create a sequence filled with the median value\n    return rasp.SequenceMap(lambda x, m: m, rasp.tokens, median).named(\"set_to_median\")",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            }
        ],
        "make_swap_min_max": [
            {
                "generated rasp code": "def make_swap_min_max() -> rasp.SOp:\n    def make_length() -> rasp.SOp:\n        all_true_selector = rasp.Select(\n            rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n        return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n    # Find max element\n    max_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LEQ).named(\"max_selector\")\n    max_count = rasp.SelectorWidth(max_selector).named(\"max_count\")\n    length = make_length()\n    max_element_selector = rasp.Select(max_count, length, rasp.Comparison.EQ).named(\"max_element_selector\")\n    max_element = rasp.Aggregate(max_element_selector, rasp.tokens).named(\"max_element\")\n\n    # Find min element\n    min_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.GEQ).named(\"min_selector\")\n    min_count = rasp.SelectorWidth(min_selector).named(\"min_count\")\n    min_element_selector = rasp.Select(min_count, length, rasp.Comparison.EQ).named(\"min_element_selector\")\n    min_element = rasp.Aggregate(min_element_selector, rasp.tokens).named(\"min_element\")\n\n    # Create selectors for max and min positions\n    is_max = rasp.Select(rasp.tokens, max_element, rasp.Comparison.EQ).named(\"is_max\")\n    is_min = rasp.Select(rasp.tokens, min_element, rasp.Comparison.EQ).named(\"is_min\")\n\n    # Swap max and min elements\n    swapped = rasp.Map(\n        lambda x: min_element if x == max_element else (max_element if x == min_element else x),\n        rasp.tokens\n    ).named(\"swapped\")\n\n    return swapped",
                "failure stage": 3,
                "error": "unhashable type: 'Aggregate'"
            },
            {
                "generated rasp code": "def make_swap_min_max() -> rasp.SOp:\n    def make_length() -> rasp.SOp:\n        all_true_selector = rasp.Select(\n            rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n        return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n    # Find maximum element\n    max_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LEQ).named(\"max_selector\")\n    max_count = rasp.SelectorWidth(max_selector).named(\"max_count\")\n    length = make_length()\n    max_element_selector = rasp.Select(max_count, length, rasp.Comparison.EQ).named(\"max_element_selector\")\n    max_element = rasp.Aggregate(max_element_selector, rasp.tokens, default=None).named(\"max_element\")\n\n    # Find minimum element\n    min_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.GEQ).named(\"min_selector\")\n    min_count = rasp.SelectorWidth(min_selector).named(\"min_count\")\n    min_element_selector = rasp.Select(min_count, length, rasp.Comparison.EQ).named(\"min_element_selector\")\n    min_element = rasp.Aggregate(min_element_selector, rasp.tokens, default=None).named(\"min_element\")\n\n    # Create selectors for max and min positions\n    is_max = rasp.Select(rasp.tokens, max_element, rasp.Comparison.EQ).named(\"is_max\")\n    is_min = rasp.Select(rasp.tokens, min_element, rasp.Comparison.EQ).named(\"is_min\")\n\n    # Swap max and min elements\n    def swap(x, is_max_val, is_min_val, max_val, min_val):\n        if is_max_val:\n            return min_val\n        elif is_min_val:\n            return max_val\n        else:\n            return x\n\n    swapped = rasp.SequenceMap(\n        lambda x, m, n, mx, mn: swap(x, m, n, mx, mn),\n        rasp.tokens,\n        is_max,\n        is_min,\n        max_element,\n        min_element\n    ).named(\"swapped\")\n\n    return swapped",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 7 were given"
            },
            {
                "generated rasp code": "def make_swap_min_max() -> rasp.SOp:\n    def make_max_element() -> rasp.SOp:\n        # Selector that creates a comparison matrix where each element is compared to every other element.\n        geq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.GEQ).named(\"geq_selector\")\n        # Count the number of comparisons where each element is greater than or equal to other elements.\n        geq_count = rasp.SelectorWidth(geq_selector).named(\"geq_count\")\n        # Create a sequence of the length of the input\n        length = rasp.SelectorWidth(rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE)).named(\"length\")\n        # Select the element(s) where the geq_count equals the sequence length (i.e., the maximum element(s))\n        max_element_selector = rasp.Select(geq_count, length, rasp.Comparison.EQ).named(\"max_element_selector\")\n        # Use Aggregate to broadcast the maximum element across the entire sequence\n        return rasp.Aggregate(max_element_selector, rasp.tokens).named(\"max_element\")\n\n    def make_min_element() -> rasp.SOp:\n        # Selector that creates a comparison matrix where each element is compared to every other element.\n        leq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LEQ).named(\"leq_selector\")\n        # Count the number of comparisons where each element is less than or equal to other elements.\n        leq_count = rasp.SelectorWidth(leq_selector).named(\"leq_count\")\n        # Create a sequence of the length of the input\n        length = rasp.SelectorWidth(rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE)).named(\"length\")\n        # Select the element(s) where the leq_count equals the sequence length (i.e., the minimum element(s))\n        min_element_selector = rasp.Select(leq_count, length, rasp.Comparison.EQ).named(\"min_element_selector\")\n        # Use Aggregate to broadcast the minimum element across the entire sequence\n        return rasp.Aggregate(min_element_selector, rasp.tokens).named(\"min_element\")\n\n    # Get the maximum and minimum elements\n    max_element = make_max_element()\n    min_element = make_min_element()\n\n    # Create selectors for the positions of the maximum and minimum elements\n    max_selector = rasp.Select(rasp.tokens, max_element, rasp.Comparison.EQ).named(\"max_selector\")\n    min_selector = rasp.Select(rasp.tokens, min_element, rasp.Comparison.EQ).named(\"min_selector\")\n\n    # Create a sequence where max elements are replaced by min and min elements are replaced by max\n    swapped_sequence = rasp.SequenceMap(\n        lambda x, y, z: y if z else (x if not y else z),\n        rasp.tokens,\n        rasp.SequenceMap(\n            lambda x, y: x if y else y,\n            min_element,\n            max_selector\n        ),\n        rasp.SequenceMap(\n            lambda x, y: x if y else y,\n            max_element,\n            min_selector\n        )\n    ).named(\"swapped_sequence\")\n\n    return swapped_sequence",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_swap_min_max() -> rasp.SOp:\n    def make_max_element() -> rasp.SOp:\n        # Selector that creates a comparison matrix where each element is compared to every other element\n        geq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.GEQ).named(\"geq_selector\")\n        # Count the number of comparisons where each element is greater than or equal to other elements\n        geq_count = rasp.SelectorWidth(geq_selector).named(\"geq_count\")\n        # Create a sequence of the length of the input\n        length = rasp.SelectorWidth(rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE)).named(\"length\")\n        # Select elements that are greater than or equal to all other elements (i.e., the maximum)\n        max_selector = rasp.Select(geq_count, length, rasp.Comparison.EQ).named(\"max_selector\")\n        # Use Aggregate to get the maximum value\n        return rasp.Aggregate(max_selector, rasp.tokens).named(\"max_element\")\n\n    def make_min_element() -> rasp.SOp:\n        # Selector that creates a comparison matrix where each element is compared to every other element\n        leq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LEQ).named(\"leq_selector\")\n        # Count the number of comparisons where each element is less than or equal to other elements\n        leq_count = rasp.SelectorWidth(leq_selector).named(\"leq_count\")\n        # Create a sequence of the length of the input\n        length = rasp.SelectorWidth(rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE)).named(\"length\")\n        # Select elements that are less than or equal to all other elements (i.e., the minimum)\n        min_selector = rasp.Select(leq_count, length, rasp.Comparison.EQ).named(\"min_selector\")\n        # Use Aggregate to get the minimum value\n        return rasp.Aggregate(min_selector, rasp.tokens).named(\"min_element\")\n\n    # Get the maximum and minimum elements\n    max_element = make_max_element()\n    min_element = make_min_element()\n\n    # Create selectors for the positions of the maximum and minimum elements\n    max_positions = rasp.Select(rasp.tokens, max_element, rasp.Comparison.EQ).named(\"max_positions\")\n    min_positions = rasp.Select(rasp.tokens, min_element, rasp.Comparison.EQ).named(\"min_positions\")\n\n    # Replace max elements with min value and min elements with max value\n    replaced_max = rasp.Aggregate(max_positions, min_element).named(\"replaced_max\")\n    replaced_min = rasp.Aggregate(min_positions, max_element).named(\"replaced_min\")\n\n    # Combine the replaced elements with the original sequence\n    # If an element is a max, use the replaced max value\n    # If an element is a min, use the replaced min value\n    # Otherwise, use the original value\n    return rasp.SequenceMap(\n        lambda orig, rep_max, rep_min: rep_max if rep_max is not None else (rep_min if rep_min is not None else orig),\n        rasp.tokens,\n        replaced_max,\n        replaced_min\n    ).named(\"swapped_sequence\")",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            },
            {
                "generated rasp code": "def make_swap_min_max() -> rasp.SOp:\n    # Find the maximum element\n    max_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.GEQ).named(\"max_selector\")\n    max_count = rasp.SelectorWidth(max_selector).named(\"max_count\")\n    length = rasp.SelectorWidth(rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE)).named(\"length\")\n    is_max = rasp.Select(max_count, length, rasp.Comparison.EQ).named(\"is_max\")\n    max_value = rasp.Aggregate(is_max, rasp.tokens).named(\"max_value\")\n\n    # Find the minimum element\n    min_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LEQ).named(\"min_selector\")\n    min_count = rasp.SelectorWidth(min_selector).named(\"min_count\")\n    is_min = rasp.Select(min_count, length, rasp.Comparison.EQ).named(\"is_min\")\n    min_value = rasp.Aggregate(is_min, rasp.tokens).named(\"min_value\")\n\n    # Create selectors for max and min elements\n    select_max = rasp.Select(rasp.tokens, max_value, rasp.Comparison.EQ).named(\"select_max\")\n    select_min = rasp.Select(rasp.tokens, min_value, rasp.Comparison.EQ).named(\"select_min\")\n\n    # Replace max elements with min value and min elements with max value\n    swapped_max = rasp.Aggregate(select_max, min_value).named(\"swapped_max\")\n    swapped_min = rasp.Aggregate(select_min, max_value).named(\"swapped_min\")\n\n    # Combine swapped elements with unchanged elements\n    is_unchanged = ~(select_max | select_min).named(\"is_unchanged\")\n    unchanged = rasp.Aggregate(is_unchanged, rasp.tokens).named(\"unchanged\")\n\n    # Combine all parts to create the final sequence\n    result = rasp.SequenceMap(\n        lambda x, y, z: x if x is not None else (y if y is not None else z),\n        swapped_max,\n        rasp.SequenceMap(\n            lambda x, y: x if x is not None else y,\n            swapped_min,\n            unchanged\n        )\n    ).named(\"result\")\n\n    return result",
                "failure stage": 1,
                "error": "Unsupported type for aggregation: [1.0, 1.0]"
            }
        ],
        "make_clip": [],
        "make_pairwise_max": [
            {
                "generated rasp code": "def make_pairwise_max() -> rasp.SOp:\n    # Function to shift the sequence by 1 position\n    def shift_by_one(sop: rasp.SOp) -> rasp.SOp:\n        shift_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y + 1).named(\"shift_selector\")\n        return rasp.Aggregate(shift_selector, sop).named(\"shifted_sequence\")\n\n    # Shift the sequence by 1\n    shifted_sequence = shift_by_one(rasp.tokens)\n\n    # Use the first element of the original sequence for the first position of the shifted sequence\n    first_element_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == 0).named(\"first_element_selector\")\n    first_element = rasp.Aggregate(first_element_selector, rasp.tokens).named(\"first_element\")\n    \n    shifted_sequence_with_first = rasp.SequenceMap(\n        lambda x, y: y if x == 0 else x,\n        shifted_sequence,\n        first_element\n    ).named(\"shifted_sequence_with_first\")\n\n    # Compare each element with its previous element\n    max_sequence = rasp.SequenceMap(\n        lambda x, y: max(x, y),\n        rasp.tokens,\n        shifted_sequence_with_first\n    ).named(\"max_sequence\")\n\n    return max_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [8.0, 8, 2, 5.0, 5, None]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_pairwise_max() -> rasp.SOp:\n    # Define shift_by function\n    def shift_by(offset: int, sop: rasp.SOp, fill: rasp.Value) -> rasp.SOp:\n        \"\"\"Returns the sop, shifted by `offset`, filled with `fill` value.\"\"\"\n        select_off_by_offset = rasp.Select(rasp.indices, rasp.indices,\n                                           lambda k, q: q == k + offset)\n        out = rasp.Aggregate(select_off_by_offset, sop, default=fill)\n        return out.named(f\"shift_by({offset})\")\n\n    # Shift the sequence by 1 position to the right, filling with a very small number\n    shifted = shift_by(1, rasp.tokens, fill=float('-inf'))\n\n    # Compare each element with its previous element (or -inf for the first element)\n    pairwise_max = rasp.SequenceMap(lambda x, y: max(x, y), rasp.tokens, shifted).named(\"pairwise_max\")\n\n    # Create a selector for the first element\n    first_elem_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == 0).named(\"first_elem_selector\")\n\n    # Replace the first element with its original value\n    result = rasp.Aggregate(first_elem_selector, rasp.tokens, default=None).named(\"first_elem_original\")\n\n    # Combine the pairwise max with the original first element\n    final_result = rasp.SequenceMap(lambda x, y: y if y is not None else x, pairwise_max, result).named(\"final_result\")\n\n    return final_result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3.0, 3.0, 3.0, 3.0, 3.0, 3.0]. (0.839 error rate)"
            },
            {
                "generated rasp code": "def shift_by(offset: int, sop: rasp.SOp, fill: rasp.Value) -> rasp.SOp:\n    \"\"\"Returns the sop, shifted by `offset`, filled with `fill` value.\"\"\"\n    select_off_by_offset = rasp.Select(rasp.indices, rasp.indices,\n                                       lambda k, q: q == k + offset)\n    out = rasp.Aggregate(select_off_by_offset, sop, default=fill)\n    return out.named(f\"shift_by({offset})\")\n\ndef make_pairwise_max() -> rasp.SOp:\n    # Shift the sequence by 1 to the right, filling with a very small number\n    shifted = shift_by(1, rasp.tokens, fill=-float('inf')).named(\"shifted\")\n\n    # Compare each element with its previous (shifted) element\n    pairwise_max = rasp.SequenceMap(lambda x, y: max(x, y), rasp.tokens, shifted).named(\"pairwise_max\")\n\n    # Create a selector for the first element\n    first_elem_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: 0, rasp.indices), rasp.Comparison.EQ).named(\"first_elem_selector\")\n\n    # Combine the results: use the original first element, and pairwise max for the rest\n    result = rasp.SequenceMap(\n        lambda x, y: x if y else y,\n        pairwise_max,\n        first_elem_selector\n    ).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_pairwise_max() -> rasp.SOp:\n    # Create a selector to shift the sequence by one position\n    shift_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y + 1).named(\"shift_selector\")\n    \n    # Create a shifted version of the sequence, with float('-inf') as the first element\n    shifted_sequence = rasp.Aggregate(shift_selector, rasp.tokens, default=None).named(\"shifted_sequence\")\n    \n    # Replace None with float('-inf') to ensure correct comparison\n    shifted_sequence_inf = rasp.Map(lambda x: float('-inf') if x is None else x, shifted_sequence).named(\"shifted_sequence_inf\")\n    \n    # Compare each element with its previous element (or -inf for the first element)\n    max_sequence = rasp.SequenceMap(lambda x, y: max(x, y), rasp.tokens, shifted_sequence_inf).named(\"max_sequence\")\n    \n    # Ensure the first element remains unchanged\n    first_element_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == 0).named(\"first_element_selector\")\n    first_element = rasp.Aggregate(first_element_selector, rasp.tokens, default=None).named(\"first_element\")\n    \n    # Combine the original first element with the max sequence\n    result = rasp.SequenceMap(lambda x, y: x if y == 0 else y, max_sequence, rasp.indices).named(\"result\")\n    \n    return result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [8.0, 1, 2, 3, 4, None]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_pairwise_max() -> rasp.SOp:\n    # Create a selector for shifting the sequence\n    shift_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y + 1).named(\"shift_selector\")\n    \n    # Shift the sequence by one position to the right, using the first element as the default\n    shifted_sequence = rasp.Aggregate(shift_selector, rasp.tokens).named(\"shifted_sequence\")\n    \n    # Compare each element with its previous (shifted) element\n    pairwise_max = rasp.SequenceMap(lambda x, y: max(x, y), rasp.tokens, shifted_sequence).named(\"pairwise_max\")\n    \n    # Create a selector for the first element\n    first_elem_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == 0).named(\"first_elem_selector\")\n    \n    # Combine the results: keep the first element unchanged, use pairwise max for the rest\n    result = rasp.SequenceMap(\n        lambda x, y: x if y else y,\n        pairwise_max,\n        first_elem_selector\n    ).named(\"result\")\n    \n    return result",
                "failure stage": 0,
                "error": ""
            }
        ],
        "make_check_alternating": [
            {
                "generated rasp code": "def make_check_alternating() -> rasp.SOp:\n    # Function to check if a number is even (1) or odd (0)\n    is_even = rasp.Map(lambda x: 1 if x % 2 == 0 else 0, rasp.tokens).named(\"is_even\")\n    \n    # Function to determine if the index should be even (1) or odd (0)\n    should_be_even = rasp.Map(lambda x: x % 2, rasp.indices).named(\"should_be_even\")\n    \n    # Compare the actual evenness with the expected evenness\n    matches_pattern = rasp.SequenceMap(lambda x, y: 1 if x == y else 0, is_even, should_be_even).named(\"matches_pattern\")\n    \n    # Check if all elements match the pattern\n    all_match = rasp.Select(matches_pattern, matches_pattern, lambda x, y: x == 1).named(\"all_match\")\n    \n    # Count how many elements match the pattern\n    match_count = rasp.SelectorWidth(all_match).named(\"match_count\")\n    \n    # Get the length of the sequence\n    seq_length = rasp.Map(lambda x: 1, rasp.tokens).named(\"seq_length\")\n    length = rasp.SelectorWidth(rasp.Select(seq_length, seq_length, rasp.Comparison.TRUE)).named(\"length\")\n    \n    # Check if all elements match (match_count equals length)\n    all_alternating = rasp.Select(match_count, length, rasp.Comparison.EQ).named(\"all_alternating\")\n    \n    # Create the final output sequence\n    return rasp.Aggregate(all_alternating, rasp.Map(lambda x: 1, rasp.tokens), default=0).named(\"check_alternating\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0, 0, 0, 0, 0, 0]. (0.04 error rate)"
            },
            {
                "generated rasp code": "def make_check_alternating() -> rasp.SOp:\n    # Function to check if a number is even (1) or odd (0)\n    check_even = rasp.Map(lambda x: 1 if x % 2 == 0 else 0, rasp.tokens).named(\"check_even\")\n    \n    # Shift the sequence by 1 to compare adjacent elements\n    shifted = rasp.SequenceMap(lambda x, y: y, rasp.tokens, rasp.Map(lambda x: None, rasp.tokens)).named(\"shifted\")\n    \n    # Check if adjacent elements are different (one odd, one even)\n    adjacent_different = rasp.SequenceMap(lambda x, y: 1 if x != y else 0, check_even, \n                                          rasp.Map(lambda x: 1 if x is None else check_even(x), shifted)).named(\"adjacent_different\")\n    \n    # Count how many adjacent pairs are different\n    count_different = rasp.SelectorWidth(rasp.Select(adjacent_different, adjacent_different, lambda x, y: x == 1)).named(\"count_different\")\n    \n    # Get the length of the sequence\n    length = rasp.SelectorWidth(rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE)).named(\"length\")\n    \n    # Check if the count of different pairs is equal to length - 1\n    is_alternating = rasp.SequenceMap(lambda x, y: 1 if x == y - 1 else 0, count_different, length).named(\"is_alternating\")\n    \n    # Create the final output: if is_alternating is 1, return 1, else return 0\n    return rasp.Map(lambda x: x, is_alternating).named(\"check_alternating\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0, 0, 0, 0, 0, 0]. (0.08 error rate)"
            },
            {
                "generated rasp code": "def make_check_alternating() -> rasp.SOp:\n    # Function to check if a number is even (1) or odd (0)\n    def is_even(x):\n        return 1 if x % 2 == 0 else 0\n\n    # Create a sequence of even/odd checks\n    even_odd_seq = rasp.Map(is_even, rasp.tokens).named(\"even_odd_seq\")\n\n    # Shift the even/odd sequence by 1 to compare with its predecessor\n    shifted_even_odd = rasp.SequenceMap(lambda x, y: x, even_odd_seq, rasp.tokens).named(\"shifted_even_odd\")\n\n    # Compare each element with its predecessor\n    alternating_check = rasp.SequenceMap(\n        lambda x, y: 1 if x != y else 0,\n        even_odd_seq,\n        shifted_even_odd\n    ).named(\"alternating_check\")\n\n    # Create a selector for elements that satisfy the alternation condition\n    alternating_selector = rasp.Select(\n        alternating_check,\n        rasp.Map(lambda x: 1, rasp.tokens),\n        rasp.Comparison.EQ\n    ).named(\"alternating_selector\")\n\n    # Count how many elements satisfy the alternation condition\n    alternating_count = rasp.SelectorWidth(alternating_selector).named(\"alternating_count\")\n\n    # Get the length of the sequence\n    seq_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"seq_length\")\n\n    # Check if all elements satisfy the alternation condition\n    all_alternating = rasp.SequenceMap(\n        lambda count, length: 1 if count == length - 1 else 0,\n        alternating_count,\n        seq_length\n    ).named(\"all_alternating\")\n\n    return all_alternating",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_check_alternating() -> rasp.SOp:\n    # Function to check if a number is even (1) or odd (0)\n    check_even = rasp.Map(lambda x: 1 if x % 2 == 0 else 0, rasp.tokens).named(\"check_even\")\n    \n    # Function to check if index is even (1) or odd (0)\n    check_index_even = rasp.Map(lambda x: 1 if x % 2 == 0 else 0, rasp.indices).named(\"check_index_even\")\n    \n    # Compare evenness of number with oddness of index\n    # If number is even (1) and index is odd (0), or number is odd (0) and index is even (1), it's correct\n    correct_alternation = rasp.SequenceMap(lambda x, y: 1 if x != y else 0, check_even, check_index_even).named(\"correct_alternation\")\n    \n    # Count how many elements follow the alternating pattern\n    alternating_count = rasp.SelectorWidth(rasp.Select(correct_alternation, correct_alternation, rasp.Comparison.EQ)).named(\"alternating_count\")\n    \n    # Get the length of the sequence\n    length = rasp.SelectorWidth(rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE)).named(\"length\")\n    \n    # Check if all elements follow the pattern (count equals length)\n    all_alternating = rasp.Select(alternating_count, length, rasp.Comparison.EQ).named(\"all_alternating\")\n    \n    # If all elements alternate, output 1, otherwise 0\n    result = rasp.Aggregate(all_alternating, rasp.Map(lambda x: 1, rasp.tokens), default=None).named(\"result\")\n    \n    return result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, None, None, None, None, None]. (0.92 error rate)"
            },
            {
                "generated rasp code": "def make_check_alternating() -> rasp.SOp:\n    # Helper function to check if a number is even\n    def is_even(x):\n        return 1 if x % 2 == 0 else 0\n\n    # Implement shift_by function\n    def shift_by(offset: int, sop: rasp.SOp, fill: rasp.Value) -> rasp.SOp:\n        select_off_by_offset = rasp.Select(rasp.indices, rasp.indices,\n                                           lambda k, q: q == k + offset)\n        out = rasp.Aggregate(select_off_by_offset, sop, default=fill)\n        return out.named(f\"shift_by({offset})\")\n\n    # Check if each number is even\n    even_check = rasp.Map(is_even, rasp.tokens).named(\"even_check\")\n\n    # Shift the even_check sequence by 1 to compare with adjacent elements\n    shifted_even_check = shift_by(1, even_check, fill=None).named(\"shifted_even_check\")\n\n    # Compare each element with its predecessor to check for alternating parity\n    alternating_check = rasp.SequenceMap(\n        lambda x, y: 1 if x != y else 0,\n        even_check,\n        shifted_even_check\n    ).named(\"alternating_check\")\n\n    # Check if the first element is odd (should be 1 in even_check)\n    first_odd_check = rasp.SequenceMap(\n        lambda x, y: 1 if (x == 0 and y == 0) else 1,\n        rasp.indices,\n        even_check\n    ).named(\"first_odd_check\")\n\n    # Combine alternating_check and first_odd_check\n    combined_check = rasp.SequenceMap(\n        lambda x, y: x * y,\n        alternating_check,\n        first_odd_check\n    ).named(\"combined_check\")\n\n    # Convert to final output format (all 1's if conditions are met, all 0's otherwise)\n    final_output = rasp.Map(\n        lambda x: 1 if x == 1 else 0,\n        combined_check\n    ).named(\"final_output\")\n\n    return final_output",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, 1, 0, 1, 0, 1]. (1.0 error rate)"
            }
        ],
        "make_exponential": [
            {
                "generated rasp code": "def make_exponential() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that exponentiates each element in the input sequence.\n    Uses a Taylor series approximation of e^x with 10 terms for accuracy.\n    \"\"\"\n    def exp_approx(x):\n        # Taylor series approximation of e^x\n        # e^x \u2248 1 + x + x^2/2! + x^3/3! + ... + x^10/10!\n        result = 1.0\n        term = 1.0\n        for i in range(1, 11):  # Using 10 terms for approximation\n            term *= x / i\n            result += term\n        return result\n\n    return rasp.Map(exp_approx, rasp.tokens).named(\"exponential\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [20.079665178571425, 2432.121269841269, 7.388994708994708, 2.7182818011463845, 146.38060102513228, 54.44310405643739]. (0.987 error rate)"
            },
            {
                "generated rasp code": "def make_exponential() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that exponentiates each element in the input sequence.\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that, when executed, applies the exponential \n              function to each element of the input sequence.\n    \"\"\"\n    # Define the exponential function using the approximation e^x \u2248 (1 + x/n)^n\n    # where n is a large number for better accuracy\n    def exp_approx(x, n=1000000):\n        return (1 + x/n)**n\n    \n    # Use rasp.Map to apply the exponential function to each element\n    return rasp.Map(lambda x: exp_approx(x), rasp.tokens).named(\"exponential\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [20.08544653815843, 2980.862598444957, 7.389041321277888, 2.7182804690957534, 148.41130396072768, 54.59771324501273]. (0.987 error rate)"
            },
            {
                "generated rasp code": "def make_exponential() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that exponentiates each element of the input sequence.\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that applies the exponential function to each element.\n    \n    Example:\n    exponential = make_exponential()\n    exponential([0, 1, 2]) # returns approximately [1, 2.718, 7.389]\n    \"\"\"\n    \n    # Define the exponential approximation function\n    # We use the approximation e^x \u2248 (1 + x/n)^n where n = 1000\n    def exp_approx(x):\n        n = 1000\n        return (1 + x / n) ** n\n    \n    # Apply the exponential approximation to each element using Map\n    return rasp.Map(exp_approx, rasp.tokens).named(\"exponential\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [19.995534623451498, 2887.5672632098995, 7.374312390354616, 2.7169239322355936, 146.57562561109216, 54.164259360432794]. (0.987 error rate)"
            },
            {
                "generated rasp code": "def make_exponential() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP SOp that exponentiates each element of the input sequence.\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that applies e^x to each element.\n    \"\"\"\n    \n    def exp_approx(x):\n        \"\"\"\n        Approximates e^x using the first 5 terms of its Taylor series.\n        e^x \u2248 1 + x + x^2/2! + x^3/3! + x^4/4!\n        \"\"\"\n        return 1 + x + (x**2)/2 + (x**3)/6 + (x**4)/24\n    \n    return rasp.Map(exp_approx, rasp.tokens).named(\"exponential\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [16.375, 297.0, 7.0, 2.708333333333333, 65.375, 34.33333333333333]. (0.987 error rate)"
            },
            {
                "generated rasp code": "def make_exponential() -> rasp.SOp:\n    def exp_approx(x, n=1000000):\n        \"\"\"\n        Approximates e^x using the formula (1 + x/n)^n.\n        \n        Args:\n        x: The exponent\n        n: The approximation factor (default: 1000000)\n        \n        Returns:\n        An approximation of e^x\n        \"\"\"\n        return (1 + x/n) ** n\n\n    # Apply the exponential approximation to each element of the input sequence\n    return rasp.Map(lambda x: exp_approx(x), rasp.tokens).named(\"exponential\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [20.08544653815843, 2980.862598444957, 7.389041321277888, 2.7182804690957534, 148.41130396072768, 54.59771324501273]. (0.987 error rate)"
            }
        ],
        "make_interleave_reverse": [
            {
                "generated rasp code": "def make_interleave_reverse() -> rasp.SOp:\n    # Create a sequence of indices\n    indices = rasp.indices.named(\"indices\")\n    \n    # Create a sequence containing the length of the sequence\n    all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    length = rasp.SelectorWidth(all_true_selector).named(\"length\")\n    \n    # Generate the reversed indices\n    reversed_indices = (length - indices - 1).named(\"reversed_indices\")\n\n    # Create a selector for reversing the sequence\n    reverse_selector = rasp.Select(indices, reversed_indices, rasp.Comparison.EQ).named(\"reverse_selector\")\n    \n    # Reverse the sequence\n    reversed_sequence = rasp.Aggregate(reverse_selector, rasp.tokens).named(\"reversed_sequence\")\n\n    # Create selectors for even and odd indices\n    even_selector = rasp.Select(indices, indices, lambda x, y: x % 2 == 0).named(\"even_selector\")\n    odd_selector = rasp.Select(indices, indices, lambda x, y: x % 2 != 0).named(\"odd_selector\")\n\n    # Select elements from original sequence for even indices\n    even_elements = rasp.Aggregate(even_selector, rasp.tokens).named(\"even_elements\")\n\n    # Select elements from reversed sequence for odd indices\n    odd_elements = rasp.Aggregate(odd_selector, reversed_sequence).named(\"odd_elements\")\n\n    # Combine even and odd elements\n    interleaved = rasp.SequenceMap(\n        lambda x, y: x if x is not None else y,\n        even_elements,\n        odd_elements\n    ).named(\"interleaved\")\n\n    return interleaved",
                "failure stage": 1,
                "error": "Unsupported type for aggregation: [2.0, 5.0, 7.0]"
            },
            {
                "generated rasp code": "def make_interleave_reverse() -> rasp.SOp:\n    # Helper function to get the length of the sequence\n    def make_length() -> rasp.SOp:\n        all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n        return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n    # Helper function to reverse the sequence\n    def make_reverse() -> rasp.SOp:\n        length = make_length()\n        reversed_indices = rasp.SequenceMap(lambda l, i: l - i - 1, length, rasp.indices).named(\"reversed_indices\")\n        reverse_selector = rasp.Select(rasp.indices, reversed_indices, rasp.Comparison.EQ).named(\"reverse_selector\")\n        return rasp.Aggregate(reverse_selector, rasp.tokens).named(\"reverse\")\n\n    # Create selectors for even and odd indices\n    even_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 0).named(\"even_selector\")\n    odd_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 != 0).named(\"odd_selector\")\n\n    # Get the original sequence for even indices\n    even_elements = rasp.Aggregate(even_selector, rasp.tokens).named(\"even_elements\")\n\n    # Get the reversed sequence for odd indices\n    reversed_sequence = make_reverse()\n    odd_elements = rasp.Aggregate(odd_selector, reversed_sequence).named(\"odd_elements\")\n\n    # Combine even and odd elements\n    return rasp.SequenceMap(lambda x, y: x if x is not None else y, even_elements, odd_elements).named(\"interleaved_reverse\")",
                "failure stage": 1,
                "error": "Unsupported type for aggregation: [2.0, 5.0, 7.0]"
            },
            {
                "generated rasp code": "def make_interleave_reverse() -> rasp.SOp:\n    # Function to get the length of the sequence\n    def make_length() -> rasp.SOp:\n        all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n        return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n    length = make_length()\n\n    # Function to reverse the sequence\n    def make_reverse(sop: rasp.SOp) -> rasp.SOp:\n        opp_idx = (length - rasp.indices - 1).named(\"opp_idx\")\n        reverse_selector = rasp.Select(rasp.indices, opp_idx, rasp.Comparison.EQ).named(\"reverse_selector\")\n        return rasp.Aggregate(reverse_selector, sop).named(\"reverse\")\n\n    reversed_sequence = make_reverse(rasp.tokens)\n\n    # Create selector for even indices\n    even_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 0).named(\"even_selector\")\n\n    # Create selector for odd indices\n    odd_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 != 0).named(\"odd_selector\")\n\n    # Select elements at even indices from original sequence\n    even_elements = rasp.Aggregate(even_selector, rasp.tokens).named(\"even_elements\")\n\n    # Select elements at odd indices from reversed sequence\n    odd_elements = rasp.Aggregate(odd_selector, reversed_sequence).named(\"odd_elements\")\n\n    # Combine even and odd elements\n    def combine_elements(even, odd):\n        return even if even is not None else odd\n\n    interleaved = rasp.SequenceMap(combine_elements, even_elements, odd_elements).named(\"interleaved\")\n\n    return interleaved",
                "failure stage": 1,
                "error": "Unsupported type for aggregation: [2.0, 5.0, 7.0]"
            },
            {
                "generated rasp code": "def make_interleave_reverse() -> rasp.SOp:\n    # Helper function to get the length of the sequence\n    def make_length() -> rasp.SOp:\n        all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n        return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n    # Helper function to reverse the sequence\n    def make_reverse() -> rasp.SOp:\n        length = make_length()\n        reverse_selector = rasp.Select(rasp.indices, length - rasp.indices - 1, rasp.Comparison.EQ).named(\"reverse_selector\")\n        return rasp.Aggregate(reverse_selector, rasp.tokens).named(\"reverse\")\n\n    # Create selectors for even and odd indices\n    even_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 0).named(\"even_selector\")\n    odd_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 != 0).named(\"odd_selector\")\n\n    # Get original elements at even positions\n    even_elements = rasp.Aggregate(even_selector, rasp.tokens).named(\"even_elements\")\n\n    # Get reversed elements at odd positions\n    reversed_sequence = make_reverse()\n    odd_elements = rasp.Aggregate(odd_selector, reversed_sequence).named(\"odd_elements\")\n\n    # Combine even and odd elements\n    return rasp.SequenceMap(\n        lambda x, y: x if x is not None else y,\n        even_elements,\n        odd_elements\n    ).named(\"interleave_reverse\")",
                "failure stage": 1,
                "error": "Unsupported type for aggregation: [2.0, 5.0, 7.0]"
            },
            {
                "generated rasp code": "def make_interleave_reverse() -> rasp.SOp:\n    # Helper function to get the length of the sequence\n    def make_length() -> rasp.SOp:\n        all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n        return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n    # Helper function to reverse the sequence\n    def make_reverse() -> rasp.SOp:\n        length = make_length()\n        reversed_indices = rasp.SequenceMap(lambda l, i: l - i - 1, length, rasp.indices).named(\"reversed_indices\")\n        reverse_selector = rasp.Select(rasp.indices, reversed_indices, rasp.Comparison.EQ).named(\"reverse_selector\")\n        return rasp.Aggregate(reverse_selector, rasp.tokens).named(\"reverse\")\n\n    # Create selectors for even and odd indices\n    even_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 0).named(\"even_selector\")\n    odd_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 != 0).named(\"odd_selector\")\n\n    # Get the original sequence for even indices\n    even_elements = rasp.Aggregate(even_selector, rasp.tokens).named(\"even_elements\")\n\n    # Get the reversed sequence for odd indices\n    reversed_sequence = make_reverse()\n    odd_elements = rasp.Aggregate(odd_selector, reversed_sequence).named(\"odd_elements\")\n\n    # Combine even and odd elements\n    return rasp.SequenceMap(lambda x, y: x if x is not None else y, even_elements, odd_elements).named(\"interleave_reverse\")",
                "failure stage": 1,
                "error": "Unsupported type for aggregation: [2.0, 5.0, 7.0]"
            }
        ],
        "make_element_divide": [
            {
                "generated rasp code": "def make_element_divide() -> rasp.SOp:\n    # Get the first element\n    first_elem_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == 0).named(\"first_elem_selector\")\n    first_elem = rasp.Aggregate(first_elem_selector, rasp.tokens).named(\"first_elem\")\n\n    # Get the second element\n    second_elem_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == 1).named(\"second_elem_selector\")\n    second_elem = rasp.Aggregate(second_elem_selector, rasp.tokens).named(\"second_elem\")\n\n    # Calculate division factor (second / first)\n    division_factor = rasp.SequenceMap(\n        lambda x, y: y / x if x != 0 and y is not None else None,\n        first_elem,\n        second_elem\n    ).named(\"division_factor\")\n\n    # Create a \"safe\" division factor\n    # It's 1 when we shouldn't divide (first or second element is zero, or sequence too short)\n    # Otherwise, it's the calculated division factor\n    safe_division_factor = rasp.Map(\n        lambda x: 1 if x is None else x,\n        division_factor\n    ).named(\"safe_division_factor\")\n\n    # Divide each element by the safe division factor\n    result = rasp.SequenceMap(\n        lambda x, y: x / y,\n        rasp.tokens,\n        safe_division_factor\n    ).named(\"result\")\n\n    return result",
                "failure stage": 1,
                "error": "float division by zero"
            },
            {
                "generated rasp code": "def make_element_divide() -> rasp.SOp:\n    # Select the first element\n    first_elem_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == 0).named(\"first_elem_selector\")\n    first_elem = rasp.Aggregate(first_elem_selector, rasp.tokens, default=None).named(\"first_elem\")\n\n    # Select the second element\n    second_elem_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == 1).named(\"second_elem_selector\")\n    second_elem = rasp.Aggregate(second_elem_selector, rasp.tokens, default=None).named(\"second_elem\")\n\n    # Calculate the divisor (first_elem / second_elem)\n    divisor = rasp.SequenceMap(lambda x, y: x / y if y != 0 else 0, first_elem, second_elem).named(\"divisor\")\n\n    # Create a constant sequence of the divisor\n    divisor_seq = rasp.Map(lambda x: x, divisor).named(\"divisor_seq\")\n\n    # Divide each element by the divisor\n    divided_seq = rasp.SequenceMap(lambda x, y: x / y if y != 0 else x, rasp.tokens, divisor_seq).named(\"divided_seq\")\n\n    # Create a validity sequence (1 if operation is valid, 0 otherwise)\n    def check_validity(x, y, z):\n        return 1 if y != 0 and z != 0 and x > 1 else 0\n\n    validity = rasp.SequenceMap(check_validity, \n                                rasp.Map(lambda x: len(x), rasp.tokens),\n                                first_elem,\n                                second_elem).named(\"validity\")\n\n    # Combine the divided sequence with the original sequence based on validity\n    result = rasp.SequenceMap(lambda x, y, z: y if z == 1 else x, \n                              rasp.tokens, \n                              divided_seq, \n                              validity).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            },
            {
                "generated rasp code": "def make_element_divide() -> rasp.SOp:\n    # Create selectors for the first and second elements\n    first_elem_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == 0).named(\"first_elem_selector\")\n    second_elem_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == 1).named(\"second_elem_selector\")\n\n    # Extract the first and second elements\n    first_elem = rasp.Aggregate(first_elem_selector, rasp.tokens).named(\"first_elem\")\n    second_elem = rasp.Aggregate(second_elem_selector, rasp.tokens).named(\"second_elem\")\n\n    # Calculate the division of the first two elements\n    division_result = rasp.SequenceMap(lambda x, y: x / y if y != 0 else 1, first_elem, second_elem).named(\"division_result\")\n\n    # Check if either of the first two elements is zero\n    zero_check = rasp.SequenceMap(lambda x, y: x == 0 or y == 0, first_elem, second_elem).named(\"zero_check\")\n\n    # Get the sequence length\n    all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    sequence_length = rasp.SelectorWidth(all_true_selector).named(\"sequence_length\")\n\n    # Check if the sequence length is less than 2\n    length_check = rasp.Map(lambda x: x < 2, sequence_length).named(\"length_check\")\n\n    # Combine zero check and length check\n    invalid_input = rasp.SequenceMap(lambda x, y: x or y, zero_check, length_check).named(\"invalid_input\")\n\n    # Divide each element by the division result or return the original element\n    divided_sequence = rasp.SequenceMap(\n        lambda x, y: x / y if not z else x,\n        rasp.tokens,\n        division_result,\n        invalid_input\n    ).named(\"divided_sequence\")\n\n    return divided_sequence",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            },
            {
                "generated rasp code": "def make_element_divide() -> rasp.SOp:\n    # Extract the first element\n    first_elem_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == 0).named(\"first_elem_selector\")\n    first_elem = rasp.Aggregate(first_elem_selector, rasp.tokens).named(\"first_elem\")\n\n    # Extract the second element\n    second_elem_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == 1).named(\"second_elem_selector\")\n    second_elem = rasp.Aggregate(second_elem_selector, rasp.tokens).named(\"second_elem\")\n\n    # Calculate the divisor (first_elem / second_elem)\n    divisor = rasp.SequenceMap(lambda x, y: x / y if y != 0 else 1, first_elem, second_elem).named(\"divisor\")\n\n    # Create a selector for sequences with at least two elements\n    length = rasp.SelectorWidth(rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE)).named(\"length\")\n    has_two_elements = rasp.Select(length, rasp.Map(lambda x: 2, rasp.indices), rasp.Comparison.GEQ).named(\"has_two_elements\")\n\n    # Create selectors to check if first and second elements are non-zero\n    first_non_zero = rasp.Select(first_elem, rasp.Map(lambda x: 0, rasp.indices), rasp.Comparison.NEQ).named(\"first_non_zero\")\n    second_non_zero = rasp.Select(second_elem, rasp.Map(lambda x: 0, rasp.indices), rasp.Comparison.NEQ).named(\"second_non_zero\")\n\n    # Combine all conditions\n    valid_input = (has_two_elements & first_non_zero & second_non_zero).named(\"valid_input\")\n\n    # Perform the division\n    divided_sequence = rasp.SequenceMap(lambda x, y: x / y, rasp.tokens, divisor).named(\"divided_sequence\")\n\n    # Select between the divided sequence and the original sequence based on the conditions\n    result = rasp.SequenceMap(lambda x, y: y if x else x, valid_input, divided_sequence).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_element_divide() -> rasp.SOp:\n    # Create selectors for the first and second elements\n    first_elem_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == 0).named(\"first_elem_selector\")\n    second_elem_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == 1).named(\"second_elem_selector\")\n\n    # Extract the first and second elements\n    first_elem = rasp.Aggregate(first_elem_selector, rasp.tokens).named(\"first_elem\")\n    second_elem = rasp.Aggregate(second_elem_selector, rasp.tokens).named(\"second_elem\")\n\n    # Calculate the division of the first two elements\n    # If second_elem is zero, use 1 to avoid division by zero\n    divisor = rasp.SequenceMap(lambda x, y: x / y if y != 0 else 1, first_elem, second_elem).named(\"divisor\")\n\n    # Create a condition: 1 if both elements are non-zero and divisor is not 1 (which would happen if second_elem was 0)\n    # Also check if the sequence has at least two elements by comparing the second element with None\n    condition = rasp.Map(\n        lambda x: 1 if x[0] != 0 and x[1] != 0 and x[1] is not None and x[2] != 1 else 0,\n        rasp.SequenceMap(lambda x, y, z: (x, y, z), first_elem, second_elem, divisor)\n    ).named(\"condition\")\n\n    # Divide each element by the divisor if the condition is met, otherwise return the original element\n    result = rasp.SequenceMap(\n        lambda x, y, z: x / z if y == 1 else x,\n        rasp.tokens,\n        condition,\n        divisor\n    ).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            }
        ],
        "make_set_to_index": [
            {
                "generated rasp code": "def make_set_to_index() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP SOp that transforms any input sequence into a sequence\n    where each element is replaced by its index in the sequence.\n    \n    Returns:\n    rasp.SOp: An operation that, when applied to a sequence, returns a new\n              sequence where each element is its index in the original sequence.\n    \n    Example:\n    set_to_index = make_set_to_index()\n    set_to_index([9, 8, 7, 6]) # returns [0, 1, 2, 3]\n    \"\"\"\n    return rasp.indices.named(\"set_to_index\")",
                "failure stage": 3,
                "error": "Expression indices cannot be translated to a model component."
            },
            {
                "generated rasp code": "def make_set_to_index() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that sets elements to their index value.\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that transforms any input sequence \n              into a sequence of indices.\n    \n    Example:\n    set_to_index = make_set_to_index()\n    set_to_index([9, 8, 7, 6]) # returns [0, 1, 2, 3]\n    \"\"\"\n    # Simply return rasp.indices, which already provides the index for each element\n    return rasp.indices.named(\"set_to_index\")",
                "failure stage": 3,
                "error": "Expression indices cannot be translated to a model component."
            },
            {
                "generated rasp code": "def make_set_to_index() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that sets each element to its index value.\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that transforms any input sequence\n              into a sequence where each element is its index.\n    \n    Example:\n    set_to_index = make_set_to_index()\n    set_to_index([9, 8, 7, 6]) # returns [0, 1, 2, 3]\n    \"\"\"\n    return rasp.indices.named(\"set_to_index\")",
                "failure stage": 3,
                "error": "Expression indices cannot be translated to a model component."
            },
            {
                "generated rasp code": "def make_set_to_index() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that sets elements to their index value.\n    \n    Returns:\n    rasp.SOp: A sequence operation that transforms any input sequence into \n              a sequence where each element is equal to its index.\n    \n    Example:\n    set_to_index = make_set_to_index()\n    set_to_index([9, 8, 7, 6]) # returns [0, 1, 2, 3]\n    \"\"\"\n    # Simply return the rasp.indices SOp, which already provides the index of each element\n    return rasp.indices.named(\"set_to_index\")",
                "failure stage": 3,
                "error": "Expression indices cannot be translated to a model component."
            },
            {
                "generated rasp code": "def make_set_to_index() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that sets elements to their index value.\n    \n    Returns:\n    rasp.SOp: A sequence operation that transforms any input sequence into \n              a sequence of indices.\n    \n    Example:\n    set_to_index = make_set_to_index()\n    set_to_index([9, 8, 7, 6]) # returns [0, 1, 2, 3]\n    \"\"\"\n    # rasp.indices is a built-in SOp that returns the indices of the input sequence\n    return rasp.indices.named(\"set_to_index\")",
                "failure stage": 3,
                "error": "Expression indices cannot be translated to a model component."
            }
        ],
        "make_check_multiple_of_n": [
            {
                "generated rasp code": "def make_check_multiple_of_n(n: int = 2) -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that checks if all elements in a sequence are multiples of n.\n    \n    Args:\n    n (int): The number to check divisibility against. Default is 2.\n    \n    Returns:\n    rasp.SOp: A RASP program that outputs 1s if all elements are multiples of n, 0s otherwise.\n    \"\"\"\n    # Check if each element is divisible by n\n    divisibility_check = rasp.Map(lambda x: x % n == 0, rasp.tokens).named(\"divisibility_check\")\n    \n    # Create a selector that is True for all elements if they all pass the divisibility check\n    all_true_selector = rasp.Select(divisibility_check, divisibility_check, rasp.Comparison.EQ).named(\"all_true_selector\")\n    \n    # Count the number of True values in each row of the selector\n    true_count = rasp.SelectorWidth(all_true_selector).named(\"true_count\")\n    \n    # Create a sequence of the input length\n    length = rasp.Map(lambda x: 1, rasp.tokens).named(\"length\")\n    sequence_length = rasp.SelectorWidth(rasp.Select(length, length, rasp.Comparison.TRUE)).named(\"sequence_length\")\n    \n    # Check if the true_count equals the sequence length\n    all_multiple_selector = rasp.Select(true_count, sequence_length, rasp.Comparison.EQ).named(\"all_multiple_selector\")\n    \n    # Convert the final boolean result to 1s and 0s\n    result = rasp.Map(lambda x: 1 if x else 0, all_multiple_selector).named(\"result\")\n    \n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_length() -> rasp.SOp:\n    \"\"\"Creates an SOp that returns the length of the input sequence for each position.\"\"\"\n    all_true_selector = rasp.Select(\n        rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\ndef make_check_multiple_of_n(n: int = 2) -> rasp.SOp:\n    \"\"\"\n    Creates an SOp that checks if all elements in a sequence are multiples of n.\n    Returns a sequence of 1s if true, 0s otherwise.\n    \n    Args:\n    n (int): The number to check multiples of. Default is 2.\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that performs the check.\n    \"\"\"\n    # Check if each element is divisible by n\n    divisible_check = rasp.Map(lambda x: x % n, rasp.tokens).named(\"divisible_check\")\n    \n    # Create a selector for elements that are divisible by n (remainder is 0)\n    divisible_selector = rasp.Select(divisible_check, rasp.Map(lambda x: 0, rasp.tokens), rasp.Comparison.EQ).named(\"divisible_selector\")\n    \n    # Count how many elements are divisible by n\n    divisible_count = rasp.SelectorWidth(divisible_selector).named(\"divisible_count\")\n    \n    # Get the length of the sequence\n    length = make_length()\n    \n    # Check if the count of divisible elements equals the length of the sequence\n    all_divisible = rasp.Select(divisible_count, length, rasp.Comparison.EQ).named(\"all_divisible\")\n    \n    # Convert the boolean result to 1s and 0s\n    return rasp.Map(lambda x: 1 if x else 0, all_divisible).named(\"check_multiple_of_n\")",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_length() -> rasp.SOp:\n    \"\"\"Creates an SOp that returns the length of the input sequence for each position.\"\"\"\n    all_true_selector = rasp.Select(\n        rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\ndef make_check_multiple_of_n(n: int = 2) -> rasp.SOp:\n    \"\"\"\n    Creates an SOp that checks if all elements in a sequence are multiples of n.\n    \n    Args:\n    n (int): The number to check divisibility against. Default is 2.\n    \n    Returns:\n    rasp.SOp: An SOp that outputs 1 for each position if all elements are multiples of n, 0 otherwise.\n    \"\"\"\n    # Check if each element is divisible by n\n    divisible_check = rasp.Map(lambda x: x % n == 0, rasp.tokens).named(\"divisible_check\")\n    \n    # Create a selector where each element is True (1)\n    all_true_selector = rasp.Select(divisible_check, divisible_check, rasp.Comparison.EQ).named(\"all_true_selector\")\n    \n    # Count the number of True values in each row\n    true_count = rasp.SelectorWidth(all_true_selector).named(\"true_count\")\n    \n    # Get the length of the sequence\n    length = make_length()\n    \n    # Check if the count of True values equals the length of the sequence\n    all_divisible = rasp.Select(true_count, length, rasp.Comparison.EQ).named(\"all_divisible\")\n    \n    # Convert the final boolean selector to 1s and 0s\n    return rasp.Map(lambda x: 1 if x else 0, all_divisible).named(\"check_multiple_of_n\")",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_length() -> rasp.SOp:\n    \"\"\"Creates an SOp that returns the length of the input sequence for each element.\"\"\"\n    all_true_selector = rasp.Select(\n        rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\ndef make_check_multiple_of_n(n: int = 2) -> rasp.SOp:\n    \"\"\"\n    Creates an SOp that checks if all elements in a sequence are multiples of n.\n    Returns a sequence of 1s if true, 0s otherwise.\n    \n    Args:\n    n (int): The number to check divisibility against. Default is 2.\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that performs the check.\n    \"\"\"\n    # Check if each element is divisible by n\n    divisibility_check = rasp.Map(lambda x: x % n == 0, rasp.tokens).named(\"divisibility_check\")\n    \n    # Create a selector of all True values\n    all_true = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true\")\n    \n    # Compare divisibility check with all True values\n    all_divisible_selector = rasp.Select(divisibility_check, all_true, rasp.Comparison.EQ).named(\"all_divisible_selector\")\n    \n    # Count the number of True values\n    true_count = rasp.SelectorWidth(all_divisible_selector).named(\"true_count\")\n    \n    # Get the length of the sequence\n    length = make_length()\n    \n    # Compare true_count with length\n    all_divisible = rasp.Select(true_count, length, rasp.Comparison.EQ).named(\"all_divisible\")\n    \n    # Convert final selector to 1s and 0s\n    return rasp.Map(lambda x: 1 if x else 0, all_divisible).named(\"check_multiple_of_n\")",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_check_multiple_of_n(n: int = 2) -> rasp.SOp:\n    def check_multiple_of_n() -> rasp.SOp:\n        # Check if each element is divisible by n\n        divisibility_check = rasp.Map(lambda x: x % n == 0, rasp.tokens).named(\"divisibility_check\")\n\n        # Create a sequence of all True values\n        all_true = rasp.Map(lambda x: True, rasp.tokens).named(\"all_true\")\n\n        # Compare divisibility check with all True values\n        all_multiples_selector = rasp.Select(divisibility_check, all_true, rasp.Comparison.EQ).named(\"all_multiples_selector\")\n\n        # Count the number of True values in each row\n        true_count = rasp.SelectorWidth(all_multiples_selector).named(\"true_count\")\n\n        # Get the length of the sequence\n        length = rasp.SelectorWidth(rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE)).named(\"length\")\n\n        # Check if true_count equals length\n        all_multiples = rasp.Select(true_count, length, rasp.Comparison.EQ).named(\"all_multiples\")\n\n        # Convert final result to 1s and 0s\n        return rasp.Map(lambda x: 1 if x else 0, all_multiples).named(\"check_multiple_of_n\")\n\n    return check_multiple_of_n()",
                "failure stage": 0,
                "error": ""
            }
        ],
        "make_swap_first_last": [
            {
                "generated rasp code": "def make_length() -> rasp.SOp:\n    \"\"\"Creates the `length` SOp using selector width primitive.\"\"\"\n    all_true_selector = rasp.Select(\n        rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\ndef make_swap_first_last() -> rasp.SOp:\n    \"\"\"\n    Creates an SOp that swaps the first and last elements of a sequence.\n    If the sequence has only one element, it returns the original sequence.\n    \"\"\"\n    # Get the length of the sequence\n    length = make_length()\n\n    # Create a selector for the first element\n    first_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == 0).named(\"first_selector\")\n\n    # Create a selector for the last element\n    last_selector = rasp.Select(rasp.indices, length, lambda x, y: x == y - 1).named(\"last_selector\")\n\n    # Get the first element and broadcast it\n    first_element = rasp.Aggregate(first_selector, rasp.tokens, default=None).named(\"first_element\")\n\n    # Get the last element and broadcast it\n    last_element = rasp.Aggregate(last_selector, rasp.tokens, default=None).named(\"last_element\")\n\n    # Create a selector for all elements except first and last\n    middle_selector = rasp.Select(rasp.indices, length, lambda x, y: 0 < x < y - 1).named(\"middle_selector\")\n\n    # Get the middle elements\n    middle_elements = rasp.Aggregate(middle_selector, rasp.tokens, default=None).named(\"middle_elements\")\n\n    # Combine the swapped elements with the middle elements\n    swapped_sequence = rasp.SequenceMap(\n        lambda last, middle, first: last if middle is None else (middle if first is None else first),\n        last_element,\n        middle_elements,\n        first_element\n    ).named(\"swapped_sequence\")\n\n    return swapped_sequence",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            },
            {
                "generated rasp code": "def make_swap_first_last() -> rasp.SOp:\n    # Create a selector for the first element\n    first_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == 0).named(\"first_selector\")\n    \n    # Create a selector for the last element\n    def last_element_selector(x, y):\n        return x == y - 1\n    last_selector = rasp.Select(rasp.indices, make_length(), last_element_selector).named(\"last_selector\")\n    \n    # Get the first and last elements\n    first_element = rasp.Aggregate(first_selector, rasp.tokens).named(\"first_element\")\n    last_element = rasp.Aggregate(last_selector, rasp.tokens).named(\"last_element\")\n    \n    # Create a selector for all elements except first and last\n    middle_selector = rasp.Select(rasp.indices, make_length(), lambda x, y: 0 < x < y - 1).named(\"middle_selector\")\n    \n    # Get the middle elements\n    middle_elements = rasp.Aggregate(middle_selector, rasp.tokens).named(\"middle_elements\")\n    \n    # Create a selector for sequences of length greater than 1\n    length_gt_one_selector = rasp.Select(make_length(), rasp.Map(lambda x: 1, rasp.indices), rasp.Comparison.GT).named(\"length_gt_one_selector\")\n    \n    # Combine the swapped elements with the middle elements\n    swapped_sequence = rasp.SequenceMap(\n        lambda x, y, z: z * (y if x == 0 else (x if y is None else z)),\n        last_element,\n        middle_elements,\n        first_element\n    ).named(\"swapped_sequence\")\n    \n    # Choose between the swapped sequence and the original sequence based on length\n    result = rasp.SequenceMap(\n        lambda x, y, z: y if z else x,\n        rasp.tokens,\n        swapped_sequence,\n        length_gt_one_selector\n    ).named(\"result\")\n    \n    return result\n\ndef make_length() -> rasp.SOp:\n    all_true_selector = rasp.Select(\n        rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    return rasp.SelectorWidth(all_true_selector).named(\"length\")",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            },
            {
                "generated rasp code": "def make_length() -> rasp.SOp:\n    \"\"\"Creates the `length` SOp using selector width primitive.\"\"\"\n    all_true_selector = rasp.Select(\n        rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\ndef make_swap_first_last() -> rasp.SOp:\n    \"\"\"\n    Creates an SOp that swaps the first and last elements of a sequence.\n    If the sequence has only one element, it returns the original sequence.\n    \"\"\"\n    # Calculate the length of the sequence\n    length = make_length()\n\n    # Create a selector for the first element\n    first_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == 0).named(\"first_selector\")\n\n    # Create a selector for the last element\n    last_selector = rasp.Select(rasp.indices, length, lambda x, y: x == y - 1).named(\"last_selector\")\n\n    # Get the first element and broadcast it across the sequence\n    first_element = rasp.Aggregate(first_selector, rasp.tokens, default=None).named(\"first_element\")\n\n    # Get the last element and broadcast it across the sequence\n    last_element = rasp.Aggregate(last_selector, rasp.tokens, default=None).named(\"last_element\")\n\n    # Create a selector for all elements except the first and last\n    middle_selector = rasp.Select(rasp.indices, length, lambda x, y: 0 < x < y - 1).named(\"middle_selector\")\n\n    # Get the middle elements\n    middle_elements = rasp.Aggregate(middle_selector, rasp.tokens, default=None).named(\"middle_elements\")\n\n    # Combine the swapped elements with the middle elements\n    swapped_sequence = rasp.SequenceMap(\n        lambda last, mid, first: last if mid is None else (mid if first is None else first),\n        last_element,\n        middle_elements,\n        first_element\n    ).named(\"swapped_sequence\")\n\n    # Handle sequences of length 1 or 2\n    return rasp.SequenceMap(\n        lambda x, y: x if y <= 2 else y,\n        rasp.tokens,\n        length,\n        swapped_sequence\n    ).named(\"swap_first_last\")",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            },
            {
                "generated rasp code": "def make_length() -> rasp.SOp:\n    \"\"\"Creates the `length` SOp using selector width primitive.\"\"\"\n    all_true_selector = rasp.Select(\n        rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\ndef make_swap_first_last() -> rasp.SOp:\n    \"\"\"\n    Creates an SOp that swaps the first and last elements of a sequence.\n    If the sequence has only one element, it returns the original sequence.\n    \"\"\"\n    # Get the length of the sequence\n    length = make_length()\n\n    # Create a selector for the first element\n    first_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == 0).named(\"first_selector\")\n\n    # Create a selector for the last element\n    last_selector = rasp.Select(rasp.indices, length, lambda x, y: x == y - 1).named(\"last_selector\")\n\n    # Get the first element and broadcast it across the sequence\n    first_element = rasp.Aggregate(first_selector, rasp.tokens).named(\"first_element\")\n\n    # Get the last element and broadcast it across the sequence\n    last_element = rasp.Aggregate(last_selector, rasp.tokens).named(\"last_element\")\n\n    # Create a selector for all elements except the first and last\n    middle_selector = rasp.Select(rasp.indices, length, lambda x, y: 0 < x < y - 1).named(\"middle_selector\")\n\n    # Combine the swapped elements with the middle elements\n    swapped_sequence = rasp.SequenceMap(\n        lambda x, y, z: z if y else (x if z == 0 else y),\n        last_element,\n        rasp.Aggregate(middle_selector, rasp.tokens),\n        rasp.indices\n    ).named(\"swapped_sequence\")\n\n    return swapped_sequence",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            },
            {
                "generated rasp code": "def make_length() -> rasp.SOp:\n    \"\"\"Creates the `length` SOp.\"\"\"\n    all_true_selector = rasp.Select(\n        rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\ndef make_swap_first_last() -> rasp.SOp:\n    \"\"\"\n    Creates an SOp that swaps the first and last elements of a sequence.\n    If the sequence has only one element, it returns the original sequence.\n    \"\"\"\n    # Get the length of the sequence\n    length = make_length()\n\n    # Create a selector for the first element\n    first_selector = rasp.Select(rasp.indices, rasp.tokens, lambda x, y: x == 0).named(\"first_selector\")\n\n    # Create a selector for the last element\n    last_selector = rasp.Select(rasp.indices, length, lambda x, y: x == y - 1).named(\"last_selector\")\n\n    # Get the first element and broadcast it across the sequence\n    first_element = rasp.Aggregate(first_selector, rasp.tokens, default=None).named(\"first_element\")\n\n    # Get the last element and broadcast it across the sequence\n    last_element = rasp.Aggregate(last_selector, rasp.tokens, default=None).named(\"last_element\")\n\n    # Create a selector for all elements except the first and last\n    middle_selector = rasp.Select(rasp.indices, length, lambda x, y: 0 < x < y - 1).named(\"middle_selector\")\n\n    # Combine the swapped elements with the middle elements\n    swapped_sequence = rasp.SequenceMap(\n        lambda last, mid, first: last if mid == 0 else (first if mid == length - 1 else rasp.tokens),\n        last_element,\n        rasp.indices,\n        first_element\n    ).named(\"swapped_sequence\")\n\n    return swapped_sequence",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            }
        ],
        "make_test_at_least_two_equal": [
            {
                "generated rasp code": "def make_test_at_least_two_equal() -> rasp.SOp:\n    # Selector that creates a comparison matrix where each element is compared to every other element for equality.\n    eq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.EQ).named(\"eq_selector\")\n\n    # Count the number of comparisons where each element is equal to other elements (including itself).\n    eq_count = rasp.SelectorWidth(eq_selector).named(\"eq_count\")\n\n    # Subtract 1 from each count to exclude self-comparisons.\n    adjusted_count = rasp.Map(lambda x: x - 1, eq_count).named(\"adjusted_count\")\n\n    # Create a selector that checks if any adjusted count is greater than 0.\n    has_equal_selector = rasp.Select(adjusted_count, rasp.Map(lambda x: 0, rasp.tokens), rasp.Comparison.GT).named(\"has_equal_selector\")\n\n    # Use Aggregate to broadcast the result across the entire sequence.\n    result_bool = rasp.Aggregate(has_equal_selector, rasp.Map(lambda x: True, rasp.tokens), default=None).named(\"result_bool\")\n\n    # Convert the boolean result to integer (1 for True, 0 for False).\n    result = rasp.Map(lambda x: 1 if x else 0, result_bool).named(\"result\")\n\n    return result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, None, None, None, None, None]. (0.38 error rate)"
            }
        ],
        "make_reflect": [],
        "make_check_square": [
            {
                "generated rasp code": "def make_check_square() -> rasp.SOp:\n    # Find the maximum value in the input sequence\n    max_value = make_max_element()\n\n    # Create a sequence of integers from 1 to the square root of the max value\n    sqrt_sequence = rasp.Map(lambda x: x + 1, rasp.indices).named(\"sqrt_sequence\")\n\n    # Create a sequence of perfect squares\n    perfect_squares = rasp.Map(lambda x: x * x, sqrt_sequence).named(\"perfect_squares\")\n\n    # Check if each input element exists in the perfect squares sequence\n    is_square_selector = rasp.Select(rasp.tokens, perfect_squares, rasp.Comparison.EQ).named(\"is_square_selector\")\n\n    # Count the number of matches (will be 0 or 1)\n    is_square_count = rasp.SelectorWidth(is_square_selector).named(\"is_square_count\")\n\n    # Convert count to 0 or 1\n    return rasp.Map(lambda x: 1 if x > 0 else 0, is_square_count).named(\"check_square\")\n\n# Helper function to find the maximum element\ndef make_max_element() -> rasp.SOp:\n    # Selector comparing each element with every other element using LEQ\n    leq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LEQ).named(\"leq_selector\")\n    \n    # Counting the number of elements each element is less than or equal to\n    leq_count = rasp.SelectorWidth(leq_selector).named(\"leq_count\")\n    \n    # Get the length of the sequence\n    length = make_length()\n    \n    # The maximum element is the one that is less or equal to all elements (count equal to sequence length)\n    max_element_selector = rasp.Select(leq_count, length, rasp.Comparison.EQ).named(\"max_element_selector\")\n    \n    # Using Aggregate to select the maximum element and broadcast it across the entire sequence\n    return rasp.Aggregate(max_element_selector, rasp.tokens).named(\"max_element\")\n\n# Helper function to get the length of the sequence\ndef make_length() -> rasp.SOp:\n    all_true_selector = rasp.Select(\n        rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    return rasp.SelectorWidth(all_true_selector).named(\"length\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [1, 1, 0, 0, 0, 0]. (0.779 error rate)"
            },
            {
                "generated rasp code": "def make_check_square(max_check=10) -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that checks if each number in the input sequence is a square number.\n    \n    Args:\n    max_check (int): The maximum square root to check. Default is 10, which can verify square numbers up to 100.\n    \n    Returns:\n    rasp.SOp: A RASP program that outputs 1 for square numbers and 0 for non-square numbers.\n    \"\"\"\n    # Create a sequence of integers from 0 to max_check\n    check_sequence = rasp.Map(lambda x: x, rasp.indices).named(\"check_sequence\")\n    \n    # Square each number in the check sequence\n    squared_sequence = rasp.SequenceMap(lambda x, y: x * x, check_sequence, check_sequence).named(\"squared_sequence\")\n    \n    # Compare each squared number with each input number\n    is_square_selector = rasp.Select(squared_sequence, rasp.tokens, rasp.Comparison.EQ).named(\"is_square_selector\")\n    \n    # Count how many matches each input number has\n    match_count = rasp.SelectorWidth(is_square_selector).named(\"match_count\")\n    \n    # Convert the count to 1 if it's greater than 0 (square number), and 0 otherwise\n    is_square = rasp.Map(lambda x: 1 if x > 0 else 0, match_count).named(\"is_square\")\n    \n    return is_square",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0, 0, 0, 1, 0, 1]. (0.083 error rate)"
            },
            {
                "generated rasp code": "def make_check_square() -> rasp.SOp:\n    # Create a sequence of integers from 0 to the maximum value in the input\n    max_value = rasp.Aggregate(rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE), rasp.tokens).named(\"max_value\")\n    integer_sequence = rasp.Map(lambda x: x, rasp.indices).named(\"integer_sequence\")\n    \n    # Create a sequence of perfect squares\n    squares = rasp.SequenceMap(lambda x, y: x * x, integer_sequence, integer_sequence).named(\"squares\")\n    \n    # Check if each input element exists in the sequence of squares\n    is_square_selector = rasp.Select(rasp.tokens, squares, rasp.Comparison.EQ).named(\"is_square_selector\")\n    \n    # Count the number of matches (will be 0 or 1)\n    match_count = rasp.SelectorWidth(is_square_selector).named(\"match_count\")\n    \n    # Map to 1 if there's a match (element is a perfect square), 0 otherwise\n    return rasp.Map(lambda x: 1 if x > 0 else 0, match_count).named(\"is_square\")\n\n# The function can be called as:\n# check_square = make_check_square()",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0, 1, 1, 0, 0, 0]. (0.757 error rate)"
            }
        ],
        "make_count_prime_factors": [
            {
                "generated rasp code": "def make_count_prime_factors(max_prime=100) -> rasp.SOp:\n    def make_primes_up_to_n():\n        # Generate a sequence of booleans where True indicates a prime number\n        is_prime = rasp.Map(lambda x: x > 1, rasp.indices).named(\"is_prime\")\n        \n        for i in range(2, int(max_prime**0.5) + 1):\n            # Create a selector for multiples of i\n            multiple_selector = rasp.Select(\n                rasp.indices, rasp.indices,\n                lambda x, y: x != 0 and y != 0 and x % y == 0 and x != y\n            ).named(f\"multiple_selector_{i}\")\n            \n            # Set multiples of i to False in is_prime\n            is_prime = rasp.SequenceMap(\n                lambda x, y: x and not y,\n                is_prime,\n                rasp.SelectorWidth(multiple_selector)\n            ).named(f\"is_prime_{i}\")\n        \n        # Create a sequence of prime numbers\n        primes = rasp.SequenceMap(\n            lambda x, y: y if x else 0,\n            is_prime,\n            rasp.indices\n        ).named(\"primes\")\n        \n        return primes\n\n    primes = make_primes_up_to_n()\n\n    def count_prime_factors(n):\n        # Count how many times each prime divides n\n        factor_counts = rasp.SequenceMap(\n            lambda p, n: 0 if p == 0 else (n // (p ** (n // p))) % p == 0,\n            primes,\n            rasp.Map(lambda x: n, rasp.indices)\n        ).named(\"factor_counts\")\n        \n        # Sum the factor counts\n        return rasp.SelectorWidth(\n            rasp.Select(factor_counts, factor_counts, lambda x, y: x > 0)\n        ).named(\"prime_factor_count\")\n\n    # Apply count_prime_factors to each element in the input sequence\n    return rasp.SequenceMap(\n        lambda x, y: y,\n        rasp.tokens,\n        rasp.Map(count_prime_factors, rasp.tokens)\n    ).named(\"count_prime_factors\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, None, None, None, None, None]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_count_prime_factors(max_factor=20) -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that counts the number of prime factors for each element in the input sequence.\n    \n    Args:\n    max_factor (int): The maximum factor to consider when counting prime factors. Default is 20.\n    \n    Returns:\n    rasp.SOp: A RASP program that counts prime factors.\n    \"\"\"\n    \n    # Generate a sequence of numbers from 2 to max_factor\n    numbers = rasp.SequenceMap(lambda x, y: y + 2, rasp.tokens, rasp.indices).named(\"numbers\")\n    \n    # Create a selector for prime numbers\n    is_prime = rasp.Select(numbers, numbers, lambda x, y: (y % x != 0) | (x == y)).named(\"is_prime\")\n    primes = rasp.Aggregate(is_prime, numbers).named(\"primes\")\n    \n    # Create a selector for factors\n    is_factor = rasp.Select(primes, rasp.tokens, lambda x, y: (y % x == 0) & (x <= y)).named(\"is_factor\")\n    \n    # Count the number of prime factors\n    factor_count = rasp.SelectorWidth(is_factor).named(\"factor_count\")\n    \n    return factor_count\n\n# Example usage:\n# count_prime_factors = make_count_prime_factors()\n# result = count_prime_factors([2, 4, 6])  # Should return [1, 1, 2]",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0, 0, 0, 0, 1, 0]. (0.937 error rate)"
            },
            {
                "generated rasp code": "def make_count_prime_factors() -> rasp.SOp:\n    def count_prime_factors(n):\n        \"\"\"Helper function to count the number of prime factors for a given number.\"\"\"\n        if n < 2:\n            return 0\n        count = 0\n        d = 2\n        while n > 1:\n            while n % d == 0:\n                count += 1\n                n //= d\n            d += 1\n            if d * d > n:\n                if n > 1:\n                    count += 1\n                break\n        return count\n\n    # Apply the count_prime_factors function to each element in the input sequence\n    return rasp.Map(count_prime_factors, rasp.tokens).named(\"count_prime_factors\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [1, 3, 1, 0, 1, 2]. (0.761 error rate)"
            },
            {
                "generated rasp code": "def make_count_prime_factors(max_number=100):\n    \"\"\"\n    Creates a RASP program that counts the number of prime factors for each element in the input sequence.\n    \n    Args:\n    max_number (int): The maximum number that can be handled by this function. Default is 100.\n    \n    Returns:\n    rasp.SOp: A RASP program that counts prime factors.\n    \"\"\"\n    \n    # Helper function to create a sequence of numbers from 2 to max_number\n    def make_factor_sequence():\n        return rasp.Map(lambda x: x + 2, rasp.indices).named(\"factor_sequence\")\n    \n    # Create the factor sequence\n    factor_sequence = make_factor_sequence()\n    \n    # Helper function to check if a number is divisible by another\n    def is_divisible(x, y):\n        return (x % y == 0) and (x != 0)\n    \n    # Create a selector for factors\n    factor_selector = rasp.Select(rasp.tokens, factor_sequence, is_divisible).named(\"factor_selector\")\n    \n    # Count the number of factors\n    factor_count = rasp.SelectorWidth(factor_selector).named(\"factor_count\")\n    \n    # Helper function to check if a number is prime\n    def is_prime(x):\n        return (x > 1) and (factor_count(x) == 1)\n    \n    # Create a selector for prime factors\n    prime_factor_selector = rasp.Select(factor_sequence, factor_sequence, is_prime).named(\"prime_factor_selector\")\n    \n    # Count the number of prime factors\n    prime_factor_count = rasp.SelectorWidth(\n        rasp.Select(factor_selector, prime_factor_selector, rasp.Comparison.EQ)\n    ).named(\"prime_factor_count\")\n    \n    return prime_factor_count\n\n# Example usage:\n# count_prime_factors = make_count_prime_factors()\n# result = count_prime_factors([2, 4, 6, 8, 9, 10])\n# This would return [1, 1, 2, 1, 1, 2]",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_count_prime_factors(max_num=100) -> rasp.SOp:\n    # Generate a sequence of numbers from 2 to max_num\n    numbers = rasp.SequenceMap(lambda x, y: y + 2, rasp.tokens, rasp.indices).named(\"numbers\")\n\n    # Create a selector for prime numbers\n    is_divisible = rasp.Select(numbers, numbers, lambda x, y: x % y == 0 and x != y).named(\"is_divisible\")\n    is_prime = ~rasp.Select(rasp.SelectorWidth(is_divisible), rasp.tokens, rasp.Comparison.GT).named(\"is_prime\")\n\n    # Create a selector for prime factors\n    is_factor = rasp.Select(rasp.tokens, numbers, lambda x, y: x % y == 0 and x >= y).named(\"is_factor\")\n    is_prime_factor = is_factor & is_prime\n\n    # Count the number of prime factors\n    prime_factor_count = rasp.SelectorWidth(is_prime_factor).named(\"prime_factor_count\")\n\n    return prime_factor_count\n\n# Example usage:\n# count_prime_factors = make_count_prime_factors()\n# result = count_prime_factors([2, 4, 6, 8, 12, 18])",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3, 1, 2, 1, 0, 0]. (0.901 error rate)"
            }
        ],
        "make_zero_if_less_than_previous": [
            {
                "generated rasp code": "def make_zero_if_less_than_previous() -> rasp.SOp:\n    # Define shift_by function\n    def shift_by(offset: int, /, sop: rasp.SOp, fill: rasp.Value) -> rasp.SOp:\n        \"\"\"Returns the sop, shifted by `offset`, filled with `fill` value.\"\"\"\n        select_off_by_offset = rasp.Select(rasp.indices, rasp.indices,\n                                           lambda k, q: q == k + offset)\n        out = rasp.Aggregate(select_off_by_offset, sop, default=fill)\n        return out.named(f\"shift_by({offset})\")\n\n    # Find the minimum value of the input sequence\n    min_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LEQ).named(\"min_selector\")\n    min_value = rasp.Aggregate(min_selector, rasp.tokens).named(\"min_value\")\n\n    # Shift the input sequence by 1, using the minimum value as fill\n    shifted_sequence = shift_by(1, rasp.tokens, min_value).named(\"shifted_sequence\")\n\n    # Create a selector that compares each element with its previous element\n    comparison_selector = rasp.Select(rasp.tokens, shifted_sequence, rasp.Comparison.GEQ).named(\"comparison_selector\")\n\n    # Apply the zero-setting logic based on the selector\n    result = rasp.SequenceMap(\n        lambda x, sel: x if sel else 0,\n        rasp.tokens,\n        comparison_selector\n    ).named(\"zero_if_less_than_previous\")\n\n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_zero_if_less_than_previous() -> rasp.SOp:\n    # Create a selector to shift the sequence by 1 position\n    shift_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y + 1).named(\"shift_selector\")\n    \n    # Create a shifted version of the input sequence\n    shifted_sequence = rasp.Aggregate(shift_selector, rasp.tokens, default=None).named(\"shifted_sequence\")\n    \n    # Compare each element with its previous element\n    comparison = rasp.SequenceMap(\n        lambda x, y: x < y if y is not None else False,\n        rasp.tokens,\n        shifted_sequence\n    ).named(\"comparison\")\n    \n    # Create a selector for elements less than their previous element\n    less_than_prev_selector = rasp.Select(comparison, comparison, lambda x, y: x).named(\"less_than_prev_selector\")\n    \n    # Set selected elements to zero, keep others unchanged\n    result = rasp.SequenceMap(\n        lambda x, y: 0 if y else x,\n        rasp.tokens,\n        less_than_prev_selector\n    ).named(\"result\")\n    \n    return result\n\n# Example usage:\n# zero_if_less = make_zero_if_less_than_previous()\n# zero_if_less([1, 3, 2, 4, 1, 5])  # returns [1, 3, 0, 4, 0, 5]",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def shift_by(offset: int, sop: rasp.SOp, fill: rasp.Value) -> rasp.SOp:\n    \"\"\"Returns the sop, shifted by `offset`, filled with `fill` value.\"\"\"\n    select_off_by_offset = rasp.Select(rasp.indices, rasp.indices,\n                                       lambda k, q: q == k + offset)\n    out = rasp.Aggregate(select_off_by_offset, sop, default=fill)\n    return out.named(f\"shift_by({offset})\")\n\ndef make_zero_if_less_than_previous() -> rasp.SOp:\n    # Create a shifted version of the input sequence\n    shifted_sequence = shift_by(1, rasp.tokens, fill=None).named(\"shifted_sequence\")\n    \n    # Create a selector that identifies elements less than their previous element\n    less_than_previous_selector = rasp.Select(\n        rasp.tokens, \n        shifted_sequence, \n        lambda x, y: x < y if y is not None else False\n    ).named(\"less_than_previous_selector\")\n    \n    # Use SequenceMap to set elements to zero where the selector is True\n    zero_if_less = rasp.SequenceMap(\n        lambda x, y: 0 if y else x,\n        rasp.tokens,\n        less_than_previous_selector\n    ).named(\"zero_if_less\")\n    \n    return zero_if_less",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_zero_if_less_than_previous() -> rasp.SOp:\n    # Create a shifted version of the input sequence\n    shifted_sequence = rasp.SequenceMap(\n        lambda x, y: y if x > 0 else float('-inf'),\n        rasp.indices,\n        rasp.tokens\n    ).named(\"shifted_sequence\")\n\n    # Create a selector that compares each element with its previous element\n    geq_selector = rasp.Select(\n        rasp.tokens,\n        shifted_sequence,\n        rasp.Comparison.GEQ\n    ).named(\"geq_selector\")\n\n    # Use Aggregate to keep original values where the condition is met, and set to 0 otherwise\n    result = rasp.Aggregate(\n        geq_selector,\n        rasp.tokens,\n        default=None\n    ).named(\"result\")\n\n    # Replace None values (which occur when the condition is not met) with 0\n    return rasp.Map(\n        lambda x: x if x is not None else 0,\n        result\n    ).named(\"zero_if_less_than_previous\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3.8333333333333335, 8.0, 4.4, 3.8333333333333335, 6.5, 5.666666666666667]. (0.888 error rate)"
            },
            {
                "generated rasp code": "def shift_by(offset: int, sop: rasp.SOp, fill: rasp.Value) -> rasp.SOp:\n    \"\"\"Returns the sop, shifted by `offset`, filled with `fill` value.\"\"\"\n    select_off_by_offset = rasp.Select(rasp.indices, rasp.indices,\n                                       lambda k, q: q == k + offset)\n    out = rasp.Aggregate(select_off_by_offset, sop, default=fill)\n    return out.named(f\"shift_by({offset})\")\n\ndef make_zero_if_less_than_previous() -> rasp.SOp:\n    # Create a shifted version of the input sequence\n    shifted = shift_by(-1, rasp.tokens, fill=-1e9).named(\"shifted\")\n    \n    # Compare each element with its previous element\n    comparison = rasp.Select(rasp.tokens, shifted, rasp.Comparison.GEQ).named(\"comparison\")\n    \n    # Create a sequence of zeros\n    zeros = rasp.Map(lambda x: 0, rasp.tokens).named(\"zeros\")\n    \n    # Use the comparison to select between the original value and zero\n    result = rasp.SequenceMap(\n        lambda orig, keep: orig if keep else 0,\n        rasp.tokens,\n        comparison\n    ).named(\"result\")\n    \n    return result",
                "failure stage": 0,
                "error": ""
            }
        ],
        "make_element_subtract_constant": [],
        "make_check_prime": [
            {
                "generated rasp code": "def make_check_prime(max_check=100) -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that checks if each element in a sequence is prime.\n    Args:\n        max_check: The maximum number to check for primality. Default is 100.\n    Returns:\n        A RASP SOp that returns 1 for prime numbers and 0 for non-prime numbers.\n    \"\"\"\n    # Generate a sequence from 2 to max_check\n    divisor_sequence = rasp.Map(lambda x: x + 2, rasp.indices).named(\"divisor_sequence\")\n    \n    # Create a selector for numbers greater than 1 (as 1 is not prime)\n    greater_than_one = rasp.Select(rasp.tokens, rasp.tokens, lambda x, y: x > 1).named(\"greater_than_one\")\n    \n    # Create a selector for positive numbers\n    positive_numbers = rasp.Select(rasp.tokens, rasp.tokens, lambda x, y: x > 0).named(\"positive_numbers\")\n    \n    # Create a selector for numbers less than or equal to max_check\n    less_than_max = rasp.Select(rasp.tokens, rasp.Map(lambda x: max_check, rasp.indices), rasp.Comparison.LEQ).named(\"less_than_max\")\n    \n    # Combine the above conditions\n    valid_numbers = rasp.SequenceMap(lambda x, y: x and y, greater_than_one, positive_numbers).named(\"valid_numbers\")\n    valid_numbers = rasp.SequenceMap(lambda x, y: x and y, valid_numbers, less_than_max).named(\"valid_numbers\")\n    \n    # Create a selector for divisibility check\n    divisibility_check = rasp.Select(rasp.tokens, divisor_sequence, lambda x, y: x != y and x % y == 0 and y * y <= x).named(\"divisibility_check\")\n    \n    # Count the number of divisors\n    divisor_count = rasp.SelectorWidth(divisibility_check).named(\"divisor_count\")\n    \n    # Check if the number is prime (no divisors found)\n    is_prime = rasp.Map(lambda x: 1 if x == 0 else 0, divisor_count).named(\"is_prime\")\n    \n    # Combine the primality check with the valid numbers check\n    result = rasp.SequenceMap(lambda x, y: x * y, is_prime, valid_numbers).named(\"result\")\n    \n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_check_prime(max_divisors=100) -> rasp.SOp:\n    # Create a sequence of potential divisors from 2 to max_divisors\n    divisors = rasp.SequenceMap(lambda x, y: y + 2, rasp.tokens, rasp.indices).named(\"divisors\")\n\n    # Check divisibility: x % y == 0 and y <= x\n    is_divisor = rasp.Select(rasp.tokens, divisors, lambda x, y: x % y == 0 and y <= x).named(\"is_divisor\")\n\n    # Count the number of divisors for each number\n    divisor_count = rasp.SelectorWidth(is_divisor).named(\"divisor_count\")\n\n    # A number is prime if it has exactly 2 divisors (1 and itself)\n    # We also need to handle special cases:\n    # - Numbers less than 2 are not prime\n    # - 2 is prime (it will only have 1 divisor in our count, as we start from 2)\n    def check_prime(x, count):\n        if x < 2:\n            return 0\n        elif x == 2:\n            return 1\n        else:\n            return 1 if count == 1 else 0\n\n    is_prime = rasp.SequenceMap(check_prime, rasp.tokens, divisor_count).named(\"is_prime\")\n\n    return is_prime",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0, 1, 1, 0, 0, 0]. (0.83 error rate)"
            },
            {
                "generated rasp code": "def make_check_prime() -> rasp.SOp:\n    # Create a sequence of indices (potential divisors)\n    indices = rasp.indices.named(\"indices\")\n    \n    # Create a sequence containing the length of the input\n    all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n    length = rasp.SelectorWidth(all_true_selector).named(\"length\")\n    \n    # Create a sequence of potential divisors (from 2 to sqrt(n))\n    potential_divisors = rasp.SequenceMap(lambda i, n: min(i + 2, int(n**0.5) + 1), indices, rasp.tokens).named(\"potential_divisors\")\n    \n    # Check divisibility\n    is_divisible = rasp.Select(\n        rasp.tokens,\n        potential_divisors,\n        lambda n, d: (n % d == 0) if (d >= 2 and d < n) else False\n    ).named(\"is_divisible\")\n    \n    # Count divisors\n    divisor_count = rasp.SelectorWidth(is_divisible).named(\"divisor_count\")\n    \n    # Check if prime (exactly 0 divisors found in our range, excluding 1 and the number itself)\n    is_prime = rasp.SequenceMap(\n        lambda count, n: (count == 0) and (n > 1),\n        divisor_count,\n        rasp.tokens\n    ).named(\"is_prime\")\n    \n    # Convert to 1 for prime, 0 for non-prime\n    return rasp.Map(lambda x: 1 if x else 0, is_prime).named(\"prime_check_result\")",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_check_prime() -> rasp.SOp:\n    # Create a sequence of potential divisors (from 2 to sqrt(n)) for each number\n    sqrt_sequence = rasp.Map(lambda x: int(x**0.5) + 1 if x > 1 else 2, rasp.tokens).named(\"sqrt_sequence\")\n    divisor_sequence = rasp.SequenceMap(\n        lambda x, y: y if y >= 2 and y <= x else None, \n        sqrt_sequence, \n        rasp.indices\n    ).named(\"divisor_sequence\")\n\n    # Check divisibility\n    is_divisible = rasp.Select(\n        rasp.tokens, \n        divisor_sequence, \n        lambda x, y: y is not None and x % y == 0\n    ).named(\"is_divisible\")\n\n    # Count divisors (excluding 1)\n    divisor_count = rasp.SelectorWidth(is_divisible).named(\"divisor_count\")\n\n    # Check if prime (exactly 1 divisor other than 1 and itself)\n    def check_prime(x, count):\n        if x <= 1:\n            return 0  # Numbers less than or equal to 1 are not prime\n        elif count == 1:\n            return 1  # Prime numbers have exactly one divisor (other than 1 and itself)\n        else:\n            return 0  # Not prime\n\n    is_prime = rasp.SequenceMap(check_prime, rasp.tokens, divisor_count).named(\"is_prime\")\n\n    return is_prime\n\n# Example usage:\n# check_prime = make_check_prime()\n# result = check_prime([2, 4, 5, 7, 9, 11])\n# This would return [1, 0, 1, 1, 0, 1]",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0, 0, 0, 0, 0, 0]. (0.853 error rate)"
            },
            {
                "generated rasp code": "def make_check_prime() -> rasp.SOp:\n    def make_length() -> rasp.SOp:\n        all_true_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n        return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n    # Handle edge cases: numbers <= 1 are not prime\n    is_greater_than_one = rasp.Map(lambda x: int(x > 1), rasp.tokens).named(\"is_greater_than_one\")\n\n    # Create a sequence of potential divisors (2 to sqrt(x)) for each number\n    sqrt_tokens = rasp.Map(lambda x: int(x**0.5) + 1, rasp.tokens).named(\"sqrt_tokens\")\n    divisor_range = rasp.SequenceMap(lambda x, y: min(x, y), sqrt_tokens, make_length()).named(\"divisor_range\")\n    potential_divisors = rasp.SequenceMap(\n        lambda x, y: y if y >= 2 and y < x else None,\n        rasp.tokens,\n        rasp.indices\n    ).named(\"potential_divisors\")\n\n    # Check divisibility\n    is_divisible = rasp.Select(\n        rasp.tokens,\n        potential_divisors,\n        lambda x, y: y is not None and x % y == 0\n    ).named(\"is_divisible\")\n\n    # Count divisors\n    divisor_count = rasp.SelectorWidth(is_divisible).named(\"divisor_count\")\n\n    # A number is prime if it's greater than 1 and has no divisors other than 1 and itself\n    is_prime = rasp.SequenceMap(\n        lambda x, y: int(x == 1 and y == 1),\n        is_greater_than_one,\n        divisor_count\n    ).named(\"is_prime\")\n\n    return is_prime",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0, 0, 0, 0, 0, 0]. (0.854 error rate)"
            }
        ],
        "make_index_parity": [
            {
                "generated rasp code": "def make_index_parity() -> rasp.SOp:\n    # Use rasp.Map to apply a parity calculation to each index\n    # The lambda function (x % 2) calculates the remainder when x is divided by 2\n    # This remainder is 0 for even numbers and 1 for odd numbers\n    return rasp.Map(lambda x: x % 2, rasp.indices).named(\"index_parity\")",
                "failure stage": 3,
                "error": "'tokens'"
            },
            {
                "generated rasp code": "def make_index_parity() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that replaces each element with the parity of its index.\n    Returns 0 for even indices and 1 for odd indices.\n    \"\"\"\n    # Use rasp.indices to get the index of each element\n    # Then use rasp.Map to apply the parity function to each index\n    return rasp.Map(lambda x: x % 2, rasp.indices).named(\"index_parity\")",
                "failure stage": 3,
                "error": "'tokens'"
            },
            {
                "generated rasp code": "def make_index_parity() -> rasp.SOp:\n    # Use rasp.Map to apply a parity-checking function to each index\n    return rasp.Map(\n        # Lambda function to check parity:\n        # If index % 2 == 0, it's even (return 0), otherwise it's odd (return 1)\n        lambda x: 0 if x % 2 == 0 else 1,\n        # Use rasp.indices to get the index of each element\n        rasp.indices\n    ).named(\"index_parity\")",
                "failure stage": 3,
                "error": "'tokens'"
            },
            {
                "generated rasp code": "def make_index_parity() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that replaces each element with the parity of its index.\n    0 represents even indices, 1 represents odd indices.\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that transforms input sequences into their index parity representation.\n    \n    Example:\n    index_parity = make_index_parity()\n    index_parity([5, 5, 5, 5]) # returns [0, 1, 0, 1]\n    \"\"\"\n    # Use rasp.indices to get the index of each element\n    # Then use Map to apply a parity function to each index\n    # The parity function returns 0 for even indices (x % 2 == 0) and 1 for odd indices\n    return rasp.Map(lambda x: x % 2, rasp.indices).named(\"index_parity\")",
                "failure stage": 3,
                "error": "'tokens'"
            },
            {
                "generated rasp code": "def make_index_parity() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that replaces each element with the parity of its index.\n    Returns 0 for even indices and 1 for odd indices.\n    \"\"\"\n    # Use rasp.Map to apply a parity function to each index\n    return rasp.Map(lambda x: x % 2, rasp.indices).named(\"index_parity\")",
                "failure stage": 3,
                "error": "'tokens'"
            }
        ]
    }
}