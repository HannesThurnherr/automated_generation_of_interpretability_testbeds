{
    "successes": {
        "make_sum_digits": [
            "def make_sum_digits() -> rasp.SOp:\n    def sum_of_digits(n):\n        \"\"\"Helper function to calculate the sum of digits for a single number.\"\"\"\n        return sum(int(digit) for digit in str(abs(n)))\n\n    # Apply the sum_of_digits function to each element in the input sequence\n    return rasp.Map(sum_of_digits, rasp.tokens).named(\"sum_digits\")"
        ],
        "make_absolute": [
            "def make_absolute() -> rasp.SOp:\n    # Create a selector that identifies negative numbers\n    negative_selector = rasp.Select(rasp.tokens, rasp.Map(lambda x: 0, rasp.tokens), rasp.Comparison.LT).named(\"negative_selector\")\n\n    # Create a sequence where all numbers are positive\n    positive_sequence = rasp.Map(lambda x: -x, rasp.tokens).named(\"positive_sequence\")\n\n    # Combine the original sequence and the positive sequence based on the selector\n    absolute_sequence = rasp.SequenceMap(\n        lambda orig, pos: pos if orig < 0 else orig,\n        rasp.tokens,\n        positive_sequence\n    ).named(\"absolute_sequence\")\n\n    return absolute_sequence"
        ],
        "make_first_element": [
            "def make_first_element() -> rasp.SOp:\n    # Create a selector that selects only the first element (where index is 0)\n    first_element_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: 0, rasp.indices), rasp.Comparison.EQ).named(\"first_element_selector\")\n\n    # Use Aggregate to broadcast the first element across the entire sequence\n    first_element_sequence = rasp.Aggregate(first_element_selector, rasp.tokens).named(\"first_element_sequence\")\n\n    return first_element_sequence"
        ],
        "make_nth_fibonacci": [
            "def make_nth_fibonacci() -> rasp.SOp:\n    # Convert input tokens to integers\n    int_tokens = rasp.Map(lambda x: int(x), rasp.tokens).named(\"int_tokens\")\n\n    # Function to generate the nth Fibonacci number\n    def fib(n):\n        if n <= 0:\n            return 0\n        elif n == 1:\n            return 1\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n\n    # Apply the Fibonacci function to each token\n    fibonacci_sequence = rasp.Map(fib, int_tokens).named(\"fibonacci_sequence\")\n\n    return fibonacci_sequence"
        ],
        "make_count_greater_than": [
            "def make_count_greater_than() -> rasp.SOp:\n    # Create a selector that compares each element with every other element\n    # using the \"Greater Than\" (GT) comparison\n    gt_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.GT).named(\"gt_selector\")\n\n    # Use SelectorWidth to count the number of elements that are greater than each element\n    count_greater = rasp.SelectorWidth(gt_selector).named(\"count_greater\")\n\n    return count_greater"
        ],
        "make_double_first_half": [],
        "make_decrement": [
            "def make_decrement() -> rasp.SOp:\n    # Use Map to apply a decrement operation to each element of the input sequence\n    return rasp.Map(lambda x: x - 1, rasp.tokens).named(\"decrement\")"
        ],
        "make_count_frequency": [
            "def make_count_frequency() -> rasp.SOp:\n    # Create a selector that compares each element with every other element\n    eq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.EQ).named(\"eq_selector\")\n    \n    # Count the number of equal elements for each position\n    frequency_count = rasp.SelectorWidth(eq_selector).named(\"frequency_count\")\n    \n    return frequency_count"
        ],
        "make_increment_by_index": [
            "def make_increment_by_index() -> rasp.SOp:\n    # Use SequenceMap to combine tokens and indices, adding them together\n    return rasp.SequenceMap(\n        lambda token, index: token + index,\n        rasp.tokens,\n        rasp.indices\n    ).named(\"increment_by_index\")"
        ],
        "make_decrement_to_multiple_of_three": [
            "def make_decrement_to_multiple_of_three() -> rasp.SOp:\n    # Calculate the decrement needed for each element to reach a multiple of 3\n    decrement = rasp.Map(lambda x: x % 3, rasp.tokens).named(\"decrement\")\n    \n    # Subtract the decrement from each original element\n    result = rasp.SequenceMap(lambda x, y: x - y, rasp.tokens, decrement).named(\"result\")\n    \n    return result"
        ],
        "make_hyperbolic_cosine": [],
        "make_check_fibonacci": [],
        "make_square_root": [
            "def make_square_root() -> rasp.SOp:\n    # Use Map to apply the square root operation to each element\n    return rasp.Map(\n        lambda x: x ** 0.5 if x >= 0 else None,\n        rasp.tokens\n    ).named(\"square_root\")"
        ],
        "make_increment_odd_indices": [],
        "make_hyperbolic_tangent": [],
        "make_hyperbolic_sine": [],
        "make_zero_every_third": [],
        "make_element_second": [],
        "make_mirror_first_half": [],
        "make_sorting": [
            "def make_sorting() -> rasp.SOp:\n    # Create a selector that compares each element with every other element\n    lt_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LT).named(\"lt_selector\")\n\n    # Count how many elements are less than each element\n    lt_count = rasp.SelectorWidth(lt_selector).named(\"lt_count\")\n\n    # Adjust the count to get the correct index (0-based)\n    sorted_indices = rasp.Map(lambda x: x, lt_count).named(\"sorted_indices\")\n\n    # Create a selector that matches each original position with its new sorted position\n    sorting_selector = rasp.Select(rasp.indices, sorted_indices, rasp.Comparison.EQ).named(\"sorting_selector\")\n\n    # Use Aggregate to move each element to its sorted position\n    sorted_sequence = rasp.Aggregate(sorting_selector, rasp.tokens).named(\"sorted_sequence\")\n\n    return sorted_sequence"
        ],
        "make_increment": [
            "def make_increment() -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that increments each element in the input sequence by 1.\n    \n    Returns:\n        rasp.SOp: A RASP sequence operation that increments each element by 1.\n    \"\"\"\n    # Use Map to apply the increment operation to each element of the input sequence\n    increment_op = rasp.Map(lambda x: x + 1, rasp.tokens).named(\"increment_op\")\n    \n    return increment_op"
        ],
        "make_rank": [
            "def make_rank() -> rasp.SOp:\n    # Create a selector that compares each element with every other element\n    lt_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LT).named(\"lt_selector\")\n\n    # Count the number of elements less than each element\n    lt_count = rasp.SelectorWidth(lt_selector).named(\"lt_count\")\n\n    # Add 1 to the count to get the rank (ranks start from 1)\n    rank = rasp.Map(lambda x: x + 1, lt_count).named(\"rank\")\n\n    return rank"
        ],
        "make_factorial": [],
        "make_count_less_than": [],
        "make_cube_each_element": [
            "def make_cube_each_element() -> rasp.SOp:\n    # Use Map to apply the cubing operation to each element of the input sequence\n    return rasp.Map(lambda x: x**3, rasp.tokens).named(\"cube_each_element\")"
        ],
        "make_cube_root": [
            "def make_cube_root() -> rasp.SOp:\n    # Define the cube root function using pow()\n    def cube_root(x):\n        return pow(x, 1/3)\n    \n    # Apply the cube root function to each element of the input sequence\n    return rasp.Map(cube_root, rasp.tokens).named(\"cube_root\")"
        ],
        "make_round": [
            "def make_round() -> rasp.SOp:\n    # Use Map to apply the round function to each element in the sequence\n    rounded_sequence = rasp.Map(lambda x: round(x), rasp.tokens).named(\"rounded_sequence\")\n    \n    return rounded_sequence"
        ],
        "make_multiply_by_length": [],
        "make_increment_to_multiple_of_three": [
            "def make_increment_to_multiple_of_three() -> rasp.SOp:\n    # Calculate the remainder when each element is divided by 3\n    remainder = rasp.Map(lambda x: x % 3, rasp.tokens).named(\"remainder\")\n    \n    # Calculate how many increments are needed for each element\n    # If remainder is 0, no increment is needed, otherwise 3 - remainder\n    increments_needed = rasp.Map(lambda r: 0 if r == 0 else 3 - r, remainder).named(\"increments_needed\")\n    \n    # Add the increments to the original elements\n    result = rasp.SequenceMap(lambda x, y: x + y, rasp.tokens, increments_needed).named(\"result\")\n    \n    return result"
        ],
        "make_sign": [],
        "make_cosine": [
            "from math import cos\n\ndef make_cosine() -> rasp.SOp:\n    # Apply the cosine function to each element of the input sequence\n    return rasp.Map(lambda x: cos(x), rasp.tokens).named(\"cosine_sequence\")"
        ],
        "make_divide_by_length": [],
        "make_negation": [
            "def make_negation() -> rasp.SOp:\n    # Use Map to apply negation to each element of the input sequence\n    return rasp.Map(lambda x: -x, rasp.tokens).named(\"negation\")"
        ],
        "make_sine": [
            "import math\n\ndef make_sine() -> rasp.SOp:\n    # Apply the sine function to each element of the input sequence\n    return rasp.Map(lambda x: math.sin(x), rasp.tokens).named(\"sine_sequence\")"
        ],
        "make_histogram": [
            "def make_histogram() -> rasp.SOp:\n    # Create a selector that compares each element with every other element\n    equal_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.EQ).named(\"equal_selector\")\n    \n    # Count the number of equal elements for each position\n    # This gives us the frequency of each element, which is our histogram\n    histogram = rasp.SelectorWidth(equal_selector).named(\"histogram\")\n    \n    return histogram"
        ],
        "make_element_double": [
            "def make_element_double() -> rasp.SOp:\n    # Use Map to apply a doubling operation to each element in the sequence\n    return rasp.Map(lambda x: x * 2, rasp.tokens).named(\"double_elements\")"
        ],
        "make_zero_even_indices": [],
        "make_tangent": [],
        "make_count_occurrences": [
            "def make_count_occurrences() -> rasp.SOp:\n    # Create a selector that compares each element with every other element for equality\n    equal_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.EQ).named(\"equal_selector\")\n    \n    # Count the number of equal elements for each element (including itself)\n    occurrence_count = rasp.SelectorWidth(equal_selector).named(\"occurrence_count\")\n    \n    return occurrence_count"
        ],
        "make_compute_median": [],
        "make_halve_second_half": [],
        "make_triple": [
            "def make_triple() -> rasp.SOp:\n    # Use Map to apply a tripling operation to each element of the input sequence\n    return rasp.Map(lambda x: x * 3, rasp.tokens).named(\"triple_sequence\")"
        ],
        "make_arctangent": [
            "import math\n\ndef make_arctangent() -> rasp.SOp:\n    # Apply arctangent function to each element of the input sequence\n    return rasp.Map(\n        lambda x: math.pi / 2 if x == float('inf') else math.atan(x),\n        rasp.tokens\n    ).named(\"arctangent\")"
        ],
        "make_square_each_element": [
            "def make_square_each_element() -> rasp.SOp:\n    # Use Map to apply the squaring operation to each element in the input sequence\n    return rasp.Map(lambda x: x * x, rasp.tokens).named(\"square_each_element\")"
        ],
        "make_check_power_of_n": [],
        "make_binarize": [],
        "make_average_first_last": [],
        "make_check_increasing": [],
        "make_identity": [
            "def make_identity() -> rasp.SOp:\n    # Use Map to apply an identity function (lambda x: x) to each element of the input sequence\n    return rasp.Map(lambda x: x, rasp.tokens).named(\"identity\")"
        ],
        "make_apply_threshold": [],
        "make_replace_small_tokens": [],
        "make_swap_odd_index": [],
        "make_check_descending": [],
        "make_rotate_left": [],
        "make_remove_duplicates": [
            "def make_remove_duplicates() -> rasp.SOp:\n    # Selector that creates a comparison matrix where each element is compared to every other element for equality\n    eq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.EQ).named(\"eq_selector\")\n\n    # Count the number of occurrences of each element\n    occurrence_count = rasp.SelectorWidth(eq_selector).named(\"occurrence_count\")\n\n    # Create the final sequence where duplicates (including first occurrences) are replaced with 0\n    remove_duplicates = rasp.SequenceMap(\n        lambda x, count: 0 if count > 1 else x,\n        rasp.tokens,\n        occurrence_count\n    ).named(\"remove_duplicates\")\n\n    return remove_duplicates"
        ],
        "make_scale_by_max": [],
        "make_sum_with_next": [],
        "make_swap_elements": [],
        "make_one_if_equal_to_next": [],
        "make_swap_consecutive": [],
        "make_check_palindrome": [],
        "make_next_prime": [
            "def make_next_prime() -> rasp.SOp:\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def next_prime(x):\n        if x < 2:\n            return 2\n        if is_prime(x):\n            return x\n        x += 1\n        while not is_prime(x):\n            x += 1\n        return x\n\n    return rasp.Map(lambda x: next_prime(x), rasp.tokens).named(\"next_prime_sequence\")"
        ],
        "make_mask_sequence": [],
        "make_wrap": [],
        "make_alternate_elements": [],
        "make_check_last_two_equal": [],
        "make_insert_zeros": [],
        "make_last_element": [],
        "make_difference_to_next": [],
        "make_invert_if_sorted": [],
        "make_logarithm": [],
        "make_product_with_next": [],
        "make_check_multiple_of_first": [
            "def make_check_multiple_of_first() -> rasp.SOp:\n    # Create a selector for the first element\n    first_elem_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == 0).named(\"first_elem_selector\")\n    \n    # Extract the first element\n    first_elem = rasp.Aggregate(first_elem_selector, rasp.tokens).named(\"first_elem\")\n    \n    # Perform division and check if it's a multiple\n    def check_multiple(x, y):\n        if y == 0:\n            return 0  # Avoid division by zero\n        return 1 if x % y == 0 else 0\n    \n    result = rasp.SequenceMap(check_multiple, rasp.tokens, first_elem).named(\"result\")\n    \n    return result"
        ],
        "make_sum_of_last_two": [],
        "make_pairwise_sum": [],
        "make_polynomial": [],
        "make_flip_halves": [],
        "make_arcsine": [],
        "make_check_divisibility": [
            "def make_check_divisibility(parameter: int = 3) -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that checks if each element in a sequence is divisible by the given parameter.\n    \n    Args:\n    parameter (int): The number to check divisibility against. Default is 3.\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that transforms the input sequence.\n    \"\"\"\n    # Use rasp.Map to apply the divisibility check to each element\n    return rasp.Map(\n        lambda x: 1 if x % parameter == 0 else 0,\n        rasp.tokens\n    ).named(f\"divisibility_check_{parameter}\")\n\n# Example usage:\n# divisibility_checker = make_check_divisibility()\n# result = divisibility_checker([3, 5, 9, 12, 7])  # This would return [1, 0, 1, 1, 0]"
        ],
        "make_arccosine": [],
        "make_check_all_equal": [],
        "make_position": [],
        "make_set_to_median": [],
        "make_swap_min_max": [],
        "make_clip": [
            "def make_clip(lower: float = 2, upper: float = 7) -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that clips each element of the input sequence to be within the specified range.\n    \n    Args:\n    lower (float): The lower bound of the clipping range. Default is 2.\n    upper (float): The upper bound of the clipping range. Default is 7.\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that clips the input sequence.\n    \"\"\"\n    \n    def clip_function(x):\n        return max(lower, min(upper, x))\n    \n    clipped_sequence = rasp.Map(clip_function, rasp.tokens).named(\"clipped_sequence\")\n    \n    return clipped_sequence"
        ],
        "make_pairwise_max": [],
        "make_check_alternating": [],
        "make_exponential": [],
        "make_interleave_reverse": [],
        "make_element_divide": [],
        "make_set_to_index": [],
        "make_check_multiple_of_n": [],
        "make_swap_first_last": [],
        "make_test_at_least_two_equal": [
            "def make_test_at_least_two_equal() -> rasp.SOp:\n    # Create a selector that compares each element with every other element\n    eq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.EQ).named(\"eq_selector\")\n\n    # Count the number of elements each element is equal to (including itself)\n    eq_count = rasp.SelectorWidth(eq_selector).named(\"eq_count\")\n\n    # Create a selector for elements that have at least one equal counterpart\n    has_equal = rasp.Select(eq_count, rasp.Map(lambda x: 1, rasp.tokens), rasp.Comparison.GT).named(\"has_equal\")\n\n    # Count how many elements have at least one equal counterpart\n    equal_elements_count = rasp.SelectorWidth(has_equal).named(\"equal_elements_count\")\n\n    # Convert the count to 1 if > 0 (at least two equal elements), else 0\n    result = rasp.Map(lambda x: 1 if x > 0 else 0, equal_elements_count).named(\"result\")\n\n    return result"
        ],
        "make_reflect": [
            "def make_reflect(lower_bound=2, upper_bound=7):\n    def reflect_value(x):\n        range_size = upper_bound - lower_bound\n        if x < lower_bound:\n            distance = lower_bound - x\n            return lower_bound + (distance % range_size)\n        elif x > upper_bound:\n            distance = x - upper_bound\n            return upper_bound - (distance % range_size)\n        else:\n            return x\n\n    return rasp.Map(reflect_value, rasp.tokens).named(\"reflected_sequence\")"
        ],
        "make_check_square": [],
        "make_count_prime_factors": [
            "def make_count_prime_factors() -> rasp.SOp:\n    def count_prime_factors(n):\n        if n <= 1:\n            return 0\n        \n        count = 0\n        factor = 2\n        while factor * factor <= n:\n            if n % factor == 0:\n                count += 1\n                while n % factor == 0:\n                    n //= factor\n            factor += 1\n        \n        if n > 1:\n            count += 1\n        \n        return count\n\n    return rasp.Map(lambda x: count_prime_factors(x), rasp.tokens).named(\"count_prime_factors\")"
        ],
        "make_zero_if_less_than_previous": [],
        "make_element_subtract_constant": [
            "def make_element_subtract_constant(constant: float = 2) -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that subtracts a constant from each element in the input sequence.\n    \n    Args:\n    constant (float): The value to subtract from each element. Default is 2.\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that subtracts the constant from each element.\n    \"\"\"\n    # Use Map to apply the subtraction operation to each element\n    return rasp.Map(lambda x: x - constant, rasp.tokens).named(\"subtract_constant\")"
        ],
        "make_check_prime": [],
        "make_index_parity": []
    },
    "failures": {
        "make_sum_digits": [],
        "make_absolute": [],
        "make_first_element": [],
        "make_nth_fibonacci": [
            {
                "generated rasp code": "def make_nth_fibonacci(max_length=20):\n    # Generate Fibonacci sequence\n    def fib_generator(x):\n        fib = [1, 1]\n        for _ in range(2, max_length):\n            fib.append(fib[-1] + fib[-2])\n        return fib[min(int(x), max_length-1)]\n\n    fib_sequence = rasp.Map(fib_generator, rasp.indices).named(\"fib_sequence\")\n\n    # Create a selector to pick the correct Fibonacci numbers\n    fib_selector = rasp.Select(rasp.tokens, rasp.indices, rasp.Comparison.EQ).named(\"fib_selector\")\n\n    # Map the selected Fibonacci numbers to the output sequence\n    nth_fibonacci = rasp.Aggregate(fib_selector, fib_sequence).named(\"nth_fibonacci\")\n\n    return nth_fibonacci",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, 3.0, 2.0, 1.0, 8.0, 5.0]. (1.0 error rate)"
            }
        ],
        "make_count_greater_than": [],
        "make_double_first_half": [
            {
                "generated rasp code": "def make_double_first_half() -> rasp.SOp:\n    # Calculate the length of the sequence\n    seq_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"seq_length\")\n    \n    # Calculate the half-length (rounded up)\n    half_length = rasp.Map(lambda x: (x + 1) // 2, seq_length).named(\"half_length\")\n    \n    # Create a selector for the first half of the sequence\n    first_half_selector = rasp.Select(rasp.indices, half_length, rasp.Comparison.LT).named(\"first_half_selector\")\n    \n    # Double the selected elements and keep others as they are\n    doubled_sequence = rasp.SequenceMap(\n        lambda x, y: 2 * x if y else x,\n        rasp.tokens,\n        first_half_selector\n    ).named(\"doubled_sequence\")\n    \n    return doubled_sequence",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_double_first_half() -> rasp.SOp:\n    # Calculate the halfway point of the sequence, rounding up for odd lengths\n    half_length = rasp.Map(lambda x: (len(x) + 1) // 2, rasp.tokens).named(\"half_length\")\n    \n    # Create a selector for the first half of the sequence\n    first_half_selector = rasp.Select(rasp.indices, half_length, rasp.Comparison.LT).named(\"first_half_selector\")\n    \n    # Double the selected elements and leave the rest unchanged\n    doubled_sequence = rasp.SequenceMap(\n        lambda x, y: 2 * x if y else x,\n        rasp.tokens,\n        first_half_selector\n    ).named(\"doubled_sequence\")\n    \n    return doubled_sequence",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_double_first_half() -> rasp.SOp:\n    # Calculate the midpoint (rounding up for odd-length sequences)\n    midpoint = rasp.Map(lambda x: (len(x) + 1) // 2, rasp.tokens).named(\"midpoint\")\n    \n    # Create a selector for the first half of the sequence\n    first_half_selector = rasp.Select(rasp.indices, midpoint, rasp.Comparison.LT).named(\"first_half_selector\")\n    \n    # Double all elements in the sequence\n    doubled_sequence = rasp.Map(lambda x: x * 2, rasp.tokens).named(\"doubled_sequence\")\n    \n    # Apply the doubled values to the first half of the sequence\n    result = rasp.Aggregate(first_half_selector, doubled_sequence).named(\"result\")\n    \n    # For the second half (where nothing is selected), use the original values\n    final_result = rasp.SequenceMap(\n        lambda x, y: x if x is not None else y,\n        result,\n        rasp.tokens\n    ).named(\"final_result\")\n    \n    return final_result",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_double_first_half() -> rasp.SOp:\n    # Calculate half the sequence length (rounded up)\n    half_length = rasp.Map(lambda x: (len(x) + 1) // 2, rasp.tokens).named(\"half_length\")\n    \n    # Create a selector for the first half of the sequence\n    first_half_selector = rasp.Select(rasp.indices, half_length, rasp.Comparison.LT).named(\"first_half_selector\")\n    \n    # Double the selected elements, keep others as they are\n    doubled_sequence = rasp.SequenceMap(\n        lambda x, y: 2 * x if y else x,\n        rasp.tokens,\n        first_half_selector\n    ).named(\"doubled_sequence\")\n    \n    return doubled_sequence",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_double_first_half() -> rasp.SOp:\n    # Create a selector for the first half of the sequence\n    first_half_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: (len(x) + 1) // 2, rasp.tokens),\n        rasp.Comparison.LT\n    ).named(\"first_half_selector\")\n\n    # Use SequenceMap to double the selected elements\n    doubled_sequence = rasp.SequenceMap(\n        lambda x, y: 2 * x if y else x,\n        rasp.tokens,\n        first_half_selector\n    ).named(\"doubled_sequence\")\n\n    return doubled_sequence",
                "failure stage": 0,
                "error": ""
            }
        ],
        "make_decrement": [],
        "make_count_frequency": [],
        "make_increment_by_index": [],
        "make_decrement_to_multiple_of_three": [
            {
                "generated rasp code": "def make_decrement_to_multiple_of_three() -> rasp.SOp:\n    # Calculate the remainder when dividing each element by 3\n    remainder = rasp.Map(lambda x: x % 3, rasp.tokens).named(\"remainder\")\n    \n    # Calculate how much we need to decrement each element\n    # If remainder is 0, we don't need to decrement\n    # If remainder is 1, we need to decrement by 1\n    # If remainder is 2, we need to decrement by 2\n    decrement = rasp.Map(lambda x: x if x != 0 else 3, remainder).named(\"decrement\")\n    \n    # Subtract the decrement from the original sequence\n    result = rasp.SequenceMap(lambda x, y: x - y, rasp.tokens, decrement).named(\"result\")\n    \n    return result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0, 6, 0, 0, 3, 3]. (0.837 error rate)"
            },
            {
                "generated rasp code": "def make_decrement_to_multiple_of_three() -> rasp.SOp:\n    # Calculate the remainder when dividing each element by 3\n    remainder = rasp.Map(lambda x: x % 3, rasp.tokens).named(\"remainder\")\n    \n    # Calculate how much we need to decrement each element\n    # If remainder is 0, we don't need to decrement\n    # If remainder is 1, we need to decrement by 1\n    # If remainder is 2, we need to decrement by 2\n    decrement = rasp.Map(lambda x: x if x != 0 else 3, remainder).named(\"decrement\")\n    \n    # Subtract the decrement from each original element\n    result = rasp.SequenceMap(lambda x, y: x - y, rasp.tokens, decrement).named(\"result\")\n    \n    return result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0, 6, 0, 0, 3, 3]. (0.837 error rate)"
            }
        ],
        "make_hyperbolic_cosine": [
            {
                "generated rasp code": "def make_hyperbolic_cosine() -> rasp.SOp:\n    # Define the hyperbolic cosine function\n    def cosh(x):\n        exp_x = 2.718281828459045 ** x  # e \u2248 2.718281828459045\n        return (exp_x + 1/exp_x) / 2\n\n    # Apply the hyperbolic cosine function to each element of the input sequence\n    return rasp.Map(lambda x: cosh(x), rasp.tokens).named(\"hyperbolic_cosine\")",
                "failure stage": 4,
                "error": "ground truth: ['BOS', 74.20994852478785, 10.067661995777765, 74.20994852478785, 1490.479161252178, 1490.479161252178] model output: ['BOS', 74.20994852478783, 10.067661995777764, 74.20994852478783, 1490.4791612521774, 1490.4791612521774] for [5, 3, 5, 8, 8]"
            },
            {
                "generated rasp code": "def make_hyperbolic_cosine() -> rasp.SOp:\n    # Define a lambda function to calculate hyperbolic cosine\n    # cosh(x) = (e^x + e^(-x)) / 2\n    cosh = lambda x: (math.exp(x) + math.exp(-x)) / 2\n\n    # Apply the hyperbolic cosine function to each element of the input sequence\n    hyperbolic_cosine_sequence = rasp.Map(cosh, rasp.tokens).named(\"hyperbolic_cosine_sequence\")\n\n    return hyperbolic_cosine_sequence",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_hyperbolic_cosine() -> rasp.SOp:\n    def exp_approx(x):\n        # Approximate e^x using Taylor series expansion\n        # e^x \u2248 1 + x + x^2/2! + x^3/3! + x^4/4! + x^5/5!\n        return 1 + x + (x**2)/2 + (x**3)/6 + (x**4)/24 + (x**5)/120\n\n    def cosh(x):\n        # Hyperbolic cosine: cosh(x) = (e^x + e^(-x)) / 2\n        return (exp_approx(x) + exp_approx(-x)) / 2\n\n    # Apply the hyperbolic cosine function to each element of the input sequence\n    return rasp.Map(lambda x: cosh(x), rasp.tokens).named(\"hyperbolic_cosine\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [8.875, 203.66666666666663, 3.6666666666666665, 1.5416666666666665, 39.54166666666667, 19.666666666666664]. (0.989 error rate)"
            },
            {
                "generated rasp code": "def make_hyperbolic_cosine() -> rasp.SOp:\n    def exp_approx(x, terms=10):\n        \"\"\"Approximate e^x using Taylor series.\"\"\"\n        result = 1.0\n        term = 1.0\n        for i in range(1, terms):\n            term *= x / i\n            result += term\n        return result\n\n    def cosh(x):\n        \"\"\"Calculate hyperbolic cosine.\"\"\"\n        ex = exp_approx(x)\n        e_neg_x = exp_approx(-x)\n        return (ex + e_neg_x) / 2\n\n    # Apply hyperbolic cosine to each element\n    return rasp.Map(lambda x: cosh(x), rasp.tokens).named(\"hyperbolic_cosine\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [10.050223214285714, 983.8571428571427, 3.7619047619047614, 1.5430803571428573, 70.9311755952381, 26.98095238095238]. (0.989 error rate)"
            },
            {
                "generated rasp code": "def make_hyperbolic_cosine() -> rasp.SOp:\n    def exp_approx(x):\n        # Approximation of e^x using (1 + x/n)^n with n = 1000000\n        n = 1000000\n        return (1 + x/n) ** n\n\n    def cosh(x):\n        # Hyperbolic cosine: cosh(x) = (e^x + e^(-x)) / 2\n        return (exp_approx(x) + exp_approx(-x)) / 2\n\n    # Apply the hyperbolic cosine function to each element of the input sequence\n    return rasp.Map(lambda x: cosh(x), rasp.tokens).named(\"hyperbolic_cosine\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [10.067616691242886, 1490.431466948425, 3.762188166925543, 1.54307986315841, 74.20902091175122, 27.308014368688237]. (0.989 error rate)"
            }
        ],
        "make_check_fibonacci": [
            {
                "generated rasp code": "def make_check_fibonacci():\n    def generate_fibonacci(n):\n        if n < 0:\n            return 0\n        a, b = 0, 1\n        while b <= n:\n            if b == n:\n                return 1\n            a, b = b, a + b\n        return 0\n\n    return rasp.Map(lambda x: generate_fibonacci(x), rasp.tokens).named(\"fibonacci_checker\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [1, 1, 1, 1, 1, 0]. (0.412 error rate)"
            },
            {
                "generated rasp code": "def make_check_fibonacci():\n    def fib_less_or_equal(x):\n        a, b = 0, 1\n        while b <= x:\n            if b == x:\n                return x\n            a, b = b, a + b\n        return a\n\n    # Generate sequence of largest Fibonacci numbers not exceeding each input\n    largest_fib = rasp.Map(fib_less_or_equal, rasp.tokens).named(\"largest_fib\")\n\n    # Check if each input is equal to its corresponding largest Fibonacci number\n    is_fib = rasp.Select(rasp.tokens, largest_fib, rasp.Comparison.EQ).named(\"is_fib\")\n\n    # Convert boolean selector to 1s and 0s\n    result = rasp.Map(lambda x: 1 if x else 0, is_fib).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_check_fibonacci() -> rasp.SOp:\n    # Find the maximum value in the input sequence\n    max_value = rasp.Aggregate(\n        rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.GEQ),\n        rasp.tokens\n    ).named(\"max_value\")\n    \n    # Generate Fibonacci sequence up to max_value\n    def generate_fibonacci(x):\n        fib = [0, 1]\n        while fib[-1] < x:\n            fib.append(fib[-1] + fib[-2])\n        return fib\n    \n    fibonacci_seq = rasp.Map(generate_fibonacci, max_value).named(\"fibonacci_seq\")\n    \n    # Create a selector that compares each input element with the Fibonacci sequence\n    is_fibonacci = rasp.Select(\n        rasp.tokens,\n        fibonacci_seq,\n        lambda x, fib_seq: x in fib_seq\n    ).named(\"is_fibonacci\")\n    \n    # Count matches (will be 1 for Fibonacci numbers, 0 for non-Fibonacci)\n    match_count = rasp.SelectorWidth(is_fibonacci).named(\"match_count\")\n    \n    # Map counts to 1 (Fibonacci) or 0 (non-Fibonacci)\n    result = rasp.Map(lambda x: 1 if x > 0 else 0, match_count).named(\"result\")\n    \n    return result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [1, 1, 1, 1, 1, 1]. (0.792 error rate)"
            },
            {
                "generated rasp code": "def make_check_fibonacci():\n    # Generate the first 30 Fibonacci numbers\n    def fib_generator(x, i):\n        if i == 0:\n            return 0\n        elif i == 1:\n            return 1\n        else:\n            return x[i-1] + x[i-2]\n    \n    fib_numbers = rasp.Map(lambda i: fib_generator(rasp.tokens, i), rasp.indices).named(\"fib_numbers\")\n    \n    # Create a selector that checks if each input element is equal to any Fibonacci number\n    is_fib_selector = rasp.Select(rasp.tokens, fib_numbers, rasp.Comparison.EQ).named(\"is_fib_selector\")\n    \n    # Count how many times each input element matches a Fibonacci number (should be 0 or 1)\n    fib_match_count = rasp.SelectorWidth(is_fib_selector).named(\"fib_match_count\")\n    \n    # Map the result to 1 if the count is 1 (element is a Fibonacci number) or 0 otherwise\n    result = rasp.Map(lambda x: 1 if x > 0 else 0, fib_match_count).named(\"result\")\n    \n    return result\n\n# Usage:\n# fibonacci_checker = make_check_fibonacci()\n# output = fibonacci_checker(input_sequence)",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_check_fibonacci():\n    # Find the maximum value in the input sequence\n    max_value = rasp.Aggregate(\n        rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.GEQ),\n        rasp.tokens\n    ).named(\"max_value\")\n\n    # Generate Fibonacci sequence up to max_value\n    def fib_generator(prev, curr, max_val):\n        next_val = prev + curr\n        return (curr, next_val) if next_val <= max_val else (curr, curr)\n\n    fib_sequence = rasp.SequenceMap(\n        fib_generator,\n        rasp.Map(lambda x: 0, rasp.tokens),  # Previous Fibonacci number\n        rasp.Map(lambda x: 1, rasp.tokens),  # Current Fibonacci number\n        max_value\n    ).named(\"fib_sequence\")\n\n    # Create a selector to check if each input element is in the Fibonacci sequence\n    is_fibonacci_selector = rasp.Select(\n        rasp.tokens,\n        fib_sequence,\n        rasp.Comparison.EQ\n    ).named(\"is_fibonacci_selector\")\n\n    # Count matches (should be 0 or 1 for each element)\n    match_count = rasp.SelectorWidth(is_fibonacci_selector).named(\"match_count\")\n\n    # Convert count to binary output (1 if Fibonacci, 0 otherwise)\n    is_fibonacci = rasp.Map(lambda x: 1 if x > 0 else 0, match_count).named(\"is_fibonacci\")\n\n    return is_fibonacci",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            }
        ],
        "make_square_root": [],
        "make_increment_odd_indices": [
            {
                "generated rasp code": "def make_increment_odd_indices() -> rasp.SOp:\n    # Create a selector for odd indices\n    odd_selector = rasp.Select(\n        rasp.Map(lambda x: x % 2, rasp.indices),\n        rasp.Map(lambda x: 1, rasp.indices),\n        rasp.Comparison.EQ\n    ).named(\"odd_selector\")\n\n    # Create a sequence of 1s at odd indices and 0s at even indices\n    increment_sequence = rasp.Map(lambda x: 1 if x else 0, odd_selector).named(\"increment_sequence\")\n\n    # Add the increment sequence to the original sequence\n    incremented_sequence = rasp.SequenceMap(\n        lambda x, y: x + y,\n        rasp.tokens,\n        increment_sequence\n    ).named(\"incremented_sequence\")\n\n    return incremented_sequence",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_increment_odd_indices() -> rasp.SOp:\n    # Create a selector for odd indices\n    odd_selector = rasp.Select(\n        rasp.Map(lambda x: x % 2, rasp.indices),\n        rasp.Map(lambda x: 1, rasp.indices),\n        rasp.Comparison.EQ\n    ).named(\"odd_selector\")\n\n    # Create a sequence of 1's to be added\n    increment = rasp.Map(lambda x: 1, rasp.tokens).named(\"increment\")\n\n    # Combine the original sequence with the increment values at odd indices\n    incremented_sequence = rasp.SequenceMap(\n        lambda x, y: x + y,\n        rasp.tokens,\n        rasp.Aggregate(odd_selector, increment, default=None)\n    ).named(\"incremented_sequence\")\n\n    return incremented_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [4.0, 9.0, 3.0, 2.0, 6.0, 5.0]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_increment_odd_indices() -> rasp.SOp:\n    # Create a selector for odd indices\n    odd_selector = rasp.Select(\n        rasp.Map(lambda x: x % 2, rasp.indices),\n        rasp.Map(lambda x: 1, rasp.indices),\n        rasp.Comparison.EQ\n    ).named(\"odd_selector\")\n\n    # Create a sequence of 1s for odd indices and 0s for even indices\n    increment_sequence = rasp.Map(lambda x: 1 if x else 0, odd_selector).named(\"increment_sequence\")\n\n    # Add the increment sequence to the original tokens\n    incremented_tokens = rasp.SequenceMap(\n        lambda x, y: x + y,\n        rasp.tokens,\n        increment_sequence\n    ).named(\"incremented_tokens\")\n\n    return incremented_tokens",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_increment_odd_indices() -> rasp.SOp:\n    # Create a selector for odd indices\n    odd_indices_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: 2, rasp.indices),\n        lambda x, y: x % y == 1\n    ).named(\"odd_indices_selector\")\n\n    # Create a sequence of 1's at odd indices and 0's at even indices\n    increment_values = rasp.Map(\n        lambda x: 1 if x else 0,\n        odd_indices_selector\n    ).named(\"increment_values\")\n\n    # Add the increment values to the original sequence\n    incremented_sequence = rasp.SequenceMap(\n        lambda x, y: x + y,\n        rasp.tokens,\n        increment_values\n    ).named(\"incremented_sequence\")\n\n    return incremented_sequence",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_increment_odd_indices() -> rasp.SOp:\n    # Create a selector for odd indices\n    odd_selector = rasp.Select(\n        rasp.Map(lambda x: x % 2, rasp.indices),  # Calculate modulo 2 for each index\n        rasp.Map(lambda x: 1, rasp.indices),      # Compare with 1 to select odd indices\n        rasp.Comparison.EQ\n    ).named(\"odd_selector\")\n\n    # Create a sequence of 1s for odd indices and 0s for even indices\n    increment_sequence = rasp.Map(\n        lambda x: 1 if x else 0,\n        odd_selector\n    ).named(\"increment_sequence\")\n\n    # Add the increment sequence to the original input\n    incremented_sequence = rasp.SequenceMap(\n        lambda x, y: x + y,\n        rasp.tokens,\n        increment_sequence\n    ).named(\"incremented_sequence\")\n\n    return incremented_sequence",
                "failure stage": 0,
                "error": ""
            }
        ],
        "make_hyperbolic_tangent": [
            {
                "generated rasp code": "def make_hyperbolic_tangent() -> rasp.SOp:\n    # Define the hyperbolic tangent function using the mathematical formula\n    def tanh(x):\n        exp_x = exp(x)\n        exp_neg_x = exp(-x)\n        return (exp_x - exp_neg_x) / (exp_x + exp_neg_x)\n    \n    # Apply the hyperbolic tangent function to each element of the input sequence\n    return rasp.Map(lambda x: tanh(x), rasp.tokens).named(\"hyperbolic_tangent\")",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_hyperbolic_tangent() -> rasp.SOp:\n    def tanh(x):\n        # Implementing tanh function: tanh(x) = (e^x - e^(-x)) / (e^x + e^(-x))\n        if x > 20:  # To prevent overflow for large x\n            return 1.0\n        elif x < -20:  # To prevent underflow for large negative x\n            return -1.0\n        exp_x = exp(x)\n        exp_neg_x = exp(-x)\n        return (exp_x - exp_neg_x) / (exp_x + exp_neg_x)\n    \n    # Apply the tanh function to each element of the input sequence\n    return rasp.Map(lambda x: tanh(x), rasp.tokens).named(\"hyperbolic_tangent\")",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_hyperbolic_tangent() -> rasp.SOp:\n    # Define a lambda function to calculate hyperbolic tangent\n    def tanh(x):\n        ex = exp(x)\n        emx = exp(-x)\n        return (ex - emx) / (ex + emx)\n    \n    # Apply the tanh function to each element of the input sequence\n    return rasp.Map(lambda x: tanh(x), rasp.tokens).named(\"hyperbolic_tangent\")",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_hyperbolic_tangent() -> rasp.SOp:\n    # Define the hyperbolic tangent function using its mathematical definition\n    def tanh(x):\n        exp_x = math.exp(x)\n        exp_neg_x = math.exp(-x)\n        return (exp_x - exp_neg_x) / (exp_x + exp_neg_x)\n    \n    # Apply the tanh function to each element of the input sequence\n    return rasp.Map(lambda x: tanh(x), rasp.tokens).named(\"hyperbolic_tangent\")",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_hyperbolic_tangent() -> rasp.SOp:\n    def exp_approximation(x):\n        # Approximate e^x using Taylor series expansion\n        # e^x \u2248 1 + x + x^2/2! + x^3/3! + x^4/4! + x^5/5!\n        return 1 + x + (x**2)/2 + (x**3)/6 + (x**4)/24 + (x**5)/120\n\n    def tanh_approximation(x):\n        # Calculate tanh(x) using the approximation of e^x\n        exp_x = exp_approximation(x)\n        exp_neg_x = exp_approximation(-x)\n        return (exp_x - exp_neg_x) / (exp_x + exp_neg_x)\n\n    # Apply the tanh approximation to each element of the input sequence\n    return rasp.Map(tanh_approximation, rasp.tokens).named(\"hyperbolic_tangent\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [1.0732394366197182, 1.7990180032733227, 0.9818181818181819, 0.7621621621621621, 1.3119072708113801, 1.1796610169491524]. (0.986 error rate)"
            }
        ],
        "make_hyperbolic_sine": [
            {
                "generated rasp code": "def make_hyperbolic_sine() -> rasp.SOp:\n    def exp_approx(x):\n        # Taylor series approximation of e^x\n        # e^x \u2248 1 + x + x^2/2! + x^3/3! + x^4/4! + x^5/5!\n        return 1 + x + (x**2)/2 + (x**3)/6 + (x**4)/24 + (x**5)/120\n\n    def sinh(x):\n        # Hyperbolic sine: sinh(x) = (e^x - e^(-x)) / 2\n        return (exp_approx(x) - exp_approx(-x)) / 2\n\n    # Apply the hyperbolic sine function to each element\n    return rasp.Map(lambda x: sinh(x), rasp.tokens).named(\"hyperbolic_sine\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [9.524999999999999, 366.4, 3.6, 1.1749999999999998, 51.875, 23.199999999999996]. (0.992 error rate)"
            },
            {
                "generated rasp code": "def make_hyperbolic_sine() -> rasp.SOp:\n    # Define the hyperbolic sine function using its mathematical definition\n    # sinh(x) = (e^x - e^(-x)) / 2\n    def sinh(x):\n        return (math.exp(x) - math.exp(-x)) / 2\n\n    # Apply the hyperbolic sine function to each element of the input sequence\n    hyperbolic_sine = rasp.Map(lambda x: sinh(x), rasp.tokens).named(\"hyperbolic_sine\")\n\n    return hyperbolic_sine",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_hyperbolic_sine() -> rasp.SOp:\n    # Define the hyperbolic sine function using the formula (e^x - e^(-x)) / 2\n    # where e is approximated as 2.71828\n    def sinh(x):\n        e_x = 2.71828 ** x\n        e_neg_x = 2.71828 ** (-x)\n        return (e_x - e_neg_x) / 2\n\n    # Apply the hyperbolic sine function to each element of the input sequence\n    return rasp.Map(lambda x: sinh(x), rasp.tokens).named(\"hyperbolic_sine\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [10.017854611309684, 1490.4708052122592, 3.6268553465479862, 1.1752001556866842, 74.20296099059055, 27.28984372139837]. (0.992 error rate)"
            },
            {
                "generated rasp code": "def make_hyperbolic_sine() -> rasp.SOp:\n    def exp_approx(x):\n        # Approximate e^x using Taylor series (up to 5th term)\n        return 1 + x + (x**2)/2 + (x**3)/6 + (x**4)/24 + (x**5)/120\n\n    def sinh(x):\n        # Hyperbolic sine function: (e^x - e^(-x)) / 2\n        return (exp_approx(x) - exp_approx(-x)) / 2\n\n    # Apply hyperbolic sine to each element of the input sequence\n    return rasp.Map(lambda x: sinh(x), rasp.tokens).named(\"hyperbolic_sine\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [9.524999999999999, 366.4, 3.6, 1.1749999999999998, 51.875, 23.199999999999996]. (0.992 error rate)"
            },
            {
                "generated rasp code": "def make_hyperbolic_sine() -> rasp.SOp:\n    def exp_approx(x):\n        # Approximate e^x using Taylor series up to 5th term\n        return 1 + x + (x**2)/2 + (x**3)/6 + (x**4)/24 + (x**5)/120\n\n    def sinh_approx(x):\n        # Approximate sinh(x) using the definition and our exp_approx\n        return (exp_approx(x) - exp_approx(-x)) / 2\n\n    # Apply the hyperbolic sine approximation to each element\n    return rasp.Map(lambda x: sinh_approx(x), rasp.tokens).named(\"hyperbolic_sine\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [9.524999999999999, 366.4, 3.6, 1.1749999999999998, 51.875, 23.199999999999996]. (0.992 error rate)"
            }
        ],
        "make_zero_every_third": [
            {
                "generated rasp code": "def make_zero_every_third() -> rasp.SOp:\n    # Create a sequence where every third element is True, others are False\n    third_element_seq = rasp.Map(lambda x: x % 3 == 2, rasp.indices).named(\"third_element_seq\")\n    \n    # Create a selector for every third element\n    third_element_selector = rasp.Select(third_element_seq, rasp.tokens, rasp.Comparison.EQ).named(\"third_element_selector\")\n    \n    # Use SequenceMap to set every third element to zero, leaving others unchanged\n    result = rasp.SequenceMap(\n        lambda x, y: 0 if y else x,\n        rasp.tokens,\n        third_element_selector\n    ).named(\"zero_every_third\")\n    \n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_zero_every_third() -> rasp.SOp:\n    # Create a selector that identifies every third element\n    every_third_selector = rasp.Select(\n        rasp.Map(lambda x: x % 3, rasp.indices),\n        rasp.Map(lambda x: 0, rasp.indices),\n        rasp.Comparison.EQ\n    ).named(\"every_third_selector\")\n\n    # Use SequenceMap to replace every third element with zero\n    zero_every_third = rasp.SequenceMap(\n        lambda x, y: 0 if y else x,\n        rasp.tokens,\n        every_third_selector\n    ).named(\"zero_every_third\")\n\n    return zero_every_third",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_zero_every_third() -> rasp.SOp:\n    # Create a selector that identifies every third element\n    every_third_selector = rasp.Select(\n        rasp.indices,  # keys: use indices of the sequence\n        rasp.Map(lambda x: 2, rasp.indices),  # queries: constant sequence of 2\n        rasp.Comparison.EQ  # comparison: check if (index % 3) == 2\n    ).named(\"every_third_selector\")\n\n    # Create the output sequence\n    output = rasp.SequenceMap(\n        lambda x, y: 0 if y else x,  # If selected (y is True), set to 0; otherwise, keep x\n        rasp.tokens,  # Original sequence\n        every_third_selector  # Our selector for every third element\n    ).named(\"zero_every_third\")\n\n    return output",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_zero_every_third() -> rasp.SOp:\n    # Create a sequence where each element is its index modulo 3\n    mod_3_indices = rasp.Map(lambda x: x % 3, rasp.indices).named(\"mod_3_indices\")\n\n    # Create a selector that is True for every third element (where mod 3 == 0)\n    every_third_selector = rasp.Select(mod_3_indices, rasp.Map(lambda x: 0, rasp.indices), rasp.Comparison.EQ).named(\"every_third_selector\")\n\n    # Use SequenceMap to set every third element to zero, leaving others unchanged\n    zero_every_third = rasp.SequenceMap(\n        lambda x, y: 0 if y else x,\n        rasp.tokens,\n        every_third_selector\n    ).named(\"zero_every_third\")\n\n    return zero_every_third",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_zero_every_third() -> rasp.SOp:\n    # Create a sequence of indices modulo 3\n    mod_3_indices = rasp.Map(lambda x: x % 3, rasp.indices).named(\"mod_3_indices\")\n    \n    # Create a selector that is True for every third element (where mod 3 == 0)\n    every_third_selector = rasp.Select(mod_3_indices, rasp.Map(lambda x: 0, rasp.indices), rasp.Comparison.EQ).named(\"every_third_selector\")\n    \n    # Use SequenceMap to set every third element to zero\n    zero_every_third = rasp.SequenceMap(\n        lambda x, y: 0 if y else x,\n        rasp.tokens,\n        every_third_selector\n    ).named(\"zero_every_third\")\n    \n    return zero_every_third",
                "failure stage": 0,
                "error": ""
            }
        ],
        "make_element_second": [
            {
                "generated rasp code": "def make_element_second() -> rasp.SOp:\n    # Selector that picks only the second element (index 1)\n    second_element_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: 1, rasp.tokens), rasp.Comparison.EQ).named(\"second_element_selector\")\n\n    # Broadcast the second element across the sequence\n    second_element_broadcast = rasp.Aggregate(second_element_selector, rasp.tokens, default=None).named(\"second_element_broadcast\")\n\n    # Check if the sequence has at least two elements\n    has_two_elements = rasp.Map(lambda x: len(x) >= 2, rasp.tokens).named(\"has_two_elements\")\n\n    # Combine the results: use the broadcasted second element if the sequence has at least two elements,\n    # otherwise use None\n    result = rasp.SequenceMap(\n        lambda x, y: x if y else None,\n        second_element_broadcast,\n        has_two_elements\n    ).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_element_second() -> rasp.SOp:\n    # Selector that selects only the second element of the sequence\n    second_element_selector = rasp.Select(rasp.indices, rasp.tokens, lambda x, y: x == 1).named(\"second_element_selector\")\n\n    # Broadcast the second element across the entire sequence\n    second_element_broadcast = rasp.Aggregate(second_element_selector, rasp.tokens).named(\"second_element_broadcast\")\n\n    # Check if the sequence has at least two elements\n    has_two_elements = rasp.Map(lambda x: x >= 1, rasp.indices).named(\"has_two_elements\")\n\n    # Combine the broadcast with the length check\n    result = rasp.SequenceMap(\n        lambda x, y: x if y else None,\n        second_element_broadcast,\n        has_two_elements\n    ).named(\"result\")\n\n    return result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, 8.0, 8.0, 8.0, 8.0, 8.0]. (0.91 error rate)"
            },
            {
                "generated rasp code": "def make_element_second() -> rasp.SOp:\n    # Create a selector that selects only the second element (index 1)\n    second_element_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: 1, rasp.tokens), rasp.Comparison.EQ).named(\"second_element_selector\")\n\n    # Use Aggregate to broadcast the second element across the entire sequence\n    second_element_broadcast = rasp.Aggregate(second_element_selector, rasp.tokens).named(\"second_element_broadcast\")\n\n    # Create a selector to check if the sequence has at least two elements\n    has_second_element = rasp.Select(rasp.indices, rasp.Map(lambda x: 1, rasp.tokens), rasp.Comparison.LEQ).named(\"has_second_element\")\n\n    # Combine the broadcasted second element with the length check\n    result = rasp.Aggregate(has_second_element, second_element_broadcast).named(\"result\")\n\n    return result",
                "failure stage": 1,
                "error": "Unsupported type for aggregation: [4.0, 4.0]"
            },
            {
                "generated rasp code": "def make_element_second() -> rasp.SOp:\n    # Selector that picks only the second element (index 1)\n    second_element_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: 1, rasp.tokens), rasp.Comparison.EQ).named(\"second_element_selector\")\n\n    # Use Aggregate to broadcast the second element across the sequence\n    second_element_broadcast = rasp.Aggregate(second_element_selector, rasp.tokens).named(\"second_element_broadcast\")\n\n    # Create a Map to get the sequence length for each element\n    sequence_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"sequence_length\")\n\n    # Combine the broadcast with a length check\n    result = rasp.SequenceMap(\n        lambda x, y: x if y >= 2 else None,\n        second_element_broadcast,\n        sequence_length\n    ).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_element_second() -> rasp.SOp:\n    # Create a selector that selects only the second element\n    second_element_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: 1, rasp.indices),\n        rasp.Comparison.EQ\n    ).named(\"second_element_selector\")\n\n    # Use Aggregate to broadcast the second element across the entire sequence\n    second_element_broadcast = rasp.Aggregate(\n        second_element_selector,\n        rasp.tokens,\n        default=None\n    ).named(\"second_element_broadcast\")\n\n    # Create a sequence representing the length of the input\n    sequence_length = rasp.SelectorWidth(\n        rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE)\n    ).named(\"sequence_length\")\n\n    # Combine the broadcasted second element with a check for sequence length\n    result = rasp.SequenceMap(\n        lambda x, y: x if y >= 2 else None,\n        second_element_broadcast,\n        sequence_length\n    ).named(\"result\")\n\n    return result",
                "failure stage": 4,
                "error": "ground truth: ['BOS', None] model output: ['BOS', 0] for [6]"
            }
        ],
        "make_mirror_first_half": [
            {
                "generated rasp code": "def make_mirror_first_half() -> rasp.SOp:\n    # Calculate the midpoint of the sequence\n    sequence_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"sequence_length\")\n    midpoint = rasp.Map(lambda x: x // 2, sequence_length).named(\"midpoint\")\n\n    # Create selectors for the first and second halves\n    first_half_selector = rasp.Select(rasp.indices, midpoint, rasp.Comparison.LT).named(\"first_half_selector\")\n    second_half_selector = rasp.Select(rasp.indices, midpoint, rasp.Comparison.GEQ).named(\"second_half_selector\")\n\n    # Keep the first half unchanged\n    first_half = rasp.Aggregate(first_half_selector, rasp.tokens).named(\"first_half\")\n\n    # Create a reversed index for the second half\n    reversed_index = rasp.SequenceMap(\n        lambda i, m: m - 1 - (i - m),\n        rasp.indices,\n        midpoint\n    ).named(\"reversed_index\")\n\n    # Select elements for the second half using the reversed index\n    second_half_reversed = rasp.Aggregate(\n        rasp.Select(reversed_index, rasp.indices, rasp.Comparison.EQ) & second_half_selector,\n        rasp.tokens\n    ).named(\"second_half_reversed\")\n\n    # Combine the two halves\n    mirrored_sequence = rasp.SequenceMap(\n        lambda x, y: x if x is not None else y,\n        first_half,\n        second_half_reversed\n    ).named(\"mirrored_sequence\")\n\n    return mirrored_sequence",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_mirror_first_half() -> rasp.SOp:\n    # Create a sequence of indices\n    indices = rasp.indices\n\n    # Calculate the midpoint of the sequence\n    midpoint = rasp.Map(lambda x: len(x) // 2, rasp.tokens).named(\"midpoint\")\n\n    # Create a selector for the first half of the sequence\n    first_half_selector = rasp.Select(indices, midpoint, rasp.Comparison.LT).named(\"first_half_selector\")\n\n    # Create a selector for the second half of the sequence\n    second_half_selector = rasp.Select(indices, midpoint, rasp.Comparison.GEQ).named(\"second_half_selector\")\n\n    # Keep the first half intact\n    first_half = rasp.Aggregate(first_half_selector, rasp.tokens).named(\"first_half\")\n\n    # Create reversed indices for the second half\n    reversed_indices = rasp.Map(lambda x: len(x) - x - 1, indices).named(\"reversed_indices\")\n\n    # Use the reversed indices to select from the first half and place in the second half\n    second_half = rasp.Aggregate(second_half_selector, rasp.Aggregate(first_half_selector, rasp.tokens, default=None)).named(\"second_half\")\n\n    # Combine the first half and the mirrored second half\n    mirrored_sequence = rasp.SequenceMap(\n        lambda x, y: x if x is not None else y,\n        first_half,\n        second_half\n    ).named(\"mirrored_sequence\")\n\n    return mirrored_sequence",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_mirror_first_half() -> rasp.SOp:\n    # Get the length of the sequence\n    seq_length = rasp.SelectorWidth(rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE)).named(\"seq_length\")\n    \n    # Calculate the midpoint (works for both even and odd lengths)\n    midpoint = rasp.Map(lambda x: x // 2, seq_length).named(\"midpoint\")\n    \n    # Create a selector for the first half of the sequence\n    first_half_selector = rasp.Select(rasp.indices, midpoint, rasp.Comparison.LT).named(\"first_half_selector\")\n    \n    # Create the first half of the output\n    first_half = rasp.Aggregate(first_half_selector, rasp.tokens).named(\"first_half\")\n    \n    # Create reversed indices for the second half\n    reversed_indices = rasp.SequenceMap(\n        lambda i, l: l - i - 1,\n        rasp.indices,\n        seq_length\n    ).named(\"reversed_indices\")\n    \n    # Create a selector for the reversed first half\n    reversed_first_half_selector = rasp.Select(\n        rasp.indices,\n        midpoint,\n        rasp.Comparison.GEQ\n    ).named(\"reversed_first_half_selector\")\n    \n    # Create the reversed first half\n    reversed_first_half = rasp.Aggregate(\n        reversed_first_half_selector,\n        rasp.Aggregate(rasp.Select(reversed_indices, midpoint, rasp.Comparison.LT), rasp.tokens)\n    ).named(\"reversed_first_half\")\n    \n    # Combine the first half and reversed first half\n    mirrored_sequence = rasp.SequenceMap(\n        lambda x, y: x if x is not None else y,\n        first_half,\n        reversed_first_half\n    ).named(\"mirrored_sequence\")\n    \n    return mirrored_sequence",
                "failure stage": 1,
                "error": "Unsupported type for aggregation: [3.0, 3.0]"
            },
            {
                "generated rasp code": "def make_mirror_first_half() -> rasp.SOp:\n    # Calculate the sequence length\n    seq_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"seq_length\")\n    \n    # Calculate the midpoint (using integer division for odd lengths)\n    midpoint = rasp.Map(lambda x: x // 2, seq_length).named(\"midpoint\")\n    \n    # Create a selector for the first half of the sequence\n    first_half_selector = rasp.Select(rasp.indices, midpoint, rasp.Comparison.LT).named(\"first_half_selector\")\n    \n    # Create a selector for the second half of the sequence\n    second_half_selector = rasp.Select(rasp.indices, midpoint, rasp.Comparison.GEQ).named(\"second_half_selector\")\n    \n    # Keep the first half unchanged\n    first_half = rasp.Aggregate(first_half_selector, rasp.tokens).named(\"first_half\")\n    \n    # Create a reversed index for the second half\n    reversed_index = rasp.SequenceMap(lambda i, l: l - i - 1, rasp.indices, seq_length).named(\"reversed_index\")\n    \n    # Create a selector that maps the second half to the reversed first half\n    reverse_selector = rasp.Select(reversed_index, midpoint, rasp.Comparison.LT).named(\"reverse_selector\")\n    \n    # Create the reversed second half\n    second_half_reversed = rasp.Aggregate(reverse_selector & second_half_selector, rasp.tokens).named(\"second_half_reversed\")\n    \n    # Combine the two halves\n    mirrored = rasp.SequenceMap(lambda x, y: x if x is not None else y, first_half, second_half_reversed).named(\"mirrored\")\n    \n    return mirrored",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_mirror_first_half() -> rasp.SOp:\n    # Calculate the midpoint of the sequence\n    midpoint = rasp.Map(lambda x: len(x) // 2, rasp.tokens).named(\"midpoint\")\n    \n    # Create a selector for the first half of the sequence\n    first_half_selector = rasp.Select(rasp.indices, midpoint, rasp.Comparison.LT).named(\"first_half_selector\")\n    \n    # Create a selector for the second half of the sequence\n    second_half_selector = rasp.Select(rasp.indices, midpoint, rasp.Comparison.GT).named(\"second_half_selector\")\n    \n    # Create reversed indices\n    reversed_indices = rasp.Map(lambda x: len(x) - x - 1, rasp.indices).named(\"reversed_indices\")\n    \n    # Create the first half of the output (same as input)\n    first_half = rasp.SequenceMap(\n        lambda x, y: x if y else None,\n        rasp.tokens,\n        first_half_selector\n    ).named(\"first_half\")\n    \n    # Create the mirrored second half\n    second_half = rasp.SequenceMap(\n        lambda x, y: x if y else None,\n        rasp.Aggregate(first_half_selector, rasp.tokens),\n        second_half_selector\n    ).named(\"second_half\")\n    \n    # Combine the two halves\n    mirrored_sequence = rasp.SequenceMap(\n        lambda x, y: x if x is not None else y,\n        first_half,\n        second_half\n    ).named(\"mirrored_sequence\")\n    \n    return mirrored_sequence",
                "failure stage": 0,
                "error": ""
            }
        ],
        "make_sorting": [
            {
                "generated rasp code": "def make_sorting() -> rasp.SOp:\n    # Create a selector that compares each element with every other element\n    leq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LEQ).named(\"leq_selector\")\n\n    # Count the number of elements less than or equal to each element\n    leq_count = rasp.SelectorWidth(leq_selector).named(\"leq_count\")\n\n    # Create a sequence of indices\n    indices = rasp.Map(lambda x: x, rasp.indices).named(\"indices\")\n\n    # Create a selector that matches each original position with its new sorted position\n    position_selector = rasp.Select(indices, leq_count, rasp.Comparison.EQ).named(\"position_selector\")\n\n    # Use Aggregate to move each element to its sorted position\n    sorted_sequence = rasp.Aggregate(position_selector, rasp.tokens).named(\"sorted_sequence\")\n\n    return sorted_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [1.0, None, 2.0, 8.0, 4.0, 5.0]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_sorting() -> rasp.SOp:\n    # Create a selector that compares each element with every other element\n    lt_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LT).named(\"lt_selector\")\n\n    # Count the number of elements less than each element\n    lt_count = rasp.SelectorWidth(lt_selector).named(\"lt_count\")\n\n    # Adjust the count to get the correct index (add 1 because indices start at 0)\n    sort_index = rasp.Map(lambda x: x + 1, lt_count).named(\"sort_index\")\n\n    # Create a selector that matches each original position to its new sorted position\n    position_selector = rasp.Select(rasp.indices, sort_index, rasp.Comparison.EQ).named(\"position_selector\")\n\n    # Use Aggregate to move each element to its correct sorted position\n    sorted_sequence = rasp.Aggregate(position_selector, rasp.tokens).named(\"sorted_sequence\")\n\n    return sorted_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [1.0, None, 2.0, 8.0, 4.0, 5.0]. (0.978 error rate)"
            },
            {
                "generated rasp code": "def make_sorting() -> rasp.SOp:\n    # Create a selector that compares each element with every other element\n    lt_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LT).named(\"lt_selector\")\n\n    # Count the number of elements less than each element\n    lt_count = rasp.SelectorWidth(lt_selector).named(\"lt_count\")\n\n    # Adjust the count to get the correct position (add 1 because positions are 1-indexed)\n    position = rasp.Map(lambda x: x + 1, lt_count).named(\"position\")\n\n    # Create a selector that matches each original position with its new sorted position\n    position_selector = rasp.Select(rasp.indices, position, rasp.Comparison.EQ).named(\"position_selector\")\n\n    # Use Aggregate to move each element to its new position in the sorted sequence\n    sorted_sequence = rasp.Aggregate(position_selector, rasp.tokens).named(\"sorted_sequence\")\n\n    return sorted_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [1.0, None, 2.0, 8.0, 4.0, 5.0]. (0.978 error rate)"
            },
            {
                "generated rasp code": "def make_sorting() -> rasp.SOp:\n    # Selector that creates a comparison matrix where each element is compared to every other element (less than).\n    lt_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LT).named(\"lt_selector\")\n    \n    # Selector for equality comparison\n    eq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.EQ).named(\"eq_selector\")\n    \n    # Combine LT and EQ to get LEQ\n    leq_selector = (lt_selector | eq_selector).named(\"leq_selector\")\n\n    # Count the number of elements less than or equal to each element\n    leq_count = rasp.SelectorWidth(leq_selector).named(\"leq_count\")\n\n    # Adjust the count to get the correct index (add 1 because indices are 1-based in this context)\n    sort_index = rasp.Map(lambda x: x + 1, leq_count).named(\"sort_index\")\n\n    # Create a selector that will be used to place each element in its sorted position\n    sort_selector = rasp.Select(sort_index, rasp.indices, rasp.Comparison.EQ).named(\"sort_selector\")\n\n    # Use Aggregate to place each element in its sorted position\n    sorted_sequence = rasp.Aggregate(sort_selector, rasp.tokens).named(\"sorted_sequence\")\n\n    return sorted_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, None, 1.0, 2.0, 3.0, 4.0]. (1.0 error rate)"
            }
        ],
        "make_increment": [],
        "make_rank": [],
        "make_factorial": [
            {
                "generated rasp code": "def make_factorial() -> rasp.SOp:\n    # Selector that creates a comparison matrix where each element is compared to indices\n    geq_selector = rasp.Select(rasp.tokens, rasp.indices, rasp.Comparison.GEQ).named(\"geq_selector\")\n\n    # Count how many numbers are less than or equal to each element and add 1\n    factorial_range = rasp.Map(lambda x: x + 1, rasp.SelectorWidth(geq_selector)).named(\"factorial_range\")\n\n    # Create running products for each element\n    running_product = rasp.SequenceMap(\n        lambda x, y: x * (y + 1) if y < x else 1,\n        factorial_range,\n        rasp.indices\n    ).named(\"running_product\")\n\n    # Select the final product for each element, which is the factorial\n    factorial = rasp.Map(lambda x: x[-1] if x else 1, running_product).named(\"factorial\")\n\n    return factorial",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_factorial() -> rasp.SOp:\n    # Create a sequence of ones\n    ones = rasp.Map(lambda x: 1, rasp.tokens).named(\"ones\")\n    \n    # Calculate factorial for each index\n    factorial_sequence = rasp.SequenceMap(\n        lambda x, y: x * (y + 1),\n        ones,\n        rasp.indices\n    ).named(\"factorial_sequence\")\n    \n    # Replace each element with its factorial\n    result = rasp.SequenceMap(\n        lambda x, y: y,\n        rasp.tokens,\n        factorial_sequence\n    ).named(\"result\")\n    \n    return result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [1, 2, 3, 4, 5, 6]. (0.984 error rate)"
            },
            {
                "generated rasp code": "def make_factorial():\n    # Create a sequence where each element is the minimum of itself and its index + 1\n    valid_inputs = rasp.SequenceMap(lambda x, y: min(x, y + 1), rasp.tokens, rasp.indices).named(\"valid_inputs\")\n\n    # Define an iterative factorial function (up to 10!)\n    def factorial(n):\n        if n <= 1:\n            return 1\n        result = 1\n        for i in range(2, min(n + 1, 11)):  # Calculate up to 10!\n            result *= i\n        return result\n\n    # Apply the factorial function to each element\n    factorial_sequence = rasp.Map(factorial, valid_inputs).named(\"factorial_sequence\")\n\n    return factorial_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [1, 2, 2, 1, 120, 24]. (0.974 error rate)"
            },
            {
                "generated rasp code": "def make_factorial() -> rasp.SOp:\n    # Create a sequence of indices starting from 1\n    indices_from_one = rasp.Map(lambda x: x + 1, rasp.indices).named(\"indices_from_one\")\n\n    # Create a sequence where each element is the minimum of its index and the input element\n    range_seq = rasp.SequenceMap(lambda x, y: min(x, y), indices_from_one, rasp.tokens).named(\"range_seq\")\n\n    # Create a selector for partial products\n    selector = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.LT).named(\"selector\")\n\n    # Calculate partial products\n    partial_products = rasp.Aggregate(selector, range_seq, default=None).named(\"partial_products\")\n\n    # Convert 0 to 1 in the input (since 0! = 1)\n    converted_input = rasp.Map(lambda x: 1 if x == 0 else x, rasp.tokens).named(\"converted_input\")\n\n    # Multiply partial products with the converted input to get the final factorial\n    factorial = rasp.SequenceMap(lambda x, y: x * y if x is not None else y, \n                                 partial_products, converted_input).named(\"factorial\")\n\n    return factorial",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, 8.0, 3.0, 1.6666666666666667, 7.5, 8.8]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_factorial() -> rasp.SOp:\n    # Create a selector that compares each element with its index (plus 1)\n    factorial_selector = rasp.Select(rasp.tokens, rasp.Map(lambda x: x + 1, rasp.indices), rasp.Comparison.GEQ).named(\"factorial_selector\")\n    \n    # Count how many numbers we need to multiply for each element's factorial\n    factorial_count = rasp.SelectorWidth(factorial_selector).named(\"factorial_count\")\n    \n    # Create a sequence of numbers from 1 to n for each position\n    number_sequence = rasp.Map(lambda x: x + 1, rasp.indices).named(\"number_sequence\")\n    \n    # Create a sequence of running products\n    running_product = rasp.SequenceMap(\n        lambda x, y: x * y if y <= x else x,\n        rasp.Map(lambda x: max(x, 1), factorial_count),\n        number_sequence\n    ).named(\"running_product\")\n    \n    # Select the correct factorial for each element\n    factorial_result = rasp.Aggregate(\n        rasp.Select(factorial_count, rasp.indices, rasp.Comparison.EQ),\n        running_product\n    ).named(\"factorial_result\")\n    \n    # Handle the special case of 0 factorial\n    final_result = rasp.SequenceMap(\n        lambda x, y: 1 if x == 0 else y,\n        rasp.tokens,\n        factorial_result\n    ).named(\"final_result\")\n    \n    return final_result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, 1.0, 2.0, 3.0, 12.0, 10.0]. (0.99 error rate)"
            }
        ],
        "make_count_less_than": [
            {
                "generated rasp code": "def make_count_less_than() -> rasp.SOp:\n    # Create a selector that compares each element with every other element\n    # using a \"Greater Than\" (GT) comparison. This is equivalent to finding\n    # elements less than the current element.\n    gt_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.GT).named(\"gt_selector\")\n\n    # Use SelectorWidth to count the number of elements less than each element\n    count_less_than = rasp.SelectorWidth(gt_selector).named(\"count_less_than\")\n\n    return count_less_than",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3, 0, 4, 5, 1, 2]. (0.897 error rate)"
            },
            {
                "generated rasp code": "def make_count_less_than() -> rasp.SOp:\n    # Create a selector that compares each element with every other element\n    # using \"Greater Than\" comparison. This is equivalent to finding elements less than each element.\n    gt_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.GT).named(\"gt_selector\")\n\n    # Use SelectorWidth to count the number of elements less than each element\n    count_less_than = rasp.SelectorWidth(gt_selector).named(\"count_less_than\")\n\n    return count_less_than",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3, 0, 4, 5, 1, 2]. (0.897 error rate)"
            },
            {
                "generated rasp code": "def make_count_less_than() -> rasp.SOp:\n    # Create a selector that compares each element with every other element\n    # using \"Greater Than\" comparison. This is equivalent to finding elements\n    # that are less than the current element.\n    gt_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.GT).named(\"gt_selector\")\n\n    # Use SelectorWidth to count the number of elements less than each element\n    count_less_than = rasp.SelectorWidth(gt_selector).named(\"count_less_than\")\n\n    return count_less_than",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3, 0, 4, 5, 1, 2]. (0.897 error rate)"
            },
            {
                "generated rasp code": "def make_count_less_than() -> rasp.SOp:\n    # Create a selector that compares each element with every other element\n    # using \"Greater Than\" comparison. This effectively counts elements less than each element.\n    gt_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.GT).named(\"gt_selector\")\n\n    # Use SelectorWidth to count the number of elements less than each element\n    count_less_than = rasp.SelectorWidth(gt_selector).named(\"count_less_than\")\n\n    return count_less_than",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3, 0, 4, 5, 1, 2]. (0.897 error rate)"
            },
            {
                "generated rasp code": "def make_count_less_than() -> rasp.SOp:\n    # Create a selector that compares each element with every other element\n    # using \"Greater Than\" comparison. This effectively selects elements\n    # that are less than each element.\n    gt_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.GT).named(\"gt_selector\")\n\n    # Use SelectorWidth to count the number of elements less than each element\n    count_less_than = rasp.SelectorWidth(gt_selector).named(\"count_less_than\")\n\n    return count_less_than",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3, 0, 4, 5, 1, 2]. (0.897 error rate)"
            }
        ],
        "make_cube_each_element": [],
        "make_cube_root": [],
        "make_round": [],
        "make_multiply_by_length": [
            {
                "generated rasp code": "def make_multiply_by_length() -> rasp.SOp:\n    # Create a sequence where each element is the length of the input sequence\n    sequence_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"sequence_length\")\n    \n    # Multiply each element of the original sequence by the sequence length\n    multiplied_sequence = rasp.SequenceMap(\n        lambda x, y: x * y,\n        rasp.tokens,\n        sequence_length\n    ).named(\"multiplied_sequence\")\n    \n    return multiplied_sequence",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_multiply_by_length() -> rasp.SOp:\n    # Create a sequence where each element is the length of the input sequence\n    sequence_length = rasp.Map(lambda x: x.shape[0], rasp.tokens).named(\"sequence_length\")\n    \n    # Multiply each element in the original sequence by the sequence length\n    multiplied_sequence = rasp.SequenceMap(\n        lambda x, y: x * y,\n        rasp.tokens,\n        sequence_length\n    ).named(\"multiplied_sequence\")\n    \n    return multiplied_sequence",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_multiply_by_length() -> rasp.SOp:\n    # Create a Map to get the sequence length for each element\n    sequence_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"sequence_length\")\n\n    # Use SequenceMap to multiply each element by the sequence length\n    multiplied_sequence = rasp.SequenceMap(\n        lambda x, y: x * y,\n        rasp.tokens,\n        sequence_length\n    ).named(\"multiplied_sequence\")\n\n    return multiplied_sequence",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_multiply_by_length() -> rasp.SOp:\n    # Create a Map to get the sequence length for each element\n    sequence_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"sequence_length\")\n    \n    # Use SequenceMap to multiply each element by the sequence length\n    multiplied_sequence = rasp.SequenceMap(\n        lambda x, y: x * y, \n        rasp.tokens, \n        sequence_length\n    ).named(\"multiplied_sequence\")\n    \n    return multiplied_sequence",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_multiply_by_length() -> rasp.SOp:\n    # Create a Map to get the sequence length for each element\n    sequence_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"sequence_length\")\n\n    # Use SequenceMap to multiply each element by the sequence length\n    multiplied_sequence = rasp.SequenceMap(\n        lambda x, y: x * y, \n        rasp.tokens, \n        sequence_length\n    ).named(\"multiplied_sequence\")\n\n    return multiplied_sequence",
                "failure stage": 0,
                "error": "test_run_op timed out"
            }
        ],
        "make_increment_to_multiple_of_three": [],
        "make_sign": [
            {
                "generated rasp code": "def make_sign() -> rasp.SOp:\n    # Create selectors for negative, zero, and positive values\n    negative_selector = rasp.Select(rasp.tokens, rasp.Map(lambda x: 0, rasp.tokens), rasp.Comparison.LT).named(\"negative_selector\")\n    zero_selector = rasp.Select(rasp.tokens, rasp.Map(lambda x: 0, rasp.tokens), rasp.Comparison.EQ).named(\"zero_selector\")\n    positive_selector = rasp.Select(rasp.tokens, rasp.Map(lambda x: 0, rasp.tokens), rasp.Comparison.GT).named(\"positive_selector\")\n\n    # Create sequences for each sign\n    negative_seq = rasp.Aggregate(negative_selector, rasp.Map(lambda x: -1, rasp.tokens)).named(\"negative_seq\")\n    zero_seq = rasp.Aggregate(zero_selector, rasp.Map(lambda x: 0, rasp.tokens)).named(\"zero_seq\")\n    positive_seq = rasp.Aggregate(positive_selector, rasp.Map(lambda x: 1, rasp.tokens)).named(\"positive_seq\")\n\n    # Combine sequences, prioritizing non-None values\n    def combine(neg, zero, pos):\n        if neg is not None:\n            return neg\n        elif zero is not None:\n            return zero\n        else:\n            return pos\n\n    result = rasp.SequenceMap(combine, negative_seq, rasp.SequenceMap(combine, zero_seq, positive_seq)).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_sign() -> rasp.SOp:\n    # Create selectors for positive, negative, and zero values\n    positive_selector = rasp.Select(rasp.tokens, rasp.Map(lambda x: 0, rasp.tokens), rasp.Comparison.GT).named(\"positive_selector\")\n    negative_selector = rasp.Select(rasp.tokens, rasp.Map(lambda x: 0, rasp.tokens), rasp.Comparison.LT).named(\"negative_selector\")\n    zero_selector = rasp.Select(rasp.tokens, rasp.Map(lambda x: 0, rasp.tokens), rasp.Comparison.EQ).named(\"zero_selector\")\n\n    # Create sequences of 1, -1, and 0 based on the selectors\n    positive_seq = rasp.Aggregate(positive_selector, rasp.Map(lambda x: 1, rasp.tokens)).named(\"positive_seq\")\n    negative_seq = rasp.Aggregate(negative_selector, rasp.Map(lambda x: -1, rasp.tokens)).named(\"negative_seq\")\n    zero_seq = rasp.Aggregate(zero_selector, rasp.Map(lambda x: 0, rasp.tokens)).named(\"zero_seq\")\n\n    # Combine the sequences to get the final result\n    # We add the sequences because only one will be non-None for each position\n    result = rasp.SequenceMap(lambda x, y: (x or 0) + (y or 0), \n                              rasp.SequenceMap(lambda x, y: (x or 0) + (y or 0), positive_seq, negative_seq),\n                              zero_seq).named(\"result\")\n\n    return result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, None, None, None, None, None]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_sign() -> rasp.SOp:\n    # Create selectors for negative, zero, and positive numbers\n    negative_selector = rasp.Select(rasp.tokens, rasp.Map(lambda x: 0, rasp.tokens), rasp.Comparison.LT).named(\"negative_selector\")\n    zero_selector = rasp.Select(rasp.tokens, rasp.Map(lambda x: 0, rasp.tokens), rasp.Comparison.EQ).named(\"zero_selector\")\n    positive_selector = rasp.Select(rasp.tokens, rasp.Map(lambda x: 0, rasp.tokens), rasp.Comparison.GT).named(\"positive_selector\")\n\n    # Combine selectors\n    combined_selector = (negative_selector | zero_selector | positive_selector).named(\"combined_selector\")\n\n    # Create a sequence that maps -1 to negative, 0 to zero, and 1 to positive\n    sign_sequence = rasp.Map(lambda x: [-1, 0, 1][x], rasp.SelectorWidth(combined_selector)).named(\"sign_sequence\")\n\n    return sign_sequence",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_sign() -> rasp.SOp:\n    # Selector for positive numbers\n    positive_selector = rasp.Select(rasp.tokens, rasp.Map(lambda x: 0, rasp.tokens), rasp.Comparison.GT).named(\"positive_selector\")\n    \n    # Selector for negative numbers\n    negative_selector = rasp.Select(rasp.tokens, rasp.Map(lambda x: 0, rasp.tokens), rasp.Comparison.LT).named(\"negative_selector\")\n    \n    # Selector for zero\n    zero_selector = rasp.Select(rasp.tokens, rasp.Map(lambda x: 0, rasp.tokens), rasp.Comparison.EQ).named(\"zero_selector\")\n    \n    # Create sequences of 1s, -1s, and 0s based on the selectors\n    positive_seq = rasp.Aggregate(positive_selector, rasp.Map(lambda x: 1, rasp.tokens)).named(\"positive_seq\")\n    negative_seq = rasp.Aggregate(negative_selector, rasp.Map(lambda x: -1, rasp.tokens)).named(\"negative_seq\")\n    zero_seq = rasp.Aggregate(zero_selector, rasp.Map(lambda x: 0, rasp.tokens)).named(\"zero_seq\")\n    \n    # Combine the sequences to get the final sign sequence\n    sign_seq = rasp.SequenceMap(lambda x, y: x + y, \n                                rasp.SequenceMap(lambda x, y: x + y, positive_seq, negative_seq),\n                                zero_seq).named(\"sign_seq\")\n    \n    return sign_seq",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, None, None, None, None, None]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_sign() -> rasp.SOp:\n    # Create selectors for positive, negative, and zero values\n    positive_selector = rasp.Select(rasp.tokens, rasp.Map(lambda x: 0, rasp.tokens), rasp.Comparison.GT).named(\"positive_selector\")\n    negative_selector = rasp.Select(rasp.tokens, rasp.Map(lambda x: 0, rasp.tokens), rasp.Comparison.LT).named(\"negative_selector\")\n    zero_selector = rasp.Select(rasp.tokens, rasp.Map(lambda x: 0, rasp.tokens), rasp.Comparison.EQ).named(\"zero_selector\")\n\n    # Create sequences with 1, -1, and 0 for positive, negative, and zero values respectively\n    positive_seq = rasp.Aggregate(positive_selector, rasp.Map(lambda x: 1, rasp.tokens)).named(\"positive_seq\")\n    negative_seq = rasp.Aggregate(negative_selector, rasp.Map(lambda x: -1, rasp.tokens)).named(\"negative_seq\")\n    zero_seq = rasp.Aggregate(zero_selector, rasp.Map(lambda x: 0, rasp.tokens)).named(\"zero_seq\")\n\n    # Combine the sequences, prioritizing non-None values\n    def combine(x, y):\n        return x if x is not None else y\n\n    # First, combine positive and negative sequences\n    combined_seq = rasp.SequenceMap(combine, positive_seq, negative_seq).named(\"combined_seq\")\n    \n    # Then, combine the result with the zero sequence\n    final_seq = rasp.SequenceMap(combine, combined_seq, zero_seq).named(\"final_seq\")\n\n    return final_seq",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, None, None, None, None, None]. (1.0 error rate)"
            }
        ],
        "make_cosine": [
            {
                "generated rasp code": "def make_cosine() -> rasp.SOp:\n    def cos_approx(x):\n        # Normalize x to be between -2\u03c0 and 2\u03c0\n        x = x % (2 * 3.14159265358979323846)\n        if x > 3.14159265358979323846:\n            x -= 2 * 3.14159265358979323846\n        elif x < -3.14159265358979323846:\n            x += 2 * 3.14159265358979323846\n        \n        # Taylor series approximation of cosine\n        x2 = x * x\n        return 1 - x2/2 + x2*x2/24 - x2*x2*x2/720 + x2*x2*x2*x2/40320\n\n    # Apply the cosine approximation to each element of the input sequence\n    return rasp.Map(cos_approx, rasp.tokens).named(\"cosine\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [-0.9747767857142857, -0.145440079212265, -0.41587301587301595, 0.5403025793650793, 0.2836654795010996, -0.6526235042215284]. (0.976 error rate)"
            },
            {
                "generated rasp code": "def make_cosine() -> rasp.SOp:\n    def cosine_approx(x):\n        # Normalize x to be between -2\u03c0 and 2\u03c0\n        x = x % (2 * 3.14159265358979323846)\n        if x > 3.14159265358979323846:\n            x -= 2 * 3.14159265358979323846\n        elif x < -3.14159265358979323846:\n            x += 2 * 3.14159265358979323846\n        \n        # Taylor series approximation of cosine\n        x2 = x * x\n        return 1 - x2 / 2 + x2 * x2 / 24 - x2 * x2 * x2 / 720\n\n    # Apply the cosine approximation to each element of the input sequence\n    return rasp.Map(cosine_approx, rasp.tokens).named(\"cosine_sequence\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [-1.1375, -0.1473119111275425, -0.4222222222222223, 0.5402777777777777, 0.28348317621293834, -0.670938581882107]. (0.986 error rate)"
            },
            {
                "generated rasp code": "def make_cosine() -> rasp.SOp:\n    # Note: This function assumes that the math module is already imported.\n    # If not, please import it by adding 'import math' at the top of your script.\n    \n    # Apply the cosine function to each element of the input sequence\n    return rasp.Map(lambda x: math.cos(x), rasp.tokens).named(\"cosine_sequence\")",
                "failure stage": 0,
                "error": "test_run_op timed out"
            }
        ],
        "make_divide_by_length": [
            {
                "generated rasp code": "def make_divide_by_length() -> rasp.SOp:\n    # Create a Map to get the sequence length for each element\n    sequence_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"sequence_length\")\n\n    # Use SequenceMap to divide each element by the sequence length\n    divided_sequence = rasp.SequenceMap(\n        lambda x, y: x / y if y != 0 else None,  # Avoid division by zero\n        rasp.tokens,\n        sequence_length\n    ).named(\"divided_sequence\")\n\n    return divided_sequence",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_divide_by_length() -> rasp.SOp:\n    # Create a Map to get the sequence length for each element\n    sequence_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"sequence_length\")\n\n    # Use SequenceMap to divide each element by the sequence length\n    divided_sequence = rasp.SequenceMap(lambda x, y: x / y, rasp.tokens, sequence_length).named(\"divided_sequence\")\n\n    return divided_sequence",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_divide_by_length() -> rasp.SOp:\n    # Create a Map to get the sequence length for each element\n    sequence_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"sequence_length\")\n\n    # Use SequenceMap to divide each element by the sequence length\n    divided_sequence = rasp.SequenceMap(\n        lambda x, y: x / y,\n        rasp.tokens,\n        sequence_length\n    ).named(\"divided_sequence\")\n\n    return divided_sequence",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_divide_by_length() -> rasp.SOp:\n    # Create a sequence where each element is the length of the input sequence\n    sequence_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"sequence_length\")\n\n    # Divide each element of the input sequence by the sequence length\n    divided_sequence = rasp.SequenceMap(\n        lambda x, y: x / y,\n        rasp.tokens,\n        sequence_length\n    ).named(\"divided_sequence\")\n\n    return divided_sequence",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_divide_by_length() -> rasp.SOp:\n    # Create a Map to get the sequence length for each element\n    sequence_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"sequence_length\")\n    \n    # Use SequenceMap to divide each element by the sequence length\n    divided_sequence = rasp.SequenceMap(\n        lambda x, y: x / y,\n        rasp.tokens,\n        sequence_length\n    ).named(\"divided_sequence\")\n    \n    return divided_sequence",
                "failure stage": 0,
                "error": "test_run_op timed out"
            }
        ],
        "make_negation": [],
        "make_sine": [
            {
                "generated rasp code": "def make_sine() -> rasp.SOp:\n    # Apply the sine function to each element of the input sequence\n    return rasp.Map(lambda x: sin(x), rasp.tokens).named(\"sine_sequence\")",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_sine() -> rasp.SOp:\n    def sine_approx(x):\n        # Taylor series approximation of sine\n        # sin(x) \u2248 x - x^3/3! + x^5/5! - x^7/7! + ...\n        # We'll use the first 4 terms for a reasonable approximation\n        x = x % (2 * 3.14159265358979323846)  # Normalize x to [0, 2\u03c0)\n        return x - (x**3)/6 + (x**5)/120 - (x**7)/5040\n\n    # Apply the sine approximation to each element of the input sequence\n    return rasp.Map(sine_approx, rasp.tokens).named(\"sine_sequence\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0.09107142857142847, 0.9890105705474113, 0.9079365079365079, 0.841468253968254, -5.292658730158728, -1.3841269841269837]. (0.986 error rate)"
            }
        ],
        "make_histogram": [],
        "make_element_double": [],
        "make_zero_even_indices": [
            {
                "generated rasp code": "def make_zero_even_indices() -> rasp.SOp:\n    # Create a selector for even indices\n    even_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: 0, rasp.indices),\n        lambda x, y: x % 2 == 0\n    ).named(\"even_selector\")\n\n    # Create the output sequence\n    output = rasp.SequenceMap(\n        lambda x, y: 0 if y else x,\n        rasp.tokens,\n        even_selector\n    ).named(\"zero_even_indices\")\n\n    return output",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_zero_even_indices() -> rasp.SOp:\n    # Create a selector that identifies even indices\n    even_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: 0, rasp.indices),\n        lambda x, y: x % 2 == y\n    ).named(\"even_selector\")\n\n    # Create the final sequence where even indices are set to zero\n    zero_even_sequence = rasp.SequenceMap(\n        lambda x, y: 0 if y else x,\n        rasp.tokens,\n        even_selector\n    ).named(\"zero_even_sequence\")\n\n    return zero_even_sequence",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_zero_even_indices() -> rasp.SOp:\n    # Create a selector for even indices\n    even_selector = rasp.Select(\n        rasp.Map(lambda x: x % 2, rasp.indices),\n        rasp.Map(lambda x: 0, rasp.indices),\n        rasp.Comparison.EQ\n    ).named(\"even_selector\")\n\n    # Create a sequence of zeros\n    zeros = rasp.Map(lambda x: 0, rasp.tokens).named(\"zeros\")\n\n    # Combine original sequence and zeros based on the selector\n    result = rasp.SequenceMap(\n        lambda x, y: y if x else x,\n        even_selector,\n        rasp.tokens\n    ).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_zero_even_indices() -> rasp.SOp:\n    # Create a selector for even indices\n    even_selector = rasp.Select(\n        rasp.Map(lambda x: x % 2, rasp.indices),  # Map indices to their modulo 2\n        rasp.Map(lambda x: 0, rasp.indices),      # Compare with 0\n        rasp.Comparison.EQ                        # Select where modulo is equal to 0\n    ).named(\"even_selector\")\n\n    # Create the final sequence\n    zero_even_sequence = rasp.SequenceMap(\n        lambda sel, val: 0 if sel else val,  # If selector is True (even index), set to 0; else keep original value\n        even_selector,\n        rasp.tokens\n    ).named(\"zero_even_sequence\")\n\n    return zero_even_sequence",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_zero_even_indices() -> rasp.SOp:\n    # Create a selector for even indices\n    even_selector = rasp.Select(\n        rasp.indices,  # keys: the indices of the sequence\n        rasp.Map(lambda x: 0, rasp.indices),  # queries: a sequence of zeros\n        rasp.Comparison.EQ  # predicate: check if index % 2 == 0\n    ).named(\"even_selector\")\n\n    # Create the output sequence\n    output = rasp.SequenceMap(\n        lambda sel, val: 0 if sel else val,  # if selected (even index), set to 0; otherwise, keep original value\n        even_selector,  # our even index selector\n        rasp.tokens  # the original input sequence\n    ).named(\"zero_even_indices\")\n\n    return output",
                "failure stage": 0,
                "error": ""
            }
        ],
        "make_tangent": [
            {
                "generated rasp code": "def make_tangent() -> rasp.SOp:\n    def tan(x):\n        import math\n        if abs(math.cos(x)) < 1e-10:  # Check if cosine is close to zero\n            return 1e10 if math.sin(x) > 0 else -1e10  # Return a very large number to represent infinity\n        return math.sin(x) / math.cos(x)\n    \n    return rasp.Map(lambda x: tan(x), rasp.tokens).named(\"tangent\")",
                "failure stage": 4,
                "error": "ground truth: ['BOS', 1.1578212823495775] model output: ['BOS', 1.1578212823495777] for [4]"
            },
            {
                "generated rasp code": "def make_tangent() -> rasp.SOp:\n    # Define a custom tangent function using sin and cos\n    def tan(x):\n        return (x - x**3/6 + x**5/120) / (1 - x**2/2 + x**4/24)  # Taylor series approximation\n\n    # Apply the tangent function to each element of the input sequence\n    return rasp.Map(lambda x: tan(x), rasp.tokens).named(\"tangent\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [-4.199999999999999, 1.4014319809069213, -2.8, 1.5538461538461539, 0.7020057306590259, 0.5090909090909093]. (0.986 error rate)"
            },
            {
                "generated rasp code": "def make_tangent():\n    def factorial(n):\n        if n == 0 or n == 1:\n            return 1\n        return n * factorial(n - 1)\n\n    def sin_approx(x, terms=10):\n        result = 0\n        for n in range(terms):\n            result += (-1)**n * x**(2*n + 1) / factorial(2*n + 1)\n        return result\n\n    def cos_approx(x, terms=10):\n        result = 0\n        for n in range(terms):\n            result += (-1)**n * x**(2*n) / factorial(2*n)\n        return result\n\n    def tan_approx(x):\n        sin_x = sin_approx(x)\n        cos_x = cos_approx(x)\n        if abs(cos_x) < 1e-10:  # Close to zero\n            return float('inf') if sin_x >= 0 else float('-inf')\n        return sin_x / cos_x\n\n    return rasp.Map(\n        lambda x: tan_approx(x),\n        rasp.tokens\n    ).named(\"tangent\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [-0.1425465426686876, -1.4793836149687003, -2.185039863259177, 1.5574077246549025, -3.3809893845051127, 1.157820636404092]. (0.959 error rate)"
            },
            {
                "generated rasp code": "def make_tangent():\n    def taylor_sin(x):\n        # Taylor series approximation of sin(x)\n        x = x % (2 * 3.14159265358979323846)  # Normalize to [0, 2\u03c0]\n        return x - (x**3)/6 + (x**5)/120 - (x**7)/5040\n\n    def taylor_cos(x):\n        # Taylor series approximation of cos(x)\n        x = x % (2 * 3.14159265358979323846)  # Normalize to [0, 2\u03c0]\n        return 1 - (x**2)/2 + (x**4)/24 - (x**6)/720\n\n    def tan_approx(x):\n        sin_x = taylor_sin(x)\n        cos_x = taylor_cos(x)\n        if abs(cos_x) < 1e-10:  # Close to \u03c0/2 or its equivalents\n            return 1e10 if sin_x > 0 else -1e10  # Return a very large number with appropriate sign\n        return sin_x / cos_x\n\n    return rasp.Map(lambda x: tan_approx(x), rasp.tokens).named(\"tangent\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [-0.08006279434850855, -6.713717600819984, -2.150375939849624, 1.5574733749540948, 0.7392268255507826, 0.6844583987441125]. (0.986 error rate)"
            },
            {
                "generated rasp code": "def make_tangent() -> rasp.SOp:\n    def approx_tan(x):\n        # Simple tangent approximation\n        try:\n            sin_x = sin(x)\n            cos_x = cos(x)\n            if abs(cos_x) < 1e-10:  # Close to zero\n                return float('inf') if sin_x >= 0 else float('-inf')\n            return sin_x / cos_x\n        except:\n            return float('inf')  # Handle any unexpected errors\n\n    # Apply the tangent function to each element\n    return rasp.Map(lambda x: approx_tan(x), rasp.tokens).named(\"tangent\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [inf, inf, inf, inf, inf, inf]. (1.0 error rate)"
            }
        ],
        "make_count_occurrences": [],
        "make_compute_median": [
            {
                "generated rasp code": "def make_compute_median() -> rasp.SOp:\n    # Selector that creates a comparison matrix where each element is compared to every other element\n    leq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LEQ).named(\"leq_selector\")\n\n    # Count the number of comparisons where each element is less than or equal to other elements\n    leq_count = rasp.SelectorWidth(leq_selector).named(\"leq_count\")\n\n    # Calculate the sequence length\n    sequence_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"sequence_length\")\n\n    # Calculate the median index (sequence length / 2)\n    median_index = rasp.Map(lambda x: x // 2, sequence_length).named(\"median_index\")\n\n    # Selector for the lower median (count == median index)\n    lower_median_selector = rasp.Select(leq_count, median_index, rasp.Comparison.EQ).named(\"lower_median_selector\")\n\n    # Selector for the upper median (count == median index + 1)\n    upper_median_selector = rasp.Select(leq_count, rasp.Map(lambda x: x + 1, median_index), rasp.Comparison.EQ).named(\"upper_median_selector\")\n\n    # Aggregate to get the lower median value\n    lower_median = rasp.Aggregate(lower_median_selector, rasp.tokens).named(\"lower_median\")\n\n    # Aggregate to get the upper median value\n    upper_median = rasp.Aggregate(upper_median_selector, rasp.tokens).named(\"upper_median\")\n\n    # Average the lower and upper median values\n    median = rasp.SequenceMap(lambda x, y: (x + y) / 2 if x is not None and y is not None else x or y, lower_median, upper_median).named(\"median\")\n\n    return median",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_compute_median() -> rasp.SOp:\n    # Selector that creates a comparison matrix where each element is compared to every other element.\n    leq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LEQ).named(\"leq_selector\")\n\n    # Count the number of comparisons where each element is less than or equal to other elements.\n    leq_count = rasp.SelectorWidth(leq_selector).named(\"leq_count\")\n\n    # Calculate the floor of half the sequence length\n    half_length_floor = rasp.Map(lambda x: (len(x) - 1) // 2, rasp.tokens).named(\"half_length_floor\")\n\n    # Calculate the ceiling of half the sequence length\n    half_length_ceiling = rasp.Map(lambda x: len(x) // 2, rasp.tokens).named(\"half_length_ceiling\")\n\n    # Selector for the lower median element\n    lower_median_selector = rasp.Select(leq_count, half_length_floor, rasp.Comparison.EQ).named(\"lower_median_selector\")\n\n    # Selector for the upper median element\n    upper_median_selector = rasp.Select(leq_count, half_length_ceiling, rasp.Comparison.EQ).named(\"upper_median_selector\")\n\n    # Use Aggregate to select the lower median element\n    lower_median = rasp.Aggregate(lower_median_selector, rasp.tokens).named(\"lower_median\")\n\n    # Use Aggregate to select the upper median element\n    upper_median = rasp.Aggregate(upper_median_selector, rasp.tokens).named(\"upper_median\")\n\n    # Average the lower and upper median elements\n    median = rasp.SequenceMap(lambda x, y: (x + y) / 2, lower_median, upper_median).named(\"median\")\n\n    return median",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_compute_median() -> rasp.SOp:\n    # Selector that creates a comparison matrix where each element is compared to every other element\n    geq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.GEQ).named(\"geq_selector\")\n\n    # Count the number of elements each element is greater than or equal to\n    geq_count = rasp.SelectorWidth(geq_selector).named(\"geq_count\")\n\n    # Create a sequence representing the length of the input sequence\n    sequence_length = rasp.SequenceMap(lambda x, y: y + 1, rasp.tokens, rasp.indices).named(\"sequence_length\")\n\n    # Calculate half the sequence length (rounded down for even-length sequences)\n    half_length = rasp.Map(lambda x: x // 2, sequence_length).named(\"half_length\")\n\n    # Selector that identifies elements where geq_count is greater than or equal to half_length\n    median_selector = rasp.Select(geq_count, half_length, rasp.Comparison.GEQ).named(\"median_selector\")\n\n    # Use Aggregate to broadcast the median element across the entire sequence\n    median_sequence = rasp.Aggregate(median_selector, rasp.tokens).named(\"median_sequence\")\n\n    return median_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3.8333333333333335, 3.8333333333333335, 3.8333333333333335, 3.0, 3.0, 2.5]. (0.792 error rate)"
            },
            {
                "generated rasp code": "def make_compute_median() -> rasp.SOp:\n    # Create a selector for element comparisons\n    leq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LEQ).named(\"leq_selector\")\n    \n    # Count elements less than or equal to each element\n    leq_count = rasp.SelectorWidth(leq_selector).named(\"leq_count\")\n    \n    # Calculate sequence length\n    seq_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"seq_length\")\n    \n    # Calculate middle positions for odd and even length sequences\n    mid_pos_odd = rasp.Map(lambda x: (x + 1) // 2, seq_length).named(\"mid_pos_odd\")\n    mid_pos_even_lower = rasp.Map(lambda x: x // 2, seq_length).named(\"mid_pos_even_lower\")\n    mid_pos_even_upper = rasp.Map(lambda x: (x // 2) + 1, seq_length).named(\"mid_pos_even_upper\")\n    \n    # Create selectors for median elements\n    median_selector_odd = rasp.Select(leq_count, mid_pos_odd, rasp.Comparison.EQ).named(\"median_selector_odd\")\n    median_selector_even_lower = rasp.Select(leq_count, mid_pos_even_lower, rasp.Comparison.EQ).named(\"median_selector_even_lower\")\n    median_selector_even_upper = rasp.Select(leq_count, mid_pos_even_upper, rasp.Comparison.EQ).named(\"median_selector_even_upper\")\n    \n    # Aggregate to get median values\n    median_odd = rasp.Aggregate(median_selector_odd, rasp.tokens).named(\"median_odd\")\n    median_even_lower = rasp.Aggregate(median_selector_even_lower, rasp.tokens).named(\"median_even_lower\")\n    median_even_upper = rasp.Aggregate(median_selector_even_upper, rasp.tokens).named(\"median_even_upper\")\n    \n    # Calculate average of two medians for even-length sequences\n    median_even = rasp.SequenceMap(lambda x, y: (x + y) / 2, median_even_lower, median_even_upper).named(\"median_even\")\n    \n    # Determine if sequence length is odd\n    is_odd = rasp.SequenceMap(lambda x, y: x % 2 == 1, seq_length, rasp.tokens).named(\"is_odd\")\n    \n    # Combine odd and even cases\n    final_median = rasp.SequenceMap(\n        lambda odd, even, is_odd: odd if is_odd else even,\n        median_odd,\n        median_even,\n        is_odd\n    ).named(\"final_median\")\n    \n    return final_median",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            },
            {
                "generated rasp code": "def make_compute_median() -> rasp.SOp:\n    # Selector that creates a comparison matrix where each element is compared to every other element\n    leq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LEQ).named(\"leq_selector\")\n\n    # Count the number of comparisons where each element is less than or equal to other elements\n    leq_count = rasp.SelectorWidth(leq_selector).named(\"leq_count\")\n\n    # Create a Map to get the sequence length for each element\n    sequence_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"sequence_length\")\n\n    # Calculate the median index (floor division by 2)\n    median_index = rasp.Map(lambda x: x // 2, sequence_length).named(\"median_index\")\n\n    # Add 1 to the median index to get the correct count for the median element\n    median_count = rasp.Map(lambda x: x + 1, median_index).named(\"median_count\")\n\n    # Selector that selects the element where the leq_count equals the median_count\n    median_element_selector = rasp.Select(leq_count, median_count, rasp.Comparison.EQ).named(\"median_element_selector\")\n\n    # Use Aggregate to broadcast the median element across the entire sequence\n    median_sequence = rasp.Aggregate(median_element_selector, rasp.tokens).named(\"median_sequence\")\n\n    return median_sequence",
                "failure stage": 0,
                "error": "test_run_op timed out"
            }
        ],
        "make_halve_second_half": [
            {
                "generated rasp code": "def make_halve_second_half() -> rasp.SOp:\n    # Create a sequence of the same length as the input, where each element is the sequence length\n    seq_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"seq_length\")\n    \n    # Calculate the midpoint (rounded down for odd-length sequences)\n    midpoint = rasp.Map(lambda x: x // 2, seq_length).named(\"midpoint\")\n    \n    # Create a selector for the second half of the sequence\n    second_half_selector = rasp.Select(rasp.indices, midpoint, rasp.Comparison.GEQ).named(\"second_half_selector\")\n    \n    # Create a sequence where each element is half of the original\n    halved_seq = rasp.Map(lambda x: x / 2, rasp.tokens).named(\"halved_seq\")\n    \n    # Combine the original sequence and the halved sequence based on the selector\n    result = rasp.SequenceMap(\n        lambda x, y: y if x else x,\n        second_half_selector,\n        rasp.SequenceMap(lambda x, y: y if x else x, second_half_selector, halved_seq, rasp.tokens)\n    ).named(\"result\")\n    \n    return result",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            },
            {
                "generated rasp code": "def make_halve_second_half() -> rasp.SOp:\n    # Create a selector for the second half of the sequence\n    second_half_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: (len(x) - 1) / 2, rasp.tokens),\n        rasp.Comparison.GT\n    ).named(\"second_half_selector\")\n\n    # Create a sequence of 1's and 0.5's\n    halving_sequence = rasp.Map(\n        lambda x: 0.5 if x else 1,\n        second_half_selector\n    ).named(\"halving_sequence\")\n\n    # Multiply the original sequence by the halving sequence\n    halved_sequence = rasp.SequenceMap(\n        lambda x, y: x * y,\n        rasp.tokens,\n        halving_sequence\n    ).named(\"halved_sequence\")\n\n    return halved_sequence",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_halve_second_half() -> rasp.SOp:\n    # Create a selector for the second half of the sequence\n    def is_second_half(index, length):\n        return index >= (length + 1) // 2\n    \n    second_half_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: len(x), rasp.tokens),\n        lambda i, l: is_second_half(i, l)\n    ).named(\"second_half_selector\")\n\n    # Create a sequence of halved values\n    halved_sequence = rasp.Map(lambda x: x / 2, rasp.tokens).named(\"halved_sequence\")\n\n    # Combine original and halved sequences based on the selector\n    result = rasp.SequenceMap(\n        lambda orig, halved: halved if halved is not None else orig,\n        rasp.tokens,\n        rasp.Aggregate(second_half_selector, halved_sequence)\n    ).named(\"halved_second_half\")\n\n    return result",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "import math\n\ndef make_halve_second_half() -> rasp.SOp:\n    # Create a selector for the second half of the sequence\n    second_half_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: math.ceil(len(x) / 2) - 1, rasp.tokens),\n        rasp.Comparison.GT\n    ).named(\"second_half_selector\")\n\n    # Create a sequence of 1's and 0.5's\n    halving_sequence = rasp.Map(\n        lambda x: 0.5 if x else 1,\n        second_half_selector\n    ).named(\"halving_sequence\")\n\n    # Multiply the original sequence by the halving sequence\n    halved_sequence = rasp.SequenceMap(\n        lambda x, y: x * y,\n        rasp.tokens,\n        halving_sequence\n    ).named(\"halved_sequence\")\n\n    return halved_sequence",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_halve_second_half() -> rasp.SOp:\n    # Get the length of the sequence\n    seq_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"seq_length\")\n\n    # Calculate the midpoint (half the length, rounded down)\n    midpoint = rasp.Map(lambda x: x // 2, seq_length).named(\"midpoint\")\n\n    # Create a selector for the second half of the sequence\n    second_half_selector = rasp.SequenceMap(\n        lambda i, mid: i >= mid,\n        rasp.indices,\n        midpoint\n    ).named(\"second_half_selector\")\n\n    # Create a sequence of halved values\n    halved_values = rasp.Map(lambda x: x / 2, rasp.tokens).named(\"halved_values\")\n\n    # Combine original and halved values based on the selector\n    result = rasp.SequenceMap(\n        lambda orig, halved, select: halved if select else orig,\n        rasp.tokens,\n        halved_values,\n        second_half_selector\n    ).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            }
        ],
        "make_triple": [],
        "make_arctangent": [
            {
                "generated rasp code": "def make_arctangent() -> rasp.SOp:\n    # Define pi\n    PI = 3.141592653589793\n\n    def custom_atan(x):\n        # Handle special cases\n        if x == float('inf'):\n            return PI / 2\n        elif x == float('-inf'):\n            return -PI / 2\n        \n        # Taylor series approximation of arctangent\n        # This works well for |x| <= 1\n        if abs(x) <= 1:\n            result = 0\n            power = x\n            n = 1\n            for _ in range(50):  # 50 terms for good precision\n                term = power / n\n                result += term if n % 4 == 1 else -term\n                power *= x * x\n                n += 2\n            return result\n        else:\n            # For |x| > 1, use the identity atan(x) = \u03c0/2 - atan(1/x)\n            return PI / 2 - custom_atan(1 / x) if x > 0 else -PI / 2 - custom_atan(1 / x)\n\n    # Apply the custom arctangent function to each element\n    return rasp.Map(lambda x: custom_atan(x), rasp.tokens).named(\"arctangent\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [1.2490457723982544, 1.446441332248135, 1.1071487177940906, 0.7803986631477527, 1.3734007669450157, 1.3258176636680326]. (0.401 error rate)"
            },
            {
                "generated rasp code": "def make_arctangent():\n    # Define pi (approximate value)\n    PI = 3.14159265358979323846\n\n    def custom_atan(x):\n        # Simple arctangent approximation using series expansion\n        # This is less accurate than math.atan but doesn't require imports\n        if x == float('inf'):\n            return PI / 2\n        elif x == float('-inf'):\n            return -PI / 2\n        elif abs(x) > 1:\n            return PI / 2 - custom_atan(1 / x)\n        else:\n            # Series approximation: atan(x) \u2248 x - x^3/3 + x^5/5 - x^7/7 + ...\n            x_squared = x * x\n            return x - (x * x_squared) / 3 + (x * x_squared * x_squared) / 5 - (x * x_squared * x_squared * x_squared) / 7\n\n    # Apply the custom arctangent function to each element of the input sequence\n    return rasp.Map(lambda x: custom_atan(x), rasp.tokens).named(\"arctangent\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [1.2490509482593946, 1.4464413330655324, 1.1073290648901346, 0.7238095238095239, 1.3734008220329919, 1.3258180669362656]. (0.987 error rate)"
            },
            {
                "generated rasp code": "def make_arctangent() -> rasp.SOp:\n    def arctangent_approx(x):\n        PI = 3.141592653589793\n        if abs(x) > 1e15:  # Approximate check for infinity\n            return PI / 2 if x > 0 else -PI / 2\n        elif abs(x) <= 1:\n            return x / (1 + x**2)**0.5\n        else:\n            return (PI / 2 if x > 0 else -PI / 2) - 1 / x\n\n    return rasp.Map(arctangent_approx, rasp.tokens).named(\"arctangent\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [1.2374629934615633, 1.4457963267948966, 1.0707963267948966, 0.7071067811865475, 1.3707963267948966, 1.3207963267948966]. (0.987 error rate)"
            },
            {
                "generated rasp code": "def make_arctangent() -> rasp.SOp:\n    # Approximation of \u03c0\n    PI = 3.14159265358979323846\n\n    def arctangent_approx(x):\n        # Simple arctangent approximation\n        # For small x: atan(x) \u2248 x - x^3/3 + x^5/5\n        # For large x: atan(x) \u2248 \u03c0/2 - 1/x\n        x2 = x * x\n        small_x_approx = x - (x * x2) / 3 + (x * x2 * x2) / 5\n        large_x_approx = PI / 2 - 1 / x\n        # Smoothly transition between the two approximations\n        weight = 1 / (1 + x2)\n        return weight * small_x_approx + (1 - weight) * large_x_approx\n\n    return rasp.Map(lambda x: arctangent_approx(x), rasp.tokens).named(\"arctangent\")",
                "failure stage": 0,
                "error": "test_run_op timed out"
            }
        ],
        "make_square_each_element": [],
        "make_check_power_of_n": [
            {
                "generated rasp code": "def make_check_power_of_n(n=2):\n    def generate_powers(x):\n        powers = [1]  # Start with 1 (n^0)\n        current = n\n        while current <= x:\n            powers.append(current)\n            current *= n\n        return powers\n\n    # Generate powers of n up to a reasonable maximum (e.g., 2^20)\n    max_power = 2**20\n    powers_of_n = rasp.Map(lambda x: generate_powers(max_power), rasp.indices).named(\"powers_of_n\")\n\n    # Create a selector that checks if each input element is equal to any power of n\n    is_power_selector = rasp.Select(rasp.tokens, powers_of_n, rasp.Comparison.EQ).named(\"is_power_selector\")\n\n    # Count how many times each element matched a power of n\n    match_count = rasp.SelectorWidth(is_power_selector).named(\"match_count\")\n\n    # Map the count to 1 if it's greater than 0 (element is a power of n), and 0 otherwise\n    result = rasp.Map(lambda x: 1 if x > 0 else 0, match_count).named(\"result\")\n\n    return result\n\n# The function can be called like this:\n# check_power = make_check_power_of_n()  # Default n=2\n# check_power = make_check_power_of_n(3)  # For powers of 3",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0, 0, 0, 0, 0, 0]. (0.856 error rate)"
            },
            {
                "generated rasp code": "def make_check_power_of_n(n=2):\n    def generate_powers_of_n():\n        # Generate powers of n up to a large value (e.g., 2^30)\n        max_power = 30\n        return rasp.Map(lambda x: n**x if x < max_power else float('inf'), rasp.indices).named(\"powers_of_n\")\n\n    powers_of_n = generate_powers_of_n()\n\n    # Create a selector that checks if each input element is equal to any power of n\n    is_power_of_n_selector = rasp.Select(rasp.tokens, powers_of_n, rasp.Comparison.EQ).named(\"is_power_of_n_selector\")\n\n    # Count how many times each element matches a power of n\n    match_count = rasp.SelectorWidth(is_power_of_n_selector).named(\"match_count\")\n\n    # Map the count to 1 if it's greater than 0 (indicating a power of n), and 0 otherwise\n    result = rasp.Map(lambda x: 1 if x > 0 else 0, match_count).named(\"result\")\n\n    return result\n\n# Function to call the program\ndef make_check_power_of_n(n=2):\n    return generate_powers_of_n_checker(n)",
                "failure stage": 0,
                "error": "name 'generate_powers_of_n_checker' is not defined"
            },
            {
                "generated rasp code": "def make_check_power_of_n(n=2):\n    def generate_powers_of_n(x):\n        # Generate powers of n up to 2^30 (or n^30 for different n)\n        powers = [1]  # Start with 1 (n^0)\n        for _ in range(30):\n            powers.append(powers[-1] * n)\n        return powers\n\n    # Generate powers of n\n    powers_of_n = rasp.Map(generate_powers_of_n, rasp.indices).named(\"powers_of_n\")\n\n    # Create a selector that checks if each input element is equal to any power of n\n    is_power_of_n = rasp.Select(rasp.tokens, powers_of_n, rasp.Comparison.EQ).named(\"is_power_of_n\")\n\n    # Count how many times each element matches a power of n\n    match_count = rasp.SelectorWidth(is_power_of_n).named(\"match_count\")\n\n    # Map the count to 1 if it's greater than 0, and 0 otherwise\n    result = rasp.Map(lambda x: 1 if x > 0 else 0, match_count).named(\"result\")\n\n    return result\n\n# The function to be called\ndef make_check_power_of_n(n=2):\n    return make_check_power_of_n(n)",
                "failure stage": 0,
                "error": "maximum recursion depth exceeded"
            },
            {
                "generated rasp code": "def make_check_power_of_n(n=2):\n    def generate_powers(max_power=30):\n        # Generate a sequence of powers of n up to max_power\n        return rasp.Map(lambda x: n**x if x > 0 else 1, rasp.indices).named(\"powers_of_n\")\n\n    # Create a selector for elements that are powers of n\n    power_selector = rasp.Select(rasp.tokens, generate_powers(), rasp.Comparison.EQ).named(\"power_selector\")\n\n    # Convert selector to 0s and 1s\n    is_power = rasp.SelectorWidth(power_selector).named(\"is_power\")\n\n    # Handle the case of 1 (n^0) separately\n    is_one = rasp.Select(rasp.tokens, rasp.Map(lambda x: 1, rasp.tokens), rasp.Comparison.EQ).named(\"is_one\")\n\n    # Combine results: element is a power if it's in the power sequence or if it's 1\n    final_result = rasp.Map(lambda x: 1 if x > 0 else 0, \n                            rasp.SequenceMap(lambda x, y: x + y, is_power, rasp.SelectorWidth(is_one))).named(\"final_result\")\n\n    return final_result\n\n# Example usage:\n# check_power_of_n = make_check_power_of_n()\n# check_power_of_n([1, 8, 2, 32, 7])  # returns [1, 1, 1, 1, 0]\n# \n# check_power_of_3 = make_check_power_of_n(n=3)\n# check_power_of_3([1, 3, 9, 27, 5])  # returns [1, 1, 1, 1, 0]",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [1, 1, 1, 1, 1, 1]. (0.799 error rate)"
            },
            {
                "generated rasp code": "def make_check_power_of_n(n=2):\n    def check_power_of_n():\n        # Generate powers of n up to a large value (e.g., 2^31)\n        max_power = 31\n        powers_of_n = rasp.Map(lambda x: n**x if x < max_power else None, rasp.indices).named(\"powers_of_n\")\n\n        # Create a selector that checks if each input element is equal to any power of n\n        is_power_selector = rasp.Select(rasp.tokens, powers_of_n, rasp.Comparison.EQ).named(\"is_power_selector\")\n\n        # Count how many powers of n each element matches (should be 0 or 1)\n        match_count = rasp.SelectorWidth(is_power_selector).named(\"match_count\")\n\n        # Convert to 1 if it's a power of n, 0 otherwise\n        result = rasp.Map(lambda x: 1 if x > 0 else 0, match_count).named(\"result\")\n\n        return result\n\n    return check_power_of_n\n\n# Usage:\n# check_power_of_n = make_check_power_of_n()\n# check_power_of_n([1, 8, 2, 32, 7])  # returns [1, 1, 1, 1, 0]\n# \n# check_power_of_3 = make_check_power_of_n(n=3)\n# check_power_of_3([1, 3, 9, 27, 5])  # returns [1, 1, 1, 1, 0]",
                "failure stage": 0,
                "error": "test_run_op timed out"
            }
        ],
        "make_binarize": [
            {
                "generated rasp code": "def make_binarize(threshold=3):\n    def binarize_program():\n        # Create a constant sequence of the threshold value\n        threshold_seq = rasp.Map(lambda x: threshold, rasp.tokens).named(\"threshold_seq\")\n        \n        # Compare each element with the threshold\n        comparison = rasp.Select(rasp.tokens, threshold_seq, rasp.Comparison.GEQ).named(\"comparison\")\n        \n        # Convert boolean values to 0 and 1\n        binarized = rasp.Map(lambda x: int(x), comparison).named(\"binarized\")\n        \n        return binarized\n\n    return binarize_program()\n\n# Usage:\n# binarize = make_binarize()  # Uses default threshold of 3\n# or\n# binarize = make_binarize(threshold=5)  # Uses custom threshold of 5",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_binarize(threshold=3) -> rasp.SOp:\n    # Create a constant sequence of the threshold value\n    threshold_seq = rasp.Map(lambda x: threshold, rasp.indices).named(\"threshold_seq\")\n\n    # Create a selector that compares each element with the threshold\n    gte_selector = rasp.Select(rasp.tokens, threshold_seq, rasp.Comparison.GEQ).named(\"gte_selector\")\n\n    # Convert the boolean selector to 0s and 1s\n    binarized = rasp.Map(lambda x: int(x), gte_selector).named(\"binarized\")\n\n    return binarized",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_binarize(threshold=3):\n    def binarize_program():\n        # Create a sequence of the threshold value for each element\n        threshold_seq = rasp.Map(lambda x: threshold, rasp.tokens).named(\"threshold_seq\")\n        \n        # Create a selector that compares each element with the threshold\n        ge_selector = rasp.Select(rasp.tokens, threshold_seq, rasp.Comparison.GEQ).named(\"ge_selector\")\n        \n        # Convert boolean values to 0 and 1\n        binarized = rasp.Map(lambda x: 1 if x else 0, ge_selector).named(\"binarized\")\n        \n        return binarized\n\n    return binarize_program()",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_binarize(threshold=3):\n    def binarize(tokens):\n        # Create a constant sequence of the threshold value\n        threshold_seq = rasp.Map(lambda x: threshold, rasp.tokens).named(\"threshold_seq\")\n        \n        # Create a selector that compares each element to the threshold\n        ge_selector = rasp.Select(rasp.tokens, threshold_seq, rasp.Comparison.GEQ).named(\"ge_selector\")\n        \n        # Convert the boolean selector to 0 and 1 values\n        binarized = rasp.Map(lambda x: 1 if x else 0, ge_selector).named(\"binarized\")\n        \n        return binarized\n\n    return binarize",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_binarize(threshold=3) -> rasp.SOp:\n    # Create a constant sequence of the threshold value\n    threshold_seq = rasp.Map(lambda x: threshold, rasp.indices).named(\"threshold_seq\")\n\n    # Create a selector that compares each element with the threshold\n    ge_selector = rasp.Select(rasp.tokens, threshold_seq, rasp.Comparison.GEQ).named(\"ge_selector\")\n\n    # Convert the boolean selector to 0s and 1s\n    binarized = rasp.SequenceMap(lambda x, y: 1 if x else 0, ge_selector, rasp.tokens).named(\"binarized\")\n\n    return binarized",
                "failure stage": 0,
                "error": ""
            }
        ],
        "make_average_first_last": [
            {
                "generated rasp code": "def make_average_first_last() -> rasp.SOp:\n    # Selector for the first element\n    first_selector = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.EQ).named(\"first_selector\")\n\n    # Selector for the last element\n    last_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: len(x) - 1, rasp.tokens), rasp.Comparison.EQ).named(\"last_selector\")\n\n    # Get the first element\n    first_element = rasp.Aggregate(first_selector, rasp.tokens).named(\"first_element\")\n\n    # Get the last element\n    last_element = rasp.Aggregate(last_selector, rasp.tokens).named(\"last_element\")\n\n    # Calculate the average of first and last elements\n    average = rasp.Map(lambda x: (x[0] + x[1]) / 2, rasp.SequenceMap(lambda f, l: (f, l), first_element, last_element)).named(\"average\")\n\n    # Broadcast the average across the entire sequence\n    result = rasp.Map(lambda x: x, average).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_average_first_last() -> rasp.SOp:\n    # Select the first element\n    first_selector = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.EQ).named(\"first_selector\")\n    \n    # Select the last element\n    last_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: len(x) - 1, rasp.tokens), rasp.Comparison.EQ).named(\"last_selector\")\n    \n    # Extract the first element\n    first_element = rasp.Aggregate(first_selector, rasp.tokens).named(\"first_element\")\n    \n    # Extract the last element\n    last_element = rasp.Aggregate(last_selector, rasp.tokens).named(\"last_element\")\n    \n    # Calculate the average of first and last elements\n    average = rasp.SequenceMap(lambda x, y: (x + y) / 2, first_element, last_element).named(\"average\")\n    \n    # Broadcast the average to all positions\n    result = rasp.Map(lambda x: x, average).named(\"result\")\n    \n    return result",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_average_first_last() -> rasp.SOp:\n    # Selector for the first element (index 0)\n    first_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: 0, rasp.indices), rasp.Comparison.EQ).named(\"first_selector\")\n    \n    # Selector for the last element (index == length - 1)\n    last_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: len(x) - 1, rasp.tokens), rasp.Comparison.EQ).named(\"last_selector\")\n    \n    # Extract the first element\n    first_element = rasp.Aggregate(first_selector, rasp.tokens).named(\"first_element\")\n    \n    # Extract the last element\n    last_element = rasp.Aggregate(last_selector, rasp.tokens).named(\"last_element\")\n    \n    # Calculate the average of first and last elements\n    average = rasp.LinearSequenceMap(first_element, last_element, 0.5, 0.5).named(\"average\")\n    \n    # Broadcast the average to all positions\n    result = rasp.Map(lambda x: x, average).named(\"result\")\n    \n    return result",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_average_first_last() -> rasp.SOp:\n    # Create a selector for the first element (index 0)\n    first_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: 0, rasp.indices), rasp.Comparison.EQ).named(\"first_selector\")\n\n    # Create a selector for the last element (index = length - 1)\n    last_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: len(x) - 1, rasp.tokens), rasp.Comparison.EQ).named(\"last_selector\")\n\n    # Extract the first element\n    first_element = rasp.Aggregate(first_selector, rasp.tokens).named(\"first_element\")\n\n    # Extract the last element\n    last_element = rasp.Aggregate(last_selector, rasp.tokens).named(\"last_element\")\n\n    # Combine first and last elements\n    combined_elements = rasp.SequenceMap(lambda x, y: (x, y), first_element, last_element).named(\"combined_elements\")\n\n    # Calculate the average and broadcast it to all positions\n    average = rasp.Map(lambda pair: (pair[0] + pair[1]) / 2, combined_elements).named(\"average\")\n\n    return average",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_average_first_last() -> rasp.SOp:\n    # Selector for the first element (index 0)\n    first_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: 0, rasp.indices), rasp.Comparison.EQ).named(\"first_selector\")\n\n    # Selector for the last element (index = length - 1)\n    last_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: len(x) - 1, rasp.tokens), rasp.Comparison.EQ).named(\"last_selector\")\n\n    # Extract the first element\n    first_element = rasp.Aggregate(first_selector, rasp.tokens).named(\"first_element\")\n\n    # Extract the last element\n    last_element = rasp.Aggregate(last_selector, rasp.tokens).named(\"last_element\")\n\n    # Calculate the average of first and last elements\n    average = rasp.LinearSequenceMap(first_element, last_element, 0.5, 0.5).named(\"average\")\n\n    # Broadcast the average across the entire sequence\n    result = rasp.Map(lambda x: x, average).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": "test_run_op timed out"
            }
        ],
        "make_check_increasing": [
            {
                "generated rasp code": "def make_check_increasing() -> rasp.SOp:\n    # Create a selector that compares each element with the previous one\n    geq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.GEQ).named(\"geq_selector\")\n\n    # Shift the selector to align comparisons correctly\n    shift_selector = rasp.Map(lambda x: x[1:] + [False], geq_selector).named(\"shift_selector\")\n\n    # Create a sequence of ones\n    ones = rasp.Map(lambda x: 1, rasp.tokens).named(\"ones\")\n\n    # Use Aggregate to replace ones with zeros where the condition is not met\n    # Note: We use a default of 1 to handle the first element correctly\n    comparison_result = rasp.Aggregate(shift_selector, ones, default=1).named(\"comparison_result\")\n\n    # Combine results: if any element is 0, the entire output becomes 0\n    def combine(x, y):\n        return 1 if x == 1 and y == 1 else 0\n\n    final_result = rasp.SequenceMap(combine, comparison_result, rasp.Map(lambda x: 1, rasp.tokens)).named(\"final_result\")\n\n    return final_result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_check_increasing() -> rasp.SOp:\n    # Create a selector that compares each element with the previous element\n    geq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.GEQ).named(\"geq_selector\")\n\n    # Shift the selector to align comparisons (first element should always be true)\n    shifted_selector = rasp.Aggregate(\n        rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.GT),\n        geq_selector,\n        default=None\n    ).named(\"shifted_selector\")\n\n    # Create a sequence where each element is 1 if the condition is met, and 0 otherwise\n    initial_check = rasp.Map(lambda x: 1 if x else 0, shifted_selector).named(\"initial_check\")\n\n    # Check if all previous elements (including current) meet the condition\n    cumulative_check = rasp.SequenceMap(\n        lambda x, y: x * y,\n        initial_check,\n        rasp.Aggregate(\n            rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.GEQ),\n            initial_check,\n            default=None\n        )\n    ).named(\"cumulative_check\")\n\n    # Convert the final result to 1s and 0s\n    final_result = rasp.Map(lambda x: 1 if x == 1 else 0, cumulative_check).named(\"final_result\")\n\n    return final_result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_check_increasing() -> rasp.SOp:\n    # Create a selector that compares each element with the previous element\n    geq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.GEQ).named(\"geq_selector\")\n\n    # Shift the selector by one position to align comparisons correctly\n    shifted_selector = rasp.Aggregate(\n        rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y + 1),\n        geq_selector\n    ).named(\"shifted_selector\")\n\n    # Ensure the first element is always considered as meeting the condition\n    first_element_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == 0).named(\"first_element_selector\")\n    combined_selector = rasp.SelectorOr(shifted_selector, first_element_selector).named(\"combined_selector\")\n\n    # Count the number of elements meeting the condition\n    condition_count = rasp.SelectorWidth(combined_selector).named(\"condition_count\")\n\n    # Create a sequence of the input length\n    sequence_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"sequence_length\")\n\n    # Compare the count with the sequence length\n    all_increasing = rasp.SequenceMap(lambda x, y: x == y, condition_count, sequence_length).named(\"all_increasing\")\n\n    # Map the result to 1 if all elements meet the condition, 0 otherwise\n    result = rasp.Map(lambda x: 1 if x else 0, all_increasing).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_check_increasing() -> rasp.SOp:\n    # Create a selector that compares each element with the previous element\n    geq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.GEQ).named(\"geq_selector\")\n\n    # Shift the selector to align comparisons (first element always True)\n    shift_selector = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.GT).named(\"shift_selector\")\n    shifted_geq_selector = rasp.Aggregate(shift_selector, geq_selector, default=None).named(\"shifted_geq_selector\")\n\n    # Count the number of True values in each row of the shifted selector\n    true_count = rasp.SelectorWidth(shifted_geq_selector).named(\"true_count\")\n\n    # Create a sequence of length - 1\n    seq_length_minus_one = rasp.Map(lambda x: len(x) - 1, rasp.tokens).named(\"seq_length_minus_one\")\n\n    # Create a selector where the count equals the sequence length minus 1\n    all_increasing_selector = rasp.Select(true_count, seq_length_minus_one, rasp.Comparison.EQ).named(\"all_increasing_selector\")\n\n    # Use Aggregate to broadcast the result across the entire sequence\n    result = rasp.Aggregate(all_increasing_selector, rasp.Map(lambda x: 1, rasp.tokens), default=None).named(\"result\")\n\n    # Convert None to 0 for the final output\n    final_result = rasp.Map(lambda x: 1 if x == 1 else 0, result).named(\"final_result\")\n\n    return final_result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_check_increasing() -> rasp.SOp:\n    # Create a selector that compares each element with the previous element\n    geq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.GEQ).named(\"geq_selector\")\n\n    # Shift the selector by one position to align comparisons correctly\n    shifted_selector = rasp.Aggregate(\n        rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y + 1),\n        geq_selector\n    ).named(\"shifted_selector\")\n\n    # Set the first element to True (it always meets the condition)\n    first_element_selector = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.EQ).named(\"first_element_selector\")\n    combined_selector = (shifted_selector | first_element_selector).named(\"combined_selector\")\n\n    # Count the number of elements meeting the condition\n    condition_count = rasp.SelectorWidth(combined_selector).named(\"condition_count\")\n\n    # Create a sequence of length - 1 for comparison\n    sequence_length_minus_one = rasp.Map(lambda x: len(x) - 1, rasp.tokens).named(\"sequence_length_minus_one\")\n\n    # Compare condition_count with sequence_length_minus_one and map to 1 or 0\n    result = rasp.SequenceMap(\n        lambda count, length: 1 if count == length else 0,\n        condition_count,\n        sequence_length_minus_one\n    ).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": ""
            }
        ],
        "make_identity": [],
        "make_apply_threshold": [
            {
                "generated rasp code": "def make_apply_threshold(threshold=3):\n    def apply_threshold() -> rasp.SOp:\n        # Create a constant sequence of the threshold value\n        threshold_seq = rasp.Map(lambda x: threshold, rasp.indices).named(\"threshold_seq\")\n        \n        # Create a selector that compares each element with the threshold\n        above_threshold = rasp.Select(rasp.tokens, threshold_seq, rasp.Comparison.GEQ).named(\"above_threshold\")\n        \n        # Use Aggregate to set elements below threshold to zero and keep others unchanged\n        result = rasp.Aggregate(above_threshold, rasp.tokens, default=None).named(\"thresholded_sequence\")\n        \n        return result\n\n    return apply_threshold\n\n# Example usage:\n# apply_threshold = make_apply_threshold()\n# Or with a custom threshold:\n# apply_threshold = make_apply_threshold(threshold=4)",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_apply_threshold(threshold=3):\n    def apply_threshold_program():\n        # Create a constant sequence of the threshold value\n        threshold_sequence = rasp.Map(lambda x: threshold, rasp.tokens).named(\"threshold_sequence\")\n\n        # Create a selector that compares each element with the threshold\n        above_threshold = rasp.Select(rasp.tokens, threshold_sequence, rasp.Comparison.GEQ).named(\"above_threshold\")\n\n        # Apply the threshold condition\n        thresholded = rasp.SequenceMap(\n            lambda x, y: x if y else 0,\n            rasp.tokens,\n            above_threshold\n        ).named(\"thresholded\")\n\n        return thresholded\n\n    return apply_threshold_program\n\n# Usage:\n# apply_threshold = make_apply_threshold()\n# result = apply_threshold([1, 4, 2, 5, 3])\n# Or with a custom threshold:\n# apply_threshold_custom = make_apply_threshold(threshold=4)\n# result_custom = apply_threshold_custom([1, 4, 2, 5, 3])",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_apply_threshold(threshold=3):\n    def apply_threshold() -> rasp.SOp:\n        # Create a constant sequence of the threshold value\n        threshold_seq = rasp.Map(lambda x: threshold, rasp.indices).named(\"threshold_seq\")\n\n        # Create a selector that compares each element with the threshold\n        geq_selector = rasp.Select(rasp.tokens, threshold_seq, rasp.Comparison.GEQ).named(\"geq_selector\")\n\n        # Apply the threshold: keep original value if >= threshold, else set to 0\n        thresholded_seq = rasp.SequenceMap(\n            lambda x, y: x if y else 0,\n            rasp.tokens,\n            geq_selector\n        ).named(\"thresholded_seq\")\n\n        return thresholded_seq\n\n    return apply_threshold",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_apply_threshold(threshold=3):\n    def apply_threshold():\n        # Create a sequence of the threshold value\n        threshold_sequence = rasp.Map(lambda x: threshold, rasp.tokens).named(\"threshold_sequence\")\n\n        # Create a selector for elements greater than or equal to the threshold\n        threshold_selector = rasp.Select(rasp.tokens, threshold_sequence, rasp.Comparison.GEQ).named(\"threshold_selector\")\n\n        # Use Aggregate to keep elements above or equal to the threshold (others become None)\n        thresholded = rasp.Aggregate(threshold_selector, rasp.tokens).named(\"thresholded\")\n\n        # Replace None values with 0\n        return rasp.Map(lambda x: x if x is not None else 0, thresholded).named(\"apply_threshold\")\n\n    return apply_threshold()",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [5.0, 5.0, 5.0, 5.0, 5.0, 5.0]. (0.925 error rate)"
            },
            {
                "generated rasp code": "def make_apply_threshold(threshold=3):\n    # Create a constant sequence of the threshold value\n    threshold_seq = rasp.Map(lambda x: threshold, rasp.indices).named(\"threshold_seq\")\n    \n    # Create a selector that compares each element with the threshold\n    above_threshold = rasp.Select(rasp.tokens, threshold_seq, rasp.Comparison.GEQ).named(\"above_threshold\")\n    \n    # Use Aggregate to replace values below the threshold with zero\n    thresholded = rasp.Aggregate(above_threshold, rasp.tokens, default=None).named(\"thresholded\")\n    \n    # Combine the original sequence with the thresholded sequence\n    result = rasp.SequenceMap(lambda x, y: y if y is not None else 0, rasp.tokens, thresholded).named(\"result\")\n    \n    return result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [5.0, 5.0, 5.0, 5.0, 5.0, 5.0]. (0.925 error rate)"
            }
        ],
        "make_replace_small_tokens": [
            {
                "generated rasp code": "def make_replace_small_tokens(threshold=2):\n    def replace_small_tokens():\n        # Create a constant sequence of the threshold value\n        threshold_seq = rasp.Map(lambda x: threshold, rasp.tokens).named(\"threshold_seq\")\n        \n        # Create a selector that identifies elements less than the threshold\n        less_than_threshold = rasp.Select(rasp.tokens, threshold_seq, rasp.Comparison.LT).named(\"less_than_threshold\")\n        \n        # Create a sequence of zeros\n        zeros = rasp.Map(lambda x: 0, rasp.tokens).named(\"zeros\")\n        \n        # Combine the original sequence with zeros based on the selector\n        result = rasp.SequenceMap(\n            lambda x, y: y if x else 0,\n            less_than_threshold,\n            rasp.tokens\n        ).named(\"result\")\n        \n        return result\n\n    return replace_small_tokens",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_replace_small_tokens(threshold=2):\n    def replace_small_tokens():\n        # Create a selector that compares each element with the threshold\n        less_than_threshold = rasp.Select(rasp.tokens, rasp.Map(lambda x: threshold, rasp.tokens), rasp.Comparison.LT).named(\"less_than_threshold\")\n        \n        # Create a sequence of zeros\n        zeros = rasp.Map(lambda x: 0, rasp.tokens).named(\"zeros\")\n        \n        # Combine the original sequence and the zero sequence based on the selector\n        result = rasp.SequenceMap(\n            lambda original, zero: zero if original < threshold else original,\n            rasp.tokens,\n            zeros\n        ).named(\"result\")\n        \n        return result\n    \n    return replace_small_tokens\n\n# Usage:\n# replace_small = make_replace_small_tokens()\n# or\n# replace_small = make_replace_small_tokens(threshold=3)",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_replace_small_tokens(threshold=2) -> rasp.SOp:\n    # Create a constant sequence of the threshold value\n    threshold_sequence = rasp.Map(lambda x: threshold, rasp.indices).named(\"threshold_sequence\")\n\n    # Create a selector that identifies tokens less than the threshold\n    less_than_threshold = rasp.Select(rasp.tokens, threshold_sequence, rasp.Comparison.LT).named(\"less_than_threshold\")\n\n    # Create the final sequence, replacing small tokens with zero\n    replaced_sequence = rasp.SequenceMap(\n        lambda x, y: 0 if y else x,\n        rasp.tokens,\n        less_than_threshold\n    ).named(\"replaced_sequence\")\n\n    return replaced_sequence",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_replace_small_tokens(threshold=2) -> rasp.SOp:\n    # Create a sequence of the threshold value\n    threshold_seq = rasp.Map(lambda x: threshold, rasp.indices).named(\"threshold_seq\")\n    \n    # Create a selector that compares each token with the threshold\n    geq_selector = rasp.Select(rasp.tokens, threshold_seq, rasp.Comparison.GEQ).named(\"geq_selector\")\n    \n    # Use SequenceMap to create the new sequence\n    # If selector is True, keep the original token; if False, replace with 0\n    replaced_tokens = rasp.SequenceMap(\n        lambda s, t: t if s else 0,\n        geq_selector,\n        rasp.tokens\n    ).named(\"replaced_tokens\")\n    \n    return replaced_tokens",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_replace_small_tokens(threshold=2):\n    def replace_small_tokens():\n        # Create a constant sequence of the threshold value\n        threshold_sequence = rasp.Map(lambda x: threshold, rasp.indices).named(\"threshold_sequence\")\n        \n        # Create a selector that identifies tokens smaller than the threshold\n        small_token_selector = rasp.Select(rasp.tokens, threshold_sequence, rasp.Comparison.LT).named(\"small_token_selector\")\n        \n        # Create the output sequence:\n        # If the token is smaller than the threshold (selector is True), return 0\n        # Otherwise, return the original token\n        output = rasp.SequenceMap(\n            lambda token, is_small: 0 if is_small else token,\n            rasp.tokens,\n            small_token_selector\n        ).named(\"output\")\n        \n        return output\n    \n    return replace_small_tokens()",
                "failure stage": 0,
                "error": ""
            }
        ],
        "make_swap_odd_index": [
            {
                "generated rasp code": "def make_swap_odd_index() -> rasp.SOp:\n    # Create a sequence of indices\n    indices = rasp.indices\n\n    # Create a selector for odd indices (excluding the first element)\n    odd_selector = rasp.Select(\n        rasp.Map(lambda x: x % 2, indices),\n        rasp.Map(lambda x: 1, indices),\n        rasp.Comparison.EQ\n    ).named(\"odd_selector\")\n\n    # Create a selector for even indices that are part of the swap\n    even_selector = rasp.Select(\n        rasp.Map(lambda x: (x + 1) % 2, indices),\n        rasp.Map(lambda x: 1, indices),\n        rasp.Comparison.EQ\n    ).named(\"even_selector\")\n\n    # Shift odd-indexed elements to the right\n    shift_right = rasp.Aggregate(odd_selector, rasp.tokens).named(\"shift_right\")\n\n    # Shift even-indexed elements to the left\n    shift_left = rasp.Aggregate(even_selector, rasp.tokens).named(\"shift_left\")\n\n    # Combine the shifted elements\n    swapped = rasp.SequenceMap(\n        lambda x, y: y if x is None else x,\n        shift_right,\n        shift_left\n    ).named(\"swapped\")\n\n    return swapped",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [4.333333333333333, 4.333333333333333, 4.333333333333333, 4.333333333333333, 4.333333333333333, 4.333333333333333]. (0.989 error rate)"
            },
            {
                "generated rasp code": "def make_swap_odd_index() -> rasp.SOp:\n    # Create a sequence of indices\n    indices = rasp.indices\n\n    # Create a selector for odd indices (excluding the first element)\n    odd_selector = rasp.Select(\n        rasp.Map(lambda x: x % 2, indices),\n        rasp.Map(lambda x: 1, indices),\n        rasp.Comparison.EQ\n    ).named(\"odd_selector\")\n\n    # Shift odd-indexed elements to the right and even-indexed elements to the left\n    swapped_sequence = rasp.SequenceMap(\n        lambda x, y: y if x else rasp.tokens,  # If odd index, take the element from shifted sequence\n        odd_selector,\n        rasp.Aggregate(\n            rasp.Select(indices, indices, lambda x, y: y == x + 1),  # Selector to shift right by 1\n            rasp.tokens,\n            default=None\n        )\n    ).named(\"swapped_sequence\")\n\n    return swapped_sequence",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_swap_odd_index() -> rasp.SOp:\n    # Create a helper sequence for odd indices (excluding the first element)\n    odd_indices = rasp.Map(lambda x: (x % 2 == 1) and (x > 0), rasp.indices).named(\"odd_indices\")\n    \n    # Create a helper sequence for even indices (excluding the last element if sequence length is odd)\n    even_indices = rasp.Map(lambda x: (x % 2 == 0) and (x < len(x) - 1), rasp.indices).named(\"even_indices\")\n    \n    # Create selectors for odd and even indices\n    odd_selector = rasp.Select(odd_indices, rasp.tokens, rasp.Comparison.EQ).named(\"odd_selector\")\n    even_selector = rasp.Select(even_indices, rasp.tokens, rasp.Comparison.EQ).named(\"even_selector\")\n    \n    # Shift odd-indexed elements one position forward\n    shift_forward = rasp.Aggregate(rasp.Select(rasp.indices, rasp.Map(lambda x: x - 1, rasp.indices), rasp.Comparison.EQ), rasp.tokens).named(\"shift_forward\")\n    odd_shifted = rasp.Aggregate(odd_selector, shift_forward).named(\"odd_shifted\")\n    \n    # Shift even-indexed elements one position backward\n    shift_backward = rasp.Aggregate(rasp.Select(rasp.indices, rasp.Map(lambda x: x + 1, rasp.indices), rasp.Comparison.EQ), rasp.tokens).named(\"shift_backward\")\n    even_shifted = rasp.Aggregate(even_selector, shift_backward).named(\"even_shifted\")\n    \n    # Combine the shifted elements\n    result = rasp.SequenceMap(\n        lambda x, y: x if x is not None else y,\n        odd_shifted,\n        even_shifted\n    ).named(\"result\")\n    \n    # Handle unchanged elements (first element and potentially last element if sequence length is odd)\n    unchanged = rasp.Map(lambda x: not ((x % 2 == 1 and x > 0) or (x % 2 == 0 and x < len(x) - 1)), rasp.indices).named(\"unchanged\")\n    unchanged_selector = rasp.Select(unchanged, rasp.tokens, rasp.Comparison.EQ).named(\"unchanged_selector\")\n    \n    final_result = rasp.SequenceMap(\n        lambda x, y: y if y is not None else x,\n        result,\n        rasp.Aggregate(unchanged_selector, rasp.tokens)\n    ).named(\"final_result\")\n    \n    return final_result",
                "failure stage": 1,
                "error": "Unsupported type for aggregation: [9.0, 4.0]"
            },
            {
                "generated rasp code": "def make_swap_odd_index() -> rasp.SOp:\n    # Create a selector for odd-indexed positions (excluding the first element)\n    odd_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: 1, rasp.indices),\n        rasp.Comparison.GT\n    ) & rasp.Select(\n        rasp.Map(lambda x: x % 2, rasp.indices),\n        rasp.Map(lambda x: 1, rasp.indices),\n        rasp.Comparison.EQ\n    ).named(\"odd_selector\")\n\n    # Create a selector for even-indexed positions (including the first element)\n    even_selector = rasp.Select(\n        rasp.Map(lambda x: x % 2, rasp.indices),\n        rasp.Map(lambda x: 0, rasp.indices),\n        rasp.Comparison.EQ\n    ).named(\"even_selector\")\n\n    # Shift odd-indexed elements one position forward\n    shift_forward = rasp.Aggregate(\n        rasp.Select(rasp.indices, rasp.Map(lambda x: x - 1, rasp.indices), rasp.Comparison.EQ) & odd_selector,\n        rasp.tokens\n    ).named(\"shift_forward\")\n\n    # Shift even-indexed elements one position backward\n    shift_backward = rasp.Aggregate(\n        rasp.Select(rasp.indices, rasp.Map(lambda x: x + 1, rasp.indices), rasp.Comparison.EQ) & even_selector,\n        rasp.tokens\n    ).named(\"shift_backward\")\n\n    # Combine the results\n    swapped_sequence = rasp.SequenceMap(\n        lambda x, y: x if x is not None else y,\n        shift_forward,\n        shift_backward\n    ).named(\"swapped_sequence\")\n\n    return swapped_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, None, None, None, None, None]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_swap_odd_index() -> rasp.SOp:\n    # Create a sequence of indices\n    indices = rasp.Map(lambda x: x, rasp.indices).named(\"indices\")\n    \n    # Create a selector for odd indices (excluding the first element)\n    odd_selector = rasp.Select(indices, rasp.tokens, lambda i, _: i % 2 == 1 and i > 0).named(\"odd_selector\")\n    \n    # Shift odd-indexed elements one position forward\n    shift_forward = rasp.Aggregate(odd_selector, rasp.tokens, default=None).named(\"shift_forward\")\n    \n    # Shift even-indexed elements (including the first) one position backward\n    shift_backward = rasp.Aggregate(~odd_selector, rasp.tokens, default=None).named(\"shift_backward\")\n    \n    # Combine the shifted elements\n    result = rasp.SequenceMap(\n        lambda x, y: x if x is not None else y,\n        shift_forward,\n        shift_backward\n    ).named(\"result\")\n    \n    return result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [4.333333333333333, 4.333333333333333, 4.333333333333333, 4.333333333333333, 4.333333333333333, 4.333333333333333]. (0.989 error rate)"
            }
        ],
        "make_check_descending": [
            {
                "generated rasp code": "def make_check_descending() -> rasp.SOp:\n    # Create a selector that compares each element with the next element\n    geq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.GEQ).named(\"geq_selector\")\n\n    # Shift the selector by one position to align comparisons correctly\n    shift_right = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.EQ).named(\"shift_right\")\n    shifted_selector = rasp.Aggregate(shift_right, geq_selector, default=None).named(\"shifted_selector\")\n\n    # Convert the selector to a sequence of 1s and 0s\n    descending_check = rasp.SelectorWidth(shifted_selector).named(\"descending_check\")\n\n    # Calculate the cumulative product to ensure all subsequent elements are 0 after the first 0\n    def cumulative_product(x, y):\n        if x is None or y is None:\n            return 1  # Default value for the first element\n        return x * y\n\n    cumulative_desc = rasp.SequenceMap(cumulative_product, descending_check, descending_check).named(\"cumulative_desc\")\n\n    return cumulative_desc",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_check_descending() -> rasp.SOp:\n    # Create a selector that compares each element with the next\n    geq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.GEQ).named(\"geq_selector\")\n\n    # Shift the selector by one position\n    shift_right = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y - 1).named(\"shift_right\")\n    shifted_selector = rasp.Aggregate(shift_right, geq_selector).named(\"shifted_selector\")\n\n    # Convert the selector to 1s and 0s\n    descending_check = rasp.SelectorWidth(shifted_selector).named(\"descending_check\")\n\n    # Perform cumulative product\n    def cumulative_product(x, prev_result):\n        if prev_result is None:\n            return x\n        return x * prev_result\n\n    cumulative_selector = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.GT).named(\"cumulative_selector\")\n    result = rasp.Map(\n        lambda x: cumulative_product(x, rasp.Aggregate(cumulative_selector, descending_check)),\n        descending_check\n    ).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_check_descending() -> rasp.SOp:\n    # Create a selector that compares each element with the next element\n    gt_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.GT).named(\"gt_selector\")\n\n    # Shift the selector by one position to align comparisons correctly\n    shift_selector = rasp.Aggregate(\n        rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y + 1),\n        gt_selector,\n        default=None\n    ).named(\"shift_selector\")\n\n    # Count the number of correct comparisons up to each position\n    correct_count = rasp.SelectorWidth(shift_selector).named(\"correct_count\")\n\n    # Create a sequence of indices representing the expected number of correct comparisons\n    expected_count = rasp.Map(lambda x: x, rasp.indices).named(\"expected_count\")\n\n    # Compare the actual count of correct comparisons with the expected count\n    is_descending = rasp.SequenceMap(lambda x, y: x == y, correct_count, expected_count).named(\"is_descending\")\n\n    # Convert the comparison result to 1 (True) or 0 (False)\n    result = rasp.Map(lambda x: 1 if x else 0, is_descending).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_check_descending() -> rasp.SOp:\n    # Create a selector that compares each element with the next element\n    gt_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.GT).named(\"gt_selector\")\n\n    # Shift the selector by one position to align comparisons correctly\n    shift_selector = rasp.Aggregate(\n        rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y + 1),\n        gt_selector,\n        default=None\n    ).named(\"shift_selector\")\n\n    # Convert the selector to a sequence of 1s and 0s\n    descending_check = rasp.SelectorWidth(shift_selector).named(\"descending_check\")\n\n    # Calculate the cumulative product to ensure all subsequent elements are 0 after encountering a 0\n    def cumulative_product(x, y):\n        if x is None:\n            return y\n        return x * y\n\n    final_result = rasp.SequenceMap(cumulative_product, \n                                    rasp.Aggregate(\n                                        rasp.Select(rasp.indices, rasp.indices, lambda x, y: x > y),\n                                        descending_check,\n                                        default=None\n                                    ),\n                                    descending_check\n                                   ).named(\"final_result\")\n\n    return final_result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_check_descending() -> rasp.SOp:\n    # Create a selector that compares each element with the next element\n    gt_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.GT).named(\"gt_selector\")\n\n    # Shift the selector by one position to align comparisons correctly\n    shift_selector = rasp.Aggregate(\n        rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y + 1),\n        gt_selector,\n        default=None\n    ).named(\"shift_selector\")\n\n    # Count the number of correct descending comparisons up to each position\n    descending_count = rasp.SelectorWidth(shift_selector).named(\"descending_count\")\n\n    # Compare the count of correct comparisons with the indices\n    is_descending = rasp.SequenceMap(\n        lambda count, index: count == index,\n        descending_count,\n        rasp.indices\n    ).named(\"is_descending\")\n\n    # Map the result to 1 (true) or 0 (false)\n    result = rasp.Map(lambda x: 1 if x else 0, is_descending).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": ""
            }
        ],
        "make_rotate_left": [
            {
                "generated rasp code": "def make_rotate_left() -> rasp.SOp:\n    # Create a sequence of indices incremented by 1\n    next_index = rasp.Map(lambda x: x + 1, rasp.indices).named(\"next_index\")\n    \n    # Get the length of the sequence\n    seq_length = rasp.Map(lambda x: len(x), rasp.indices).named(\"seq_length\")\n    \n    # Apply modulo operation to handle wrapping around\n    wrapped_index = rasp.SequenceMap(lambda x, y: x % y, next_index, seq_length).named(\"wrapped_index\")\n    \n    # Create a selector that matches each position with its next (wrapped) position\n    rotation_selector = rasp.Select(wrapped_index, rasp.indices, rasp.Comparison.EQ).named(\"rotation_selector\")\n    \n    # Use Aggregate to shift the elements based on the selector\n    rotated_sequence = rasp.Aggregate(rotation_selector, rasp.tokens).named(\"rotated_sequence\")\n    \n    return rotated_sequence",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_rotate_left() -> rasp.SOp:\n    # Create a sequence of indices that are one more than the current index (modulo sequence length)\n    next_index = rasp.SequenceMap(\n        lambda i, t: (i + 1) % len(t),\n        rasp.indices,\n        rasp.tokens\n    ).named(\"next_index\")\n\n    # Create a selector that selects the element to the right of each position\n    right_selector = rasp.Select(\n        rasp.indices,\n        next_index,\n        rasp.Comparison.EQ\n    ).named(\"right_selector\")\n\n    # Use Aggregate to shift each element one position to the left\n    rotated_sequence = rasp.Aggregate(\n        right_selector,\n        rasp.tokens\n    ).named(\"rotated_sequence\")\n\n    return rotated_sequence",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_rotate_left() -> rasp.SOp:\n    # Create a sequence of shifted indices\n    shifted_indices = rasp.SequenceMap(\n        lambda x, y: (x + 1) % y,\n        rasp.indices,\n        rasp.Map(lambda x: len(x), rasp.tokens)\n    ).named(\"shifted_indices\")\n\n    # Create a selector that matches original indices to shifted indices\n    shift_selector = rasp.Select(\n        rasp.indices,\n        shifted_indices,\n        rasp.Comparison.EQ\n    ).named(\"shift_selector\")\n\n    # Use Aggregate to apply the shift to the original sequence\n    rotated_sequence = rasp.Aggregate(\n        shift_selector,\n        rasp.tokens\n    ).named(\"rotated_sequence\")\n\n    return rotated_sequence",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_rotate_left() -> rasp.SOp:\n    # Get the length of the sequence\n    seq_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"seq_length\")\n    \n    # Create indices for the next elements (with wrapping)\n    next_indices = rasp.SequenceMap(\n        lambda i, l: (i + 1) % l,\n        rasp.indices,\n        seq_length\n    ).named(\"next_indices\")\n    \n    # Create a selector that selects the next element for each position\n    rotate_selector = rasp.Select(\n        rasp.indices,\n        next_indices,\n        rasp.Comparison.EQ\n    ).named(\"rotate_selector\")\n    \n    # Use Aggregate to shift the elements based on the selector\n    rotated_sequence = rasp.Aggregate(rotate_selector, rasp.tokens).named(\"rotated_sequence\")\n    \n    return rotated_sequence",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_rotate_left() -> rasp.SOp:\n    # Selector that selects the element to the right of each position\n    shift_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y + 1).named(\"shift_selector\")\n    \n    # Selector that selects the first element for the last position\n    wrap_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: (x == 0) & (y == rasp.indices[-1])).named(\"wrap_selector\")\n    \n    # Combine the selectors using OR operation\n    combined_selector = (shift_selector | wrap_selector).named(\"combined_selector\")\n    \n    # Use Aggregate to shift the elements based on the combined selector\n    rotated_sequence = rasp.Aggregate(combined_selector, rasp.tokens).named(\"rotated_sequence\")\n    \n    return rotated_sequence",
                "failure stage": 0,
                "error": "test_run_op timed out"
            }
        ],
        "make_remove_duplicates": [
            {
                "generated rasp code": "def make_remove_duplicates() -> rasp.SOp:\n    # Create a selector that compares each element with every other element\n    eq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.EQ).named(\"eq_selector\")\n\n    # Count the number of elements each element is equal to (including itself)\n    eq_count = rasp.SelectorWidth(eq_selector).named(\"eq_count\")\n\n    # Create a selector for duplicates (elements with count > 1)\n    duplicate_selector = rasp.Select(eq_count, rasp.Map(lambda x: 1, rasp.tokens), rasp.Comparison.GT).named(\"duplicate_selector\")\n\n    # Replace duplicates with 0\n    zero_duplicates = rasp.Aggregate(duplicate_selector, rasp.Map(lambda x: 0, rasp.tokens)).named(\"zero_duplicates\")\n\n    # Combine original sequence with processed sequence, keeping non-duplicates and replacing duplicates with 0\n    result = rasp.SequenceMap(\n        lambda x, y: y if y is not None else x,\n        rasp.tokens,\n        zero_duplicates\n    ).named(\"result\")\n\n    return result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, None, None, None, None, None]. (0.982 error rate)"
            }
        ],
        "make_scale_by_max": [
            {
                "generated rasp code": "def make_scale_by_max() -> rasp.SOp:\n    # First, we need to define the make_max() function\n    def make_max() -> rasp.SOp:\n        # Selector that creates a comparison matrix where each element is compared to every other element.\n        leq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LEQ).named(\"leq_selector\")\n\n        # Count the number of comparisons where each element is less than or equal to other elements.\n        leq_count = rasp.SelectorWidth(leq_selector).named(\"leq_count\")\n\n        # Create a Map to get the sequence length for each element.\n        sequence_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"sequence_length\")\n\n        # Selector that selects the element where the leq_count equals the sequence_length.\n        max_element_selector = rasp.Select(leq_count, sequence_length, rasp.Comparison.EQ).named(\"max_element_selector\")\n\n        # Use Aggregate to broadcast the maximum element across the entire sequence.\n        max_sequence = rasp.Aggregate(max_element_selector, rasp.tokens).named(\"max_sequence\")\n\n        return max_sequence\n\n    # Get the maximum value in the sequence\n    max_value = make_max()\n\n    # Divide each element by the maximum value\n    scaled_sequence = rasp.SequenceMap(lambda x, y: x / y if y != 0 else 0, rasp.tokens, max_value).named(\"scaled_sequence\")\n\n    return scaled_sequence",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_scale_by_max() -> rasp.SOp:\n    # Find the maximum value in the sequence\n    # Create a selector that compares each element with every other element\n    leq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LEQ).named(\"leq_selector\")\n\n    # Count the number of comparisons where each element is less than or equal to other elements\n    leq_count = rasp.SelectorWidth(leq_selector).named(\"leq_count\")\n\n    # Create a Map to get the sequence length for each element\n    sequence_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"sequence_length\")\n\n    # Selector that selects the element where the leq_count equals the sequence_length (i.e., the maximum)\n    max_element_selector = rasp.Select(leq_count, sequence_length, rasp.Comparison.EQ).named(\"max_element_selector\")\n\n    # Use Aggregate to create a sequence where each element is the maximum value\n    max_sequence = rasp.Aggregate(max_element_selector, rasp.tokens).named(\"max_sequence\")\n\n    # Use SequenceMap to divide each original element by the maximum value\n    scaled_sequence = rasp.SequenceMap(lambda x, y: x / y if y != 0 else 0, rasp.tokens, max_sequence).named(\"scaled_sequence\")\n\n    return scaled_sequence",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_scale_by_max() -> rasp.SOp:\n    # Selector that creates a comparison matrix where each element is compared to every other element.\n    leq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LEQ).named(\"leq_selector\")\n\n    # Count the number of comparisons where each element is less than or equal to other elements.\n    leq_count = rasp.SelectorWidth(leq_selector).named(\"leq_count\")\n\n    # Selector that selects the element where the leq_count equals the sequence length.\n    max_element_selector = rasp.Select(leq_count, rasp.indices, rasp.Comparison.EQ).named(\"max_element_selector\")\n\n    # Use Aggregate to broadcast the maximum element across the entire sequence.\n    max_value = rasp.Aggregate(max_element_selector, rasp.tokens).named(\"max_value\")\n\n    # Use SequenceMap to divide each element by the maximum value.\n    scaled_sequence = rasp.SequenceMap(lambda x, y: x / y if y != 0 else 0, rasp.tokens, max_value).named(\"scaled_sequence\")\n\n    return scaled_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, 8.0, 1.0, 0.3333333333333333, 1.25, 0.8]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_max() -> rasp.SOp:\n    # Selector that creates a comparison matrix where each element is compared to every other element.\n    leq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LEQ).named(\"leq_selector\")\n\n    # Count the number of comparisons where each element is less than or equal to other elements.\n    leq_count = rasp.SelectorWidth(leq_selector).named(\"leq_count\")\n\n    # Create a Map to get the sequence length for each element.\n    sequence_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"sequence_length\")\n\n    # Selector that selects the element where the leq_count equals the sequence_length.\n    max_element_selector = rasp.Select(leq_count, sequence_length, rasp.Comparison.EQ).named(\"max_element_selector\")\n\n    # Use Aggregate to broadcast the maximum element across the entire sequence.\n    max_sequence = rasp.Aggregate(max_element_selector, rasp.tokens).named(\"max_sequence\")\n\n    return max_sequence\n\ndef make_scale_by_max() -> rasp.SOp:\n    # Get the maximum value in the sequence\n    max_value = make_max()\n\n    # Replace zero with 1 in the max sequence to avoid division by zero\n    safe_max = rasp.Map(lambda x: 1 if x == 0 else x, max_value).named(\"safe_max\")\n\n    # Divide each element by the maximum value\n    scaled_sequence = rasp.SequenceMap(lambda x, y: x / y if y != 0 else 0, rasp.tokens, safe_max).named(\"scaled_sequence\")\n\n    return scaled_sequence",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_scale_by_max() -> rasp.SOp:\n    # Create a selector that compares each element with every other element\n    leq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LEQ).named(\"leq_selector\")\n\n    # Count the number of elements each element is less than or equal to\n    leq_count = rasp.SelectorWidth(leq_selector).named(\"leq_count\")\n\n    # Create a sequence of the length of the input\n    sequence_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"sequence_length\")\n\n    # Create a selector that identifies the maximum element(s)\n    max_element_selector = rasp.Select(leq_count, sequence_length, rasp.Comparison.EQ).named(\"max_element_selector\")\n\n    # Use Aggregate to broadcast the maximum element across the entire sequence\n    max_value = rasp.Aggregate(max_element_selector, rasp.tokens).named(\"max_value\")\n\n    # Use SequenceMap to divide each element by the maximum value\n    scaled_sequence = rasp.SequenceMap(lambda x, y: x / y if y != 0 else 0, rasp.tokens, max_value).named(\"scaled_sequence\")\n\n    return scaled_sequence",
                "failure stage": 0,
                "error": "test_run_op timed out"
            }
        ],
        "make_sum_with_next": [
            {
                "generated rasp code": "def make_sum_with_next() -> rasp.SOp:\n    # Create a selector that selects the next element (or the last element for the last position)\n    next_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: (x + 1) % len(x), rasp.indices),\n        rasp.Comparison.EQ\n    ).named(\"next_selector\")\n\n    # Use Aggregate to shift the sequence by one position\n    shifted_sequence = rasp.Aggregate(next_selector, rasp.tokens).named(\"shifted_sequence\")\n\n    # Use SequenceMap to add the original sequence with the shifted sequence\n    # Handle the case where shifted_sequence might be None for the last element\n    sum_with_next = rasp.SequenceMap(\n        lambda x, y: x + (y if y is not None else x),\n        rasp.tokens,\n        shifted_sequence\n    ).named(\"sum_with_next\")\n\n    return sum_with_next",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_sum_with_next() -> rasp.SOp:\n    # Create a selector that selects the next element (or the same element for the last position)\n    next_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: x + 1, rasp.indices),\n        rasp.Comparison.LEQ\n    ).named(\"next_selector\")\n\n    # Use Aggregate to get a sequence of the next elements\n    next_elements = rasp.Aggregate(next_selector, rasp.tokens).named(\"next_elements\")\n\n    # Sum the original sequence with the sequence of next elements\n    sum_with_next = rasp.SequenceMap(\n        lambda x, y: x + y,\n        rasp.tokens,\n        next_elements\n    ).named(\"sum_with_next\")\n\n    return sum_with_next",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [8.5, 12.333333333333332, 5.5, 4.8, 8.833333333333334, 7.833333333333334]. (0.887 error rate)"
            },
            {
                "generated rasp code": "def make_sum_with_next() -> rasp.SOp:\n    # Create a selector that selects the next element (or current for last position)\n    next_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: x + 1, rasp.indices),\n        rasp.Comparison.LEQ\n    ).named(\"next_selector\")\n\n    # Shift the sequence by one position (last element repeated)\n    shifted_sequence = rasp.Aggregate(next_selector, rasp.tokens).named(\"shifted_sequence\")\n\n    # Add the original sequence and the shifted sequence\n    sum_with_next = rasp.SequenceMap(\n        lambda x, y: x + y,\n        rasp.tokens,\n        shifted_sequence\n    ).named(\"sum_with_next\")\n\n    return sum_with_next",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [8.5, 12.333333333333332, 5.5, 4.8, 8.833333333333334, 7.833333333333334]. (0.887 error rate)"
            },
            {
                "generated rasp code": "def make_sum_with_next() -> rasp.SOp:\n    # Create a selector that selects the next element (or the same element for the last position)\n    next_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: x + 1, rasp.indices),\n        rasp.Comparison.LEQ\n    ).named(\"next_selector\")\n\n    # Use Aggregate to shift the sequence (last element repeats)\n    shifted_sequence = rasp.Aggregate(next_selector, rasp.tokens).named(\"shifted_sequence\")\n\n    # Sum the original sequence with the shifted sequence\n    sum_with_next = rasp.SequenceMap(\n        lambda x, y: x + y,\n        rasp.tokens,\n        shifted_sequence\n    ).named(\"sum_with_next\")\n\n    return sum_with_next",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [8.5, 12.333333333333332, 5.5, 4.8, 8.833333333333334, 7.833333333333334]. (0.887 error rate)"
            },
            {
                "generated rasp code": "def make_sum_with_next() -> rasp.SOp:\n    # Create a selector that selects the next element for each position\n    # For the last element, it selects itself\n    next_selector = rasp.Select(\n        rasp.indices,\n        rasp.indices,\n        lambda x, y: (x == y - 1) or (x == y and x == len(y) - 1)\n    ).named(\"next_selector\")\n\n    # Use Aggregate to shift the sequence by one position\n    # The last element is repeated\n    shifted_sequence = rasp.Aggregate(next_selector, rasp.tokens).named(\"shifted_sequence\")\n\n    # Sum the original sequence with the shifted sequence\n    sum_with_next = rasp.SequenceMap(\n        lambda x, y: x + y,\n        rasp.tokens,\n        shifted_sequence\n    ).named(\"sum_with_next\")\n\n    return sum_with_next",
                "failure stage": 0,
                "error": "test_run_op timed out"
            }
        ],
        "make_swap_elements": [
            {
                "generated rasp code": "def make_swap_elements(swap_indices=[0, 1]):\n    def swap_program():\n        # Create constant sequences for swap indices\n        index1 = rasp.Map(lambda x: swap_indices[0], rasp.indices).named(\"index1\")\n        index2 = rasp.Map(lambda x: swap_indices[1], rasp.indices).named(\"index2\")\n\n        # Create selectors for the swap indices\n        selector1 = rasp.Select(rasp.indices, index1, rasp.Comparison.EQ).named(\"selector1\")\n        selector2 = rasp.Select(rasp.indices, index2, rasp.Comparison.EQ).named(\"selector2\")\n\n        # Swap the elements\n        swapped1 = rasp.Aggregate(selector2, rasp.tokens).named(\"swapped1\")\n        swapped2 = rasp.Aggregate(selector1, rasp.tokens).named(\"swapped2\")\n\n        # Create a selector for non-swapped elements\n        non_swap_selector = ~(selector1 | selector2).named(\"non_swap_selector\")\n\n        # Keep non-swapped elements in place\n        non_swapped = rasp.Aggregate(non_swap_selector, rasp.tokens).named(\"non_swapped\")\n\n        # Combine swapped and non-swapped elements\n        result = rasp.SequenceMap(\n            lambda x, y, z: x if x is not None else (y if y is not None else z),\n            non_swapped,\n            swapped1,\n            swapped2\n        ).named(\"result\")\n\n        # Check if the sequence has only one element\n        sequence_width = rasp.SelectorWidth(rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE)).named(\"sequence_width\")\n        is_single_element = rasp.Select(sequence_width, rasp.Map(lambda x: 1, rasp.indices), rasp.Comparison.EQ).named(\"is_single_element\")\n\n        # Return [None] if the sequence has only one element, otherwise return the swapped sequence\n        final_result = rasp.Aggregate(is_single_element, rasp.Map(lambda x: None, rasp.tokens), default=result).named(\"final_result\")\n\n        return final_result\n\n    return swap_program()",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            },
            {
                "generated rasp code": "def make_swap_elements(index1=0, index2=1):\n    def swap_program():\n        # Create selectors for the two indices to be swapped\n        select_index1 = rasp.Select(rasp.indices, rasp.Map(lambda x: index1, rasp.indices), rasp.Comparison.EQ).named(\"select_index1\")\n        select_index2 = rasp.Select(rasp.indices, rasp.Map(lambda x: index2, rasp.indices), rasp.Comparison.EQ).named(\"select_index2\")\n\n        # Move elements to their new positions\n        element1_at_index2 = rasp.Aggregate(select_index1, rasp.tokens).named(\"element1_at_index2\")\n        element2_at_index1 = rasp.Aggregate(select_index2, rasp.tokens).named(\"element2_at_index1\")\n\n        # Combine the swapped elements with the original sequence\n        swapped_sequence = rasp.SequenceMap(\n            lambda orig, swap1, swap2: swap1 if swap1 is not None else (swap2 if swap2 is not None else orig),\n            rasp.tokens,\n            element2_at_index1,\n            element1_at_index2\n        ).named(\"swapped_sequence\")\n\n        # Create a selector for sequences of length 1\n        length_one_selector = rasp.Select(\n            rasp.Map(lambda x: len(x), rasp.tokens),\n            rasp.Map(lambda x: 1, rasp.indices),\n            rasp.Comparison.EQ\n        ).named(\"length_one_selector\")\n\n        # Return None for all elements if the sequence length is 1, otherwise return the swapped sequence\n        result = rasp.SequenceMap(\n            lambda x, y: None if y else x,\n            swapped_sequence,\n            length_one_selector\n        ).named(\"result\")\n\n        return result\n\n    return swap_program()",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            },
            {
                "generated rasp code": "def make_swap_elements(index1=0, index2=1):\n    def swap_program():\n        # Create selectors for the two indices to be swapped\n        select_index1 = rasp.Select(rasp.indices, rasp.Map(lambda x: index1, rasp.indices), rasp.Comparison.EQ).named(\"select_index1\")\n        select_index2 = rasp.Select(rasp.indices, rasp.Map(lambda x: index2, rasp.indices), rasp.Comparison.EQ).named(\"select_index2\")\n\n        # Move elements to their new positions\n        element1 = rasp.Aggregate(select_index1, rasp.tokens).named(\"element1\")\n        element2 = rasp.Aggregate(select_index2, rasp.tokens).named(\"element2\")\n\n        # Combine the swapped elements with the original sequence\n        swapped = rasp.SequenceMap(\n            lambda orig, e1, e2, i: \n                e2 if i == index1 else (e1 if i == index2 else orig),\n            rasp.tokens, element1, element2, rasp.indices\n        ).named(\"swapped\")\n\n        # Check if the sequence has more than one element\n        has_multiple_elements = rasp.SequenceMap(\n            lambda i, length: i < length - 1,\n            rasp.indices,\n            rasp.Map(lambda x: len(x) - 1, rasp.tokens)\n        ).named(\"has_multiple_elements\")\n\n        # Return [None] if the sequence has only one element, otherwise return the swapped sequence\n        return rasp.SequenceMap(\n            lambda multiple, s: s if multiple else None,\n            has_multiple_elements,\n            swapped\n        ).named(\"result\")\n\n    return swap_program()",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 6 were given"
            },
            {
                "generated rasp code": "def make_swap_elements(index1=0, index2=1):\n    def swap_program():\n        # Create selectors for the two indices to be swapped\n        selector1 = rasp.Select(rasp.indices, rasp.tokens, lambda i, _: i == index1).named(\"selector1\")\n        selector2 = rasp.Select(rasp.indices, rasp.tokens, lambda i, _: i == index2).named(\"selector2\")\n\n        # Move the elements to their new positions\n        elem1_at_2 = rasp.Aggregate(selector1, rasp.tokens).named(\"elem1_at_2\")\n        elem2_at_1 = rasp.Aggregate(selector2, rasp.tokens).named(\"elem2_at_1\")\n\n        # Combine the swapped elements with the rest of the sequence\n        swapped = rasp.SequenceMap(\n            lambda x, y: y if x == index1 else (elem1_at_2 if x == index2 else y),\n            rasp.indices,\n            rasp.tokens\n        ).named(\"swapped\")\n\n        # Handle the case of a single-element input\n        return rasp.SequenceMap(\n            lambda length, x: None if length == 1 else x,\n            rasp.Map(lambda x: len(x), rasp.tokens),\n            swapped\n        ).named(\"result\")\n\n    return swap_program()",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_swap_elements(index1=0, index2=1):\n    def swap_program():\n        # Create selectors for the two indices to be swapped\n        select_index1 = rasp.Select(rasp.indices, rasp.Map(lambda x: index1, rasp.indices), rasp.Comparison.EQ).named(\"select_index1\")\n        select_index2 = rasp.Select(rasp.indices, rasp.Map(lambda x: index2, rasp.indices), rasp.Comparison.EQ).named(\"select_index2\")\n\n        # Move elements to their new positions\n        element1_at_index2 = rasp.Aggregate(select_index1, rasp.tokens).named(\"element1_at_index2\")\n        element2_at_index1 = rasp.Aggregate(select_index2, rasp.tokens).named(\"element2_at_index1\")\n\n        # Combine the swapped elements with the original sequence\n        swapped_sequence = rasp.SequenceMap(\n            lambda orig, swap1, swap2: swap1 if swap1 is not None else (swap2 if swap2 is not None else orig),\n            rasp.tokens,\n            element2_at_index1,\n            element1_at_index2\n        ).named(\"swapped_sequence\")\n\n        # Handle single-element input case\n        sequence_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"sequence_length\")\n        final_output = rasp.SequenceMap(\n            lambda x, length: None if length == 1 else x,\n            swapped_sequence,\n            sequence_length\n        ).named(\"final_output\")\n\n        return final_output\n\n    return swap_program()\n\n# Usage\nswap = make_swap_elements()  # Uses default indices 0 and 1\nswap_custom = make_swap_elements(1, 3)  # Swaps elements at indices 1 and 3",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            }
        ],
        "make_one_if_equal_to_next": [
            {
                "generated rasp code": "def make_one_if_equal_to_next() -> rasp.SOp:\n    # Create a selector to compare each element with the next\n    next_index = rasp.Select(rasp.indices, rasp.indices, lambda x, y: (x + 1) % y == 0)\n    next_element = rasp.Aggregate(next_index, rasp.tokens)\n    \n    # Create a selector that is True when an element is equal to the next\n    equal_to_next = rasp.Select(rasp.tokens, next_element, rasp.Comparison.EQ).named(\"equal_to_next\")\n    \n    # Create the final sequence: 1 if equal to next, original value otherwise\n    result = rasp.SequenceMap(\n        lambda x, y: 1 if y else x,\n        rasp.tokens,\n        equal_to_next\n    ).named(\"result\")\n    \n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_one_if_equal_to_next() -> rasp.SOp:\n    # Create a selector that selects the next element for each position\n    next_element_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: (y - x) % len(x) == 1)\n\n    # Use Aggregate to shift the sequence, effectively bringing the first element to the end\n    shifted_sequence = rasp.Aggregate(next_element_selector, rasp.tokens).named(\"shifted_sequence\")\n\n    # Create a selector that compares each element with its next element (or the first for the last element)\n    equal_to_next_selector = rasp.Select(rasp.tokens, shifted_sequence, rasp.Comparison.EQ).named(\"equal_to_next_selector\")\n\n    # Use SequenceMap to set elements to 1 if they are equal to the next, otherwise keep the original value\n    result = rasp.SequenceMap(lambda x, y: 1 if y else x, rasp.tokens, equal_to_next_selector).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_one_if_equal_to_next() -> rasp.SOp:\n    # Shift the sequence one position to the right\n    shift_right = rasp.Aggregate(\n        rasp.Select(rasp.indices, rasp.indices, lambda x, y: (x + 1) % len(y) == y),\n        rasp.tokens\n    ).named(\"shift_right\")\n\n    # Create a selector that compares each element with the next\n    eq_next_selector = rasp.Select(rasp.tokens, shift_right, rasp.Comparison.EQ).named(\"eq_next_selector\")\n\n    # Create the final sequence where selected elements are set to 1\n    result = rasp.SequenceMap(\n        lambda x, y: 1 if y else x,\n        rasp.tokens,\n        eq_next_selector\n    ).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_one_if_equal_to_next() -> rasp.SOp:\n    # Shift the sequence cyclically by one position\n    shifted = rasp.Aggregate(\n        rasp.Select(rasp.indices, rasp.indices, lambda x, y: (y + 1) % len(x) == x),\n        rasp.tokens\n    ).named(\"shifted\")\n\n    # Compare each element with the next (including last with first) and set to 1 if equal\n    return rasp.SequenceMap(\n        lambda x, y: 1 if x == y else x,\n        rasp.tokens,\n        shifted\n    ).named(\"equal_to_next\")",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_one_if_equal_to_next() -> rasp.SOp:\n    # Create a selector for the next element (shifts sequence by 1)\n    next_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: (x + 1) % len(x), rasp.indices), rasp.Comparison.EQ)\n    \n    # Get the next element for each position\n    next_element = rasp.Aggregate(next_selector, rasp.tokens)\n    \n    # Create a selector that compares each element with its next element\n    equal_to_next = rasp.Select(rasp.tokens, next_element, rasp.Comparison.EQ).named(\"equal_to_next\")\n    \n    # Create the final sequence: 1 if equal to next, original value otherwise\n    result = rasp.SequenceMap(\n        lambda x, y: 1 if y else x,\n        rasp.tokens,\n        equal_to_next\n    ).named(\"result\")\n    \n    return result",
                "failure stage": 0,
                "error": ""
            }
        ],
        "make_swap_consecutive": [
            {
                "generated rasp code": "def make_swap_consecutive() -> rasp.SOp:\n    # Create a selector for even-indexed elements (0-indexed)\n    even_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: 0, rasp.indices),\n        lambda x, y: x % 2 == y\n    ).named(\"even_selector\")\n\n    # Create a selector for odd-indexed elements\n    odd_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: 1, rasp.indices),\n        lambda x, y: x % 2 == y\n    ).named(\"odd_selector\")\n\n    # Modify selectors to exclude the last element if it's at an odd index\n    sequence_length = rasp.Map(lambda x: len(x) - 1, rasp.tokens).named(\"sequence_length\")\n    last_element_odd = rasp.Select(sequence_length, rasp.Map(lambda x: 1, rasp.indices), lambda x, y: x % 2 == y).named(\"last_element_odd\")\n    \n    even_selector = even_selector & ~last_element_odd\n    odd_selector = odd_selector & ~rasp.Select(rasp.indices, sequence_length, rasp.Comparison.EQ)\n\n    # Shift even-indexed elements to the right\n    shift_right = rasp.Aggregate(even_selector, rasp.SequenceMap(\n        lambda x, y: y,\n        rasp.tokens,\n        rasp.Select(rasp.indices, rasp.Map(lambda x: x + 1, rasp.indices), rasp.Comparison.EQ)(rasp.tokens)\n    )).named(\"shift_right\")\n\n    # Shift odd-indexed elements to the left\n    shift_left = rasp.Aggregate(odd_selector, rasp.SequenceMap(\n        lambda x, y: y,\n        rasp.tokens,\n        rasp.Select(rasp.indices, rasp.Map(lambda x: x - 1, rasp.indices), rasp.Comparison.EQ)(rasp.tokens)\n    )).named(\"shift_left\")\n\n    # Combine the shifted sequences\n    combined = rasp.SequenceMap(\n        lambda x, y: x if x is not None else y,\n        shift_right,\n        shift_left\n    ).named(\"combined\")\n\n    # Handle the last element for odd-length sequences\n    last_element = rasp.Aggregate(\n        rasp.Select(rasp.indices, sequence_length, rasp.Comparison.EQ),\n        rasp.tokens\n    ).named(\"last_element\")\n\n    # Combine the swapped elements with the last element (if applicable)\n    final_result = rasp.SequenceMap(\n        lambda x, y: y if y is not None else x,\n        combined,\n        last_element\n    ).named(\"final_result\")\n\n    return final_result",
                "failure stage": 0,
                "error": "object of type 'TokensType' has no len()"
            },
            {
                "generated rasp code": "def make_swap_consecutive() -> rasp.SOp:\n    # Create a selector for even-indexed elements\n    even_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 0).named(\"even_selector\")\n    \n    # Create a selector for odd-indexed elements (inverse of even_selector)\n    odd_selector = ~even_selector\n    \n    # Shift even-indexed elements one position forward\n    shifted_even = rasp.Aggregate(rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y + 1), rasp.tokens).named(\"shifted_even\")\n    \n    # Shift odd-indexed elements one position backward\n    shifted_odd = rasp.Aggregate(rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y - 1), rasp.tokens).named(\"shifted_odd\")\n    \n    # Combine the shifted elements\n    swapped = rasp.SequenceMap(\n        lambda x, y: x if x is not None else y,\n        shifted_even,\n        shifted_odd\n    ).named(\"swapped\")\n    \n    # Handle the case of odd-length sequences\n    is_last_and_odd = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: len(x) - 1, rasp.tokens),\n        rasp.Comparison.EQ\n    ) & odd_selector\n    \n    result = rasp.SequenceMap(\n        lambda x, y: y if x else x,\n        is_last_and_odd,\n        rasp.tokens\n    ).named(\"result\")\n    \n    return rasp.SequenceMap(\n        lambda x, y: y if x is None else x,\n        swapped,\n        result\n    ).named(\"swap_consecutive\")",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_swap_consecutive() -> rasp.SOp:\n    # Create a selector for even indices\n    even_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 0).named(\"even_selector\")\n    \n    # Create a selector for odd indices\n    odd_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 1).named(\"odd_selector\")\n    \n    # Shift even-indexed elements to the left\n    shifted_even = rasp.Aggregate(\n        rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y + 1),\n        rasp.tokens\n    ).named(\"shifted_even\")\n    \n    # Shift odd-indexed elements to the right\n    shifted_odd = rasp.Aggregate(\n        rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y - 1),\n        rasp.tokens\n    ).named(\"shifted_odd\")\n    \n    # Create a selector for the last element if the sequence length is odd\n    last_element_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: len(x) - 1, rasp.tokens),\n        rasp.Comparison.EQ\n    ).named(\"last_element_selector\")\n    \n    # Combine shifted sequences, keeping the last element unchanged if necessary\n    swapped_sequence = rasp.SequenceMap(\n        lambda x, y, z, w: w if z else (x if y else y),\n        shifted_even,\n        shifted_odd,\n        last_element_selector,\n        rasp.tokens\n    ).named(\"swapped_sequence\")\n    \n    return swapped_sequence",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 6 were given"
            },
            {
                "generated rasp code": "def make_swap_consecutive() -> rasp.SOp:\n    # Selector for even-indexed elements\n    even_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 0).named(\"even_selector\")\n\n    # Selector for odd-indexed elements, excluding the last element if the sequence length is odd\n    odd_selector = rasp.Select(\n        rasp.indices,\n        rasp.indices,\n        lambda x, y: (x % 2 == 1) and (x < y - 1)\n    ).named(\"odd_selector\")\n\n    # Shift even-indexed elements to the right\n    shift_right = rasp.Aggregate(even_selector, rasp.SequenceMap(\n        lambda x, y: y,\n        rasp.tokens,\n        rasp.Map(lambda x: x - 1, rasp.indices)\n    )).named(\"shift_right\")\n\n    # Shift odd-indexed elements to the left\n    shift_left = rasp.Aggregate(odd_selector, rasp.SequenceMap(\n        lambda x, y: y,\n        rasp.tokens,\n        rasp.Map(lambda x: x + 1, rasp.indices)\n    )).named(\"shift_left\")\n\n    # Combine the shifted sequences\n    swapped = rasp.SequenceMap(\n        lambda x, y: x if x is not None else y,\n        shift_right,\n        shift_left\n    ).named(\"swapped\")\n\n    return swapped",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, None, None, 1.0, 1.0, 1.0]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_swap_consecutive() -> rasp.SOp:\n    # Create a selector for even indices\n    even_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 0).named(\"even_selector\")\n    \n    # Create sequences for even and odd-indexed elements\n    even_elements = rasp.Aggregate(even_selector, rasp.tokens).named(\"even_elements\")\n    odd_elements = rasp.Aggregate(~even_selector, rasp.tokens).named(\"odd_elements\")\n    \n    # Shift odd elements to the left\n    shift_left = rasp.SequenceMap(\n        lambda x, y: y if x > 0 else None,\n        rasp.indices,\n        odd_elements\n    ).named(\"shift_left\")\n    \n    # Combine even elements and shifted odd elements\n    swapped_sequence = rasp.Aggregate(\n        even_selector,\n        even_elements,\n        default=None\n    ) | rasp.Aggregate(\n        ~even_selector,\n        shift_left,\n        default=None\n    ).named(\"swapped_sequence\")\n    \n    return swapped_sequence",
                "failure stage": 1,
                "error": "Unsupported type for aggregation: [0.3333333333333333, 0.3333333333333333, 0.3333333333333333]"
            }
        ],
        "make_check_palindrome": [
            {
                "generated rasp code": "def make_check_palindrome() -> rasp.SOp:\n    # Create a selector that compares each element with its counterpart from the end\n    palindrome_selector = rasp.Select(\n        rasp.tokens,\n        rasp.Aggregate(rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.EQ), rasp.tokens),\n        rasp.Comparison.EQ\n    ).named(\"palindrome_selector\")\n\n    # Count the number of matching pairs\n    match_count = rasp.SelectorWidth(palindrome_selector).named(\"match_count\")\n\n    # Calculate the sequence length\n    seq_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"seq_length\")\n\n    # Calculate the expected number of matches for a palindrome (half the length, rounded down)\n    expected_matches = rasp.Map(lambda x: x // 2, seq_length).named(\"expected_matches\")\n\n    # Compare actual matches with expected matches\n    is_palindrome = rasp.SequenceMap(\n        lambda actual, expected: 1 if actual >= expected else 0,\n        match_count,\n        expected_matches\n    ).named(\"is_palindrome\")\n\n    return is_palindrome",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_check_palindrome():\n    # Create a selector that compares each element with its reversed counterpart\n    palindrome_selector = rasp.Select(\n        rasp.tokens,\n        rasp.Aggregate(rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.EQ), rasp.tokens),\n        rasp.Comparison.EQ\n    ).named(\"palindrome_selector\")\n\n    # Count the number of matches\n    match_count = rasp.SelectorWidth(palindrome_selector).named(\"match_count\")\n\n    # Create a sequence of the expected number of matches (which is the length of the sequence)\n    sequence_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"sequence_length\")\n\n    # Compare the actual matches with the expected matches\n    is_palindrome = rasp.SequenceMap(\n        lambda x, y: 1 if x == y else 0,\n        match_count,\n        sequence_length\n    ).named(\"is_palindrome\")\n\n    # Broadcast the result across the entire sequence\n    result = rasp.Aggregate(\n        rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.EQ),\n        is_palindrome\n    ).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_check_palindrome() -> rasp.SOp:\n    # Create a selector that compares each element with its corresponding element from the end\n    palindrome_selector = rasp.Select(\n        rasp.tokens,\n        rasp.Aggregate(rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.EQ), rasp.tokens),\n        rasp.Comparison.EQ\n    ).named(\"palindrome_selector\")\n\n    # Count the number of matching pairs\n    matching_pairs = rasp.SelectorWidth(palindrome_selector).named(\"matching_pairs\")\n\n    # Create a sequence of the total sequence length\n    sequence_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"sequence_length\")\n\n    # Compare the number of matching pairs with the sequence length\n    is_palindrome = rasp.SequenceMap(\n        lambda x, y: 1 if x == y else 0,\n        matching_pairs,\n        sequence_length\n    ).named(\"is_palindrome\")\n\n    return is_palindrome",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_check_palindrome() -> rasp.SOp:\n    # Create a selector that compares each element with its mirror counterpart\n    mirror_selector = rasp.Select(\n        rasp.tokens,\n        rasp.Aggregate(rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.EQ), rasp.tokens),\n        rasp.Comparison.EQ\n    ).named(\"mirror_selector\")\n\n    # Count the number of matching pairs\n    match_count = rasp.SelectorWidth(mirror_selector).named(\"match_count\")\n\n    # Calculate the sequence length\n    seq_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"seq_length\")\n\n    # Calculate the expected number of matches for a palindrome\n    # For both odd and even length sequences, this will be floor(length / 2)\n    expected_matches = rasp.Map(lambda x: x // 2, seq_length).named(\"expected_matches\")\n\n    # Compare the actual match count with the expected match count\n    is_palindrome = rasp.SequenceMap(\n        lambda actual, expected: 1 if actual >= expected else 0,\n        match_count,\n        expected_matches\n    ).named(\"is_palindrome\")\n\n    return is_palindrome",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_check_palindrome() -> rasp.SOp:\n    # Create a selector that compares each element with its corresponding element from the end\n    palindrome_selector = rasp.Select(\n        rasp.tokens, \n        rasp.Aggregate(rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.EQ), rasp.tokens),\n        rasp.Comparison.EQ\n    ).named(\"palindrome_selector\")\n\n    # Count the number of matches\n    match_count = rasp.SelectorWidth(palindrome_selector).named(\"match_count\")\n\n    # Create a sequence of the total length\n    total_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"total_length\")\n\n    # Calculate the expected number of matches and compare with actual matches\n    is_palindrome = rasp.SequenceMap(\n        lambda count, length: 1 if count == length // 2 else 0,\n        match_count,\n        total_length\n    ).named(\"is_palindrome\")\n\n    return is_palindrome",
                "failure stage": 0,
                "error": "test_run_op timed out"
            }
        ],
        "make_next_prime": [
            {
                "generated rasp code": "def make_next_prime(max_value=100) -> rasp.SOp:\n    # Create a sequence of all numbers from 2 to max_value\n    all_numbers = rasp.Map(lambda x: x + 2, rasp.indices).named(\"all_numbers\")\n    \n    # Create a selector for prime numbers\n    is_prime_selector = rasp.Select(\n        all_numbers,\n        all_numbers,\n        lambda x, y: (y == 2) or (y > 2 and all(y % i != 0 for i in range(2, int(y**0.5) + 1)))\n    ).named(\"is_prime_selector\")\n    \n    # Create a sequence of prime numbers\n    primes = rasp.Aggregate(is_prime_selector, all_numbers).named(\"primes\")\n    \n    # Create a selector for numbers greater than the input\n    greater_selector = rasp.Select(primes, rasp.tokens, rasp.Comparison.GT).named(\"greater_selector\")\n    \n    # Find the next prime for each input number\n    next_prime = rasp.Aggregate(greater_selector, primes).named(\"next_prime\")\n    \n    # If the input is already prime, keep it; otherwise, use the next prime\n    return rasp.SequenceMap(\n        lambda x, y: x if (x == 2) or (x > 2 and all(x % i != 0 for i in range(2, int(x**0.5) + 1))) else y,\n        rasp.tokens,\n        next_prime\n    ).named(\"final_next_prime\")",
                "failure stage": 1,
                "error": "key is None!"
            }
        ],
        "make_mask_sequence": [
            {
                "generated rasp code": "def make_mask_sequence(index: int = 1) -> rasp.SOp:\n    # Create a sequence of indices\n    indices = rasp.Map(lambda x: x, rasp.indices).named(\"indices\")\n    \n    # Create a selector that identifies the element at the specified index\n    index_selector = rasp.Select(indices, rasp.Map(lambda x: index, rasp.indices), rasp.Comparison.EQ).named(\"index_selector\")\n    \n    # Use SequenceMap to create the masked sequence\n    masked_sequence = rasp.SequenceMap(\n        lambda x, y: x if y else 0,\n        rasp.tokens,\n        index_selector\n    ).named(\"masked_sequence\")\n    \n    return masked_sequence",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_mask_sequence(index: int = 1) -> rasp.SOp:\n    # Create a selector that identifies the element at the specified index\n    index_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: index, rasp.indices), rasp.Comparison.EQ).named(\"index_selector\")\n\n    # Apply the mask: keep the selected element, set others to 0\n    masked_sequence = rasp.SequenceMap(\n        lambda x, y: x if y else 0,\n        rasp.tokens,\n        index_selector\n    ).named(\"masked_sequence\")\n\n    return masked_sequence",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_mask_sequence(index: int = 1) -> rasp.SOp:\n    # Adjust index to be 0-based\n    zero_based_index = index - 1\n\n    # Create a selector that identifies the element at the specified index\n    index_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: zero_based_index, rasp.indices), rasp.Comparison.EQ).named(\"index_selector\")\n\n    # Use Aggregate to keep the element at the specified index and replace others with 0\n    masked_sequence = rasp.Aggregate(index_selector, rasp.tokens, default=0).named(\"masked_sequence\")\n\n    return masked_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3.0, 3.0, 3.0, 3.0, 3.0, 3.0]. (0.976 error rate)"
            },
            {
                "generated rasp code": "def make_mask_sequence(index: int = 1) -> rasp.SOp:\n    # Create a selector that identifies the element at the specified index\n    index_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: index, rasp.indices), rasp.Comparison.EQ).named(\"index_selector\")\n\n    # Create the masked sequence\n    masked_sequence = rasp.SequenceMap(\n        lambda x, y: x if y else 0,\n        rasp.tokens,\n        index_selector\n    ).named(\"masked_sequence\")\n\n    return masked_sequence",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_mask_sequence(index: int = 1) -> rasp.SOp:\n    def mask_sequence(index: int = index) -> rasp.SOp:\n        # Create a sequence where each element is the specified index\n        index_sequence = rasp.Map(lambda x: index, rasp.indices).named(\"index_sequence\")\n        \n        # Create a selector that selects the element at the specified index\n        index_selector = rasp.Select(rasp.indices, index_sequence, rasp.Comparison.EQ).named(\"index_selector\")\n        \n        # Use Aggregate to keep the selected element and set others to 0\n        masked_sequence = rasp.Aggregate(index_selector, rasp.tokens, default=0).named(\"masked_sequence\")\n        \n        return masked_sequence\n    \n    return mask_sequence\n\n# Usage:\n# mask = make_mask_sequence()\n# result = mask([1, 2, 3, 4, 5])  # returns [0, 2, 0, 0, 0]\n# result = mask([1, 2, 3, 4, 5], index=3)  # returns [0, 0, 0, 4, 0]",
                "failure stage": 2,
                "error": "<class 'function'>"
            }
        ],
        "make_wrap": [
            {
                "generated rasp code": "def make_wrap(lower_bound: int = 2, upper_bound: int = 7) -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that wraps each element within the specified range.\n    \n    Args:\n    lower_bound (int): The lower bound of the range (default: 2)\n    upper_bound (int): The upper bound of the range (default: 7)\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that wraps input values\n    \"\"\"\n    \n    # Calculate the range size\n    range_size = upper_bound - lower_bound + 1\n    \n    # Define the wrapping function\n    def wrap_value(x):\n        # Subtract lower_bound, apply modulo, and add lower_bound back\n        return ((x - lower_bound) % range_size) + lower_bound\n    \n    # Apply the wrapping function to each element in the sequence\n    wrapped_sequence = rasp.Map(wrap_value, rasp.tokens).named(\"wrapped_sequence\")\n    \n    return wrapped_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3, 2, 2, 7, 5, 4]. (0.894 error rate)"
            },
            {
                "generated rasp code": "def make_wrap(lower: int = 2, upper: int = 7) -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that wraps each element within the specified range.\n    \n    Args:\n    lower (int): The lower bound of the range (default: 2)\n    upper (int): The upper bound of the range (default: 7)\n    \n    Returns:\n    rasp.SOp: A RASP sequence operation that wraps input values\n    \"\"\"\n    range_size = upper - lower + 1\n    \n    def wrap_value(x):\n        # Subtract lower bound, apply modulo, then add lower bound back\n        return ((x - lower) % range_size) + lower\n    \n    wrapped_sequence = rasp.Map(wrap_value, rasp.tokens).named(\"wrapped_sequence\")\n    \n    return wrapped_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3, 2, 2, 7, 5, 4]. (0.894 error rate)"
            },
            {
                "generated rasp code": "def make_wrap(lower: int = 2, upper: int = 7) -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that wraps each element within a specified range.\n    \n    Args:\n    lower (int): The lower bound of the range (default: 2)\n    upper (int): The upper bound of the range (default: 7)\n    \n    Returns:\n    rasp.SOp: A RASP program that wraps input values within the specified range\n    \"\"\"\n    # Calculate the range size\n    range_size = upper - lower + 1\n    \n    # Define the wrapping function\n    def wrap(x):\n        # Subtract lower bound, apply modulo, and add lower bound back\n        return ((x - lower) % range_size) + lower\n    \n    # Apply the wrapping function to each element in the input sequence\n    wrapped_sequence = rasp.Map(wrap, rasp.tokens).named(\"wrapped_sequence\")\n    \n    return wrapped_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3, 2, 2, 7, 5, 4]. (0.894 error rate)"
            },
            {
                "generated rasp code": "def make_wrap(lower_bound: int = 2, upper_bound: int = 7) -> rasp.SOp:\n    \"\"\"\n    Creates a RASP program that wraps each element within the specified range.\n    \n    Args:\n    lower_bound (int): The lower bound of the range (default: 2)\n    upper_bound (int): The upper bound of the range (default: 7)\n    \n    Returns:\n    rasp.SOp: A RASP program that wraps input values within the specified range\n    \"\"\"\n    # Calculate the range size\n    range_size = upper_bound - lower_bound + 1\n    \n    # Define the wrapping function\n    def wrap_value(x):\n        # Subtract lower_bound, apply modulo, and add lower_bound back\n        return ((x - lower_bound) % range_size) + lower_bound\n    \n    # Apply the wrapping function to each element in the input sequence\n    wrapped_sequence = rasp.Map(wrap_value, rasp.tokens).named(\"wrapped_sequence\")\n    \n    return wrapped_sequence\n\n# Usage example:\n# wrap = make_wrap()  # Uses default range [2, 7]\n# wrap = make_wrap(1, 4)  # Uses custom range [1, 4]",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3, 2, 2, 7, 5, 4]. (0.894 error rate)"
            },
            {
                "generated rasp code": "def make_wrap(lower_bound: int = 2, upper_bound: int = 7) -> rasp.SOp:\n    # Calculate the range size\n    range_size = upper_bound - lower_bound + 1\n\n    # Define the wrapping function\n    def wrap(x):\n        return ((x - lower_bound) % range_size) + lower_bound\n\n    # Apply the wrapping function to each element in the sequence\n    wrapped_sequence = rasp.Map(lambda x: wrap(x), rasp.tokens).named(\"wrapped_sequence\")\n\n    return wrapped_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3, 2, 2, 7, 5, 4]. (0.894 error rate)"
            }
        ],
        "make_alternate_elements": [
            {
                "generated rasp code": "def make_alternate_elements() -> rasp.SOp:\n    # Create a selector for odd-indexed positions (1-based indexing)\n    odd_selector = rasp.Select(\n        rasp.Map(lambda x: x + 1, rasp.indices),  # Convert to 1-based indexing\n        rasp.Map(lambda x: 2, rasp.indices),      # Constant sequence of 2\n        rasp.Comparison.GT\n    ).named(\"odd_selector\")\n\n    # Create a sequence of indices (1-based)\n    indices_seq = rasp.Map(lambda x: x + 1, rasp.indices).named(\"indices_seq\")\n\n    # Combine original sequence with indices using SequenceMap\n    alternated_seq = rasp.SequenceMap(\n        lambda orig, idx: idx if odd_selector(orig) else orig,\n        rasp.tokens,\n        indices_seq\n    ).named(\"alternated_seq\")\n\n    return alternated_seq",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_alternate_elements() -> rasp.SOp:\n    # Create a selector for odd-indexed positions (1-based indexing)\n    odd_selector = rasp.Select(\n        rasp.Map(lambda x: x + 1, rasp.indices),  # Convert to 1-based indexing\n        rasp.Map(lambda x: 2, rasp.indices),      # Constant sequence of 2\n        rasp.Comparison.GT\n    ).named(\"odd_selector\")\n\n    # Create a sequence of indices (0-based)\n    indices_sequence = rasp.indices.named(\"indices_sequence\")\n\n    # Use SequenceMap to alternate between original elements and indices\n    alternated_sequence = rasp.SequenceMap(\n        lambda orig, idx: idx if odd_selector(orig) else orig,\n        rasp.tokens,\n        indices_sequence\n    ).named(\"alternated_sequence\")\n\n    return alternated_sequence",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_alternate_elements() -> rasp.SOp:\n    # Create a selector for odd-indexed positions\n    odd_selector = rasp.Select(\n        rasp.Map(lambda x: x % 2, rasp.indices),\n        rasp.Map(lambda x: 1, rasp.indices),\n        rasp.Comparison.EQ\n    ).named(\"odd_selector\")\n\n    # Use SequenceMap to choose between index (for odd positions) and original element (for even positions)\n    alternated = rasp.SequenceMap(\n        lambda x, y: y if x else y,\n        odd_selector,\n        rasp.SequenceMap(\n            lambda x, y: x if y else y,\n            rasp.indices,\n            rasp.tokens\n        )\n    ).named(\"alternated\")\n\n    return alternated",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_alternate_elements() -> rasp.SOp:\n    # Create a selector for even-indexed positions (0-based indexing)\n    even_selector = rasp.Select(\n        rasp.Map(lambda x: x % 2, rasp.indices),\n        rasp.Map(lambda x: 0, rasp.indices),\n        rasp.Comparison.EQ\n    ).named(\"even_selector\")\n\n    # Create a sequence of indices (add 1 to match 1-based indexing in the output)\n    indices_seq = rasp.Map(lambda x: x + 1, rasp.indices).named(\"indices_seq\")\n\n    # Combine original sequence with indices based on the selector\n    alternated = rasp.SequenceMap(\n        lambda x, y: x if y else y,\n        rasp.tokens,\n        rasp.Aggregate(even_selector, indices_seq)\n    ).named(\"alternated\")\n\n    return alternated",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3, 8, 2, 1, 5, 4]. (0.861 error rate)"
            },
            {
                "generated rasp code": "def make_alternate_elements() -> rasp.SOp:\n    # Create a selector for odd-indexed positions (1-based indexing)\n    odd_selector = rasp.Select(\n        rasp.Map(lambda x: x + 1, rasp.indices),  # Convert to 1-based indexing\n        rasp.Map(lambda x: 2, rasp.tokens),  # Constant sequence of 2's\n        rasp.Comparison.GT  # Select positions where (index + 1) % 2 == 1\n    ).named(\"odd_selector\")\n\n    # Create a sequence where odd positions contain their indices (0-based)\n    # and even positions contain a placeholder (we'll use None)\n    alternated_sequence = rasp.Aggregate(odd_selector, rasp.indices).named(\"alternated_sequence\")\n\n    # Combine the original sequence with the alternated sequence\n    # Use the original value where alternated_sequence is None, otherwise use the alternated value\n    result = rasp.SequenceMap(\n        lambda original, alternated: alternated if alternated is not None else original,\n        rasp.tokens,\n        alternated_sequence\n    ).named(\"result\")\n\n    return result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3.5, 3.5, 3.5, 3.5, 3.5, 3.5]. (1.0 error rate)"
            }
        ],
        "make_check_last_two_equal": [
            {
                "generated rasp code": "def make_check_last_two_equal() -> rasp.SOp:\n    # Shift the sequence by one position to the left\n    shifted_sequence = rasp.SequenceMap(\n        lambda x, y: y,\n        rasp.tokens,\n        rasp.Aggregate(rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.GT), rasp.tokens)\n    ).named(\"shifted_sequence\")\n\n    # Compare the original sequence with the shifted sequence\n    comparison = rasp.SequenceMap(\n        lambda x, y: int(x == y),\n        rasp.tokens,\n        shifted_sequence\n    ).named(\"comparison\")\n\n    # Handle the case where the sequence has only one element\n    single_element_case = rasp.Map(\n        lambda x: 0 if len(x) == 1 else x,\n        comparison\n    ).named(\"single_element_case\")\n\n    # Map the result to the entire sequence\n    result = rasp.Map(\n        lambda x: x[-1] if len(x) > 1 else x,\n        single_element_case\n    ).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_check_last_two_equal() -> rasp.SOp:\n    # Create a selector for the second-to-last element\n    second_to_last_selector = rasp.Select(\n        rasp.indices, \n        rasp.Map(lambda x: len(x) - 2, rasp.tokens), \n        rasp.Comparison.EQ\n    ).named(\"second_to_last_selector\")\n\n    # Create a selector for the last element\n    last_selector = rasp.Select(\n        rasp.indices, \n        rasp.Map(lambda x: len(x) - 1, rasp.tokens), \n        rasp.Comparison.EQ\n    ).named(\"last_selector\")\n\n    # Extract the second-to-last element\n    second_to_last = rasp.Aggregate(second_to_last_selector, rasp.tokens).named(\"second_to_last\")\n\n    # Extract the last element\n    last = rasp.Aggregate(last_selector, rasp.tokens).named(\"last\")\n\n    # Compare the last two elements\n    are_equal = rasp.SequenceMap(lambda x, y: float(x == y), second_to_last, last).named(\"are_equal\")\n\n    # Handle single-element case and broadcast result\n    result = rasp.Map(\n        lambda x: 0 if x is None else x,\n        are_equal\n    ).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_check_last_two_equal() -> rasp.SOp:\n    # Select the second-to-last element\n    select_second_last = rasp.Select(\n        rasp.indices, \n        rasp.Map(lambda x: len(x) - 2, rasp.tokens), \n        rasp.Comparison.EQ\n    ).named(\"select_second_last\")\n\n    # Select the last element\n    select_last = rasp.Select(\n        rasp.indices, \n        rasp.Map(lambda x: len(x) - 1, rasp.tokens), \n        rasp.Comparison.EQ\n    ).named(\"select_last\")\n\n    # Get the second-to-last and last elements\n    second_last = rasp.Aggregate(select_second_last, rasp.tokens).named(\"second_last\")\n    last = rasp.Aggregate(select_last, rasp.tokens).named(\"last\")\n\n    # Check if the last two elements are equal\n    are_equal = rasp.Select(second_last, last, rasp.Comparison.EQ).named(\"are_equal\")\n\n    # Count the number of True values in are_equal (should be 1 if equal, 0 if not)\n    equal_count = rasp.SelectorWidth(are_equal).named(\"equal_count\")\n\n    # Create a selector for sequences of length 1\n    is_length_one = rasp.Select(\n        rasp.Map(lambda x: len(x), rasp.tokens),\n        rasp.Map(lambda x: 1, rasp.tokens),\n        rasp.Comparison.EQ\n    ).named(\"is_length_one\")\n\n    # Combine results: 1 if last two are equal and length > 1, 0 otherwise\n    result = rasp.SequenceMap(\n        lambda x, y: 1 if x > 0 and not y else 0,\n        equal_count,\n        is_length_one\n    ).named(\"result\")\n\n    # Map the result to the entire sequence\n    final_result = rasp.Map(lambda x: x, result).named(\"final_result\")\n\n    return final_result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_check_last_two_equal() -> rasp.SOp:\n    # Create a selector for the second-to-last element\n    second_to_last_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: len(x) - 2, rasp.tokens),\n        rasp.Comparison.EQ\n    ).named(\"second_to_last_selector\")\n\n    # Extract the second-to-last element\n    second_to_last = rasp.Aggregate(second_to_last_selector, rasp.tokens).named(\"second_to_last\")\n\n    # Compare the second-to-last element with the last element\n    are_last_two_equal = rasp.SequenceMap(\n        lambda x, y: float(x == y) if x is not None else 0.0,\n        second_to_last,\n        rasp.tokens\n    ).named(\"are_last_two_equal\")\n\n    # Handle single-element case and broadcast the result\n    result = rasp.Map(\n        lambda x: 1.0 if x == 1.0 else 0.0,\n        are_last_two_equal\n    ).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_check_last_two_equal() -> rasp.SOp:\n    # Create selectors for the last and second-to-last elements\n    select_last = rasp.Select(rasp.indices, rasp.Map(lambda x: len(x) - 1, rasp.tokens), rasp.Comparison.EQ)\n    select_second_last = rasp.Select(rasp.indices, rasp.Map(lambda x: len(x) - 2, rasp.tokens), rasp.Comparison.EQ)\n\n    # Get the values of the last and second-to-last elements\n    last_value = rasp.Aggregate(select_last, rasp.tokens)\n    second_last_value = rasp.Aggregate(select_second_last, rasp.tokens)\n\n    # Compare the last two values\n    are_equal = rasp.Select(last_value, second_last_value, rasp.Comparison.EQ)\n\n    # Convert boolean result to 0 or 1\n    result = rasp.SelectorWidth(are_equal)\n\n    # Create a constant 0 sequence for the single-element case\n    zero_sequence = rasp.Map(lambda x: 0, rasp.tokens)\n\n    # Check if the sequence has more than one element\n    has_multiple_elements = rasp.Select(\n        rasp.Map(lambda x: len(x), rasp.tokens),\n        rasp.Map(lambda x: 1, rasp.tokens),\n        rasp.Comparison.GT\n    )\n\n    # Combine the result with the single-element case handling\n    final_result = rasp.SequenceMap(\n        lambda x, y: x * y,\n        result,\n        rasp.Aggregate(has_multiple_elements, rasp.Map(lambda x: 1, rasp.tokens), default=None)\n    )\n\n    return final_result.named(\"check_last_two_equal\")",
                "failure stage": 0,
                "error": "test_run_op timed out"
            }
        ],
        "make_insert_zeros": [
            {
                "generated rasp code": "def make_insert_zeros() -> rasp.SOp:\n    # Selector for even indices (0, 2, 4, ...)\n    even_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 0).named(\"even_selector\")\n\n    # Selector for odd indices (1, 3, 5, ...)\n    odd_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 1).named(\"odd_selector\")\n\n    # Place original elements at even positions\n    even_elements = rasp.Aggregate(even_selector, rasp.tokens).named(\"even_elements\")\n\n    # Place zeros at odd positions\n    odd_elements = rasp.Aggregate(odd_selector, rasp.tokens).named(\"odd_elements\")\n\n    # Combine even and odd elements, using 0 for odd positions and the original elements for even positions\n    result = rasp.SequenceMap(\n        lambda x, y: x if y is None else 0,\n        even_elements,\n        odd_elements\n    ).named(\"result\")\n\n    return result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0, 0, 0, 0, 0, 0]. (0.987 error rate)"
            },
            {
                "generated rasp code": "def make_insert_zeros() -> rasp.SOp:\n    # Create a selector that alternates between True and False\n    alternating_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: 2, rasp.indices),\n        rasp.Comparison.LT\n    ).named(\"alternating_selector\")\n\n    # Create a sequence of zeros\n    zeros = rasp.Map(lambda x: 0, rasp.tokens).named(\"zeros\")\n\n    # Shift the original sequence to the right by one position\n    shifted_sequence = rasp.SequenceMap(\n        lambda x, y: y if x > 0 else 0,\n        rasp.indices,\n        rasp.tokens\n    ).named(\"shifted_sequence\")\n\n    # Use the alternating selector to choose between shifted sequence and zeros\n    result = rasp.Aggregate(alternating_selector, shifted_sequence, default=None).named(\"result\")\n\n    # Fill in the gaps with zeros\n    final_result = rasp.SequenceMap(\n        lambda x, y: x if x is not None else y,\n        result,\n        zeros\n    ).named(\"final_result\")\n\n    return final_result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [4.0, 4.0, 4.0, 4.0, 4.0, 4.0]. (0.988 error rate)"
            },
            {
                "generated rasp code": "def make_insert_zeros() -> rasp.SOp:\n    # Create a selector for even indices\n    even_selector = rasp.Select(\n        rasp.Map(lambda x: x % 2, rasp.indices),\n        rasp.Map(lambda x: 0, rasp.indices),\n        rasp.Comparison.EQ\n    ).named(\"even_selector\")\n\n    # Use Aggregate to place original elements at even positions\n    original_elements = rasp.Aggregate(even_selector, rasp.tokens).named(\"original_elements\")\n\n    # Create a sequence of zeros\n    zeros = rasp.Map(lambda x: 0, rasp.indices).named(\"zeros\")\n\n    # Combine original elements and zeros\n    result = rasp.SequenceMap(\n        lambda x, y: x if x is not None else y,\n        original_elements,\n        zeros\n    ).named(\"result\")\n\n    return result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335]. (0.882 error rate)"
            },
            {
                "generated rasp code": "def make_insert_zeros() -> rasp.SOp:\n    # Create a selector that alternates between True and False\n    alternating_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: 0, rasp.indices),\n        rasp.Comparison.EQ\n    ).named(\"alternating_selector\")\n\n    # Create a sequence of zeros\n    zeros = rasp.Map(lambda x: 0, rasp.tokens).named(\"zeros\")\n\n    # Shift the original elements to the left by half their original positions\n    shifted_tokens = rasp.SequenceMap(\n        lambda x, y: y if x % 2 == 0 else None,\n        rasp.indices,\n        rasp.tokens\n    ).named(\"shifted_tokens\")\n\n    # Use Aggregate to select between shifted tokens and zeros\n    result = rasp.Aggregate(alternating_selector, shifted_tokens, default=None).named(\"result\")\n\n    # Fill in the gaps with zeros\n    final_result = rasp.SequenceMap(\n        lambda x, y: 0 if x is None else x,\n        result,\n        zeros\n    ).named(\"final_result\")\n\n    return final_result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3.0, 3.0, 3.0, 3.0, 3.0, 3.0]. (0.88 error rate)"
            },
            {
                "generated rasp code": "def make_insert_zeros() -> rasp.SOp:\n    # Create a selector that is True for even indices and False for odd indices\n    even_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 0).named(\"even_selector\")\n    \n    # Shift the selector by one position to insert zeros between elements\n    shifted_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: (x + 1) % 2 == 0).named(\"shifted_selector\")\n    \n    # Create a sequence of zeros\n    zeros = rasp.Map(lambda x: 0, rasp.tokens).named(\"zeros\")\n    \n    # Use Aggregate to select between original elements and zeros\n    result = rasp.Aggregate(shifted_selector, rasp.tokens, default=None).named(\"result\")\n    \n    # Fill in the gaps with zeros\n    final_result = rasp.SequenceMap(lambda x, y: x if x is not None else y, result, zeros).named(\"final_result\")\n    \n    return final_result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [4.333333333333333, 4.333333333333333, 4.333333333333333, 4.333333333333333, 4.333333333333333, 4.333333333333333]. (0.999 error rate)"
            }
        ],
        "make_last_element": [
            {
                "generated rasp code": "def make_last_element() -> rasp.SOp:\n    # Create a selector that identifies the last element\n    last_element_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: len(x) - 1, rasp.tokens),\n        rasp.Comparison.EQ\n    ).named(\"last_element_selector\")\n\n    # Extract the last element\n    last_element = rasp.Aggregate(last_element_selector, rasp.tokens).named(\"last_element\")\n\n    # Create a selector for all elements except the last one\n    other_elements_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: len(x) - 1, rasp.tokens),\n        rasp.Comparison.LT\n    ).named(\"other_elements_selector\")\n\n    # Replace all other elements with zeros\n    zero_padded = rasp.Aggregate(other_elements_selector, rasp.Map(lambda x: 0, rasp.tokens)).named(\"zero_padded\")\n\n    # Combine the last element with the zero-padded sequence\n    result = rasp.SequenceMap(\n        lambda x, y: x if x is not None else y,\n        last_element,\n        zero_padded\n    ).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_last_element() -> rasp.SOp:\n    # Create a selector for the last element\n    last_element_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: len(x) - 1, rasp.tokens),\n        rasp.Comparison.EQ\n    ).named(\"last_element_selector\")\n\n    # Broadcast the last element to all positions\n    last_element_broadcast = rasp.Aggregate(last_element_selector, rasp.tokens).named(\"last_element_broadcast\")\n\n    # Create a sequence of zeros\n    zeros = rasp.Map(lambda x: 0, rasp.tokens).named(\"zeros\")\n\n    # Combine the last element with zeros based on position\n    result = rasp.SequenceMap(\n        lambda x, y: y if x else 0,\n        last_element_selector,\n        last_element_broadcast\n    ).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_last_element() -> rasp.SOp:\n    # Selector that selects only the last element\n    last_element_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: len(x) - 1, rasp.tokens),\n        rasp.Comparison.EQ\n    ).named(\"last_element_selector\")\n\n    # Broadcast the last element across the entire sequence\n    last_element_broadcast = rasp.Aggregate(last_element_selector, rasp.tokens).named(\"last_element_broadcast\")\n\n    # Selector that selects all positions except the last one\n    not_last_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: len(x) - 1, rasp.tokens),\n        rasp.Comparison.LT\n    ).named(\"not_last_selector\")\n\n    # Create a sequence of zeros\n    zeros = rasp.Map(lambda x: 0, rasp.tokens).named(\"zeros\")\n\n    # Combine the last element with zeros\n    result = rasp.SequenceMap(\n        lambda x, y: y if x else 0,\n        not_last_selector,\n        last_element_broadcast\n    ).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_last_element() -> rasp.SOp:\n    # Create a selector for the last element\n    last_element_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: len(x) - 1, rasp.tokens),\n        rasp.Comparison.EQ\n    ).named(\"last_element_selector\")\n\n    # Extract the last element\n    last_element = rasp.Aggregate(last_element_selector, rasp.tokens).named(\"last_element\")\n\n    # Create a selector for all elements except the last one\n    other_elements_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: len(x) - 1, rasp.tokens),\n        rasp.Comparison.LT\n    ).named(\"other_elements_selector\")\n\n    # Create a sequence of zeros\n    zeros = rasp.Map(lambda x: 0, rasp.tokens).named(\"zeros\")\n\n    # Combine the last element with zeros\n    result = rasp.SequenceMap(\n        lambda x, y: y if x else x,\n        last_element_selector,\n        last_element\n    ).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_last_element() -> rasp.SOp:\n    # Selector that selects only the last element\n    last_element_selector = rasp.Select(\n        rasp.indices, \n        rasp.Map(lambda x: len(x) - 1, rasp.tokens), \n        rasp.Comparison.EQ\n    ).named(\"last_element_selector\")\n\n    # Get the last element\n    last_element = rasp.Aggregate(last_element_selector, rasp.tokens).named(\"last_element\")\n\n    # Selector that selects all elements except the last one\n    other_elements_selector = rasp.Select(\n        rasp.indices, \n        rasp.Map(lambda x: len(x) - 1, rasp.tokens), \n        rasp.Comparison.LT\n    ).named(\"other_elements_selector\")\n\n    # Replace all other elements with zeros\n    zero_padded = rasp.Aggregate(other_elements_selector, rasp.tokens, default=0).named(\"zero_padded\")\n\n    # Combine the last element with the zero-padded sequence\n    result = rasp.SequenceMap(\n        lambda x, y: x if x is not None else y,\n        last_element,\n        zero_padded\n    ).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": "test_run_op timed out"
            }
        ],
        "make_difference_to_next": [
            {
                "generated rasp code": "def make_difference_to_next() -> rasp.SOp:\n    # Create a selector that selects the next element for each position\n    next_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y - 1).named(\"next_selector\")\n\n    # Shift the sequence by one position to the right\n    shifted_sequence = rasp.Aggregate(next_selector, rasp.tokens).named(\"shifted_sequence\")\n\n    # Subtract the original sequence from the shifted sequence\n    difference = rasp.SequenceMap(lambda x, y: x - y if x is not None else None, \n                                  shifted_sequence, rasp.tokens).named(\"difference\")\n\n    # Replace None with 0 for the last element\n    result = rasp.Map(lambda x: 0 if x is None else x, difference).named(\"result\")\n\n    return result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, -5.0, 6.0, 1.0, -4.0, 1.0]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_difference_to_next() -> rasp.SOp:\n    # Selector for the next element (shifts attention one step to the right)\n    next_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y - 1).named(\"next_selector\")\n\n    # Shift the sequence one position to the left (get the \"next\" element for each position)\n    shifted_sequence = rasp.Aggregate(next_selector, rasp.tokens).named(\"shifted_sequence\")\n\n    # Calculate the difference between the shifted sequence and the original sequence\n    difference_sequence = rasp.SequenceMap(lambda x, y: x - y if x is not None else 0, \n                                           shifted_sequence, rasp.tokens).named(\"difference_sequence\")\n\n    # Create a selector for the last element\n    last_element_selector = rasp.Select(rasp.indices, rasp.indices, \n                                        lambda x, y: x == y).named(\"last_element_selector\")\n\n    # Create a sequence of zeros\n    zero_sequence = rasp.Map(lambda x: 0, rasp.tokens).named(\"zero_sequence\")\n\n    # Combine the difference sequence with zeros, selecting zero for the last element\n    final_sequence = rasp.SequenceMap(\n        lambda diff, zero: zero if diff is None else diff,\n        difference_sequence,\n        rasp.Aggregate(last_element_selector, zero_sequence)\n    ).named(\"final_sequence\")\n\n    return final_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, -5.0, 6.0, 1.0, -4.0, 1.0]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_difference_to_next() -> rasp.SOp:\n    # Create a selector that selects the next element for each position\n    next_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y - 1).named(\"next_selector\")\n\n    # Use Aggregate to shift the sequence by one position to the right\n    shifted = rasp.Aggregate(next_selector, rasp.tokens).named(\"shifted\")\n\n    # Replace None values with 0 in the shifted sequence\n    shifted_zero = rasp.Map(lambda x: 0 if x is None else x, shifted).named(\"shifted_zero\")\n\n    # Subtract the original sequence from the shifted sequence\n    difference = rasp.SequenceMap(lambda x, y: x - y, shifted_zero, rasp.tokens).named(\"difference\")\n\n    return difference",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, -5.0, 6.0, 1.0, -4.0, 1.0]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_difference_to_next() -> rasp.SOp:\n    # Create a selector that selects the next element for each position\n    shift_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y - 1).named(\"shift_selector\")\n\n    # Create a sequence of \"next\" elements\n    next_sequence = rasp.Aggregate(shift_selector, rasp.tokens).named(\"next_sequence\")\n\n    # Handle the last element: set its \"next\" value to itself\n    last_index = rasp.Map(lambda x: len(x) - 1, rasp.tokens).named(\"last_index\")\n    is_last = rasp.Select(rasp.indices, last_index, rasp.Comparison.EQ).named(\"is_last\")\n    next_sequence_fixed = rasp.Aggregate(is_last, rasp.tokens, default=None).named(\"next_sequence_fixed\")\n\n    # Combine the original next_sequence with the fixed last element\n    final_next_sequence = rasp.SequenceMap(\n        lambda x, y: y if y is not None else x,\n        next_sequence,\n        next_sequence_fixed\n    ).named(\"final_next_sequence\")\n\n    # Calculate the difference\n    difference = rasp.SequenceMap(\n        lambda x, y: y - x,\n        rasp.tokens,\n        final_next_sequence\n    ).named(\"difference\")\n\n    return difference",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_difference_to_next() -> rasp.SOp:\n    # Create a selector that selects the next element for each position\n    next_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y - 1).named(\"next_selector\")\n\n    # Use Aggregate to shift the sequence one position to the left, with a default of 0\n    shifted_sequence = rasp.Aggregate(next_selector, rasp.tokens).named(\"shifted_sequence\")\n\n    # Use SequenceMap to subtract the original sequence from the shifted sequence\n    difference_sequence = rasp.SequenceMap(lambda x, y: x - y, shifted_sequence, rasp.tokens).named(\"difference_sequence\")\n\n    return difference_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, -5.0, 6.0, 1.0, -4.0, 1.0]. (1.0 error rate)"
            }
        ],
        "make_invert_if_sorted": [
            {
                "generated rasp code": "def make_invert_if_sorted() -> rasp.SOp:\n    # Create a selector that compares each element with the next element\n    adjacent_leq = rasp.Select(rasp.tokens, rasp.tokens[1:], rasp.Comparison.LEQ).named(\"adjacent_leq\")\n\n    # Count the number of adjacent pairs that satisfy LEQ\n    sorted_count = rasp.SelectorWidth(adjacent_leq).named(\"sorted_count\")\n\n    # Check if the sequence is sorted by comparing sorted_count with indices\n    is_sorted = rasp.SequenceMap(lambda count, idx: count == idx, sorted_count, rasp.indices).named(\"is_sorted\")\n\n    # Create a reverse selector\n    reverse_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: -x, rasp.indices), rasp.Comparison.EQ).named(\"reverse_selector\")\n\n    # Invert the sequence if sorted, otherwise return the original sequence\n    result = rasp.SequenceMap(\n        lambda sorted_flag, inverted: inverted if sorted_flag else rasp.tokens,\n        is_sorted,\n        rasp.Aggregate(reverse_selector, rasp.tokens)\n    ).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": "'TokensType' object is not subscriptable"
            },
            {
                "generated rasp code": "def make_invert_if_sorted() -> rasp.SOp:\n    # Selector that compares each element with the next element\n    adjacent_leq = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LEQ) & rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.LT)\n    adjacent_leq = adjacent_leq.named(\"adjacent_leq\")\n\n    # Count the number of adjacent pairs that satisfy the LEQ condition\n    sorted_count = rasp.SelectorWidth(adjacent_leq).named(\"sorted_count\")\n\n    # Create a sequence of length minus 1 for comparison\n    length_minus_one = rasp.Map(lambda x: len(x) - 1, rasp.tokens).named(\"length_minus_one\")\n\n    # Check if the sequence is sorted (count equals length minus 1)\n    is_sorted = rasp.SequenceMap(lambda x, y: x == y, sorted_count, length_minus_one).named(\"is_sorted\")\n\n    # Create a reverse mapping using indices\n    reverse_indices = rasp.Map(lambda x: len(x) - 1 - x, rasp.indices).named(\"reverse_indices\")\n\n    # Selector for reversing or keeping the sequence as is\n    reverse_selector = rasp.Select(reverse_indices, rasp.indices, rasp.Comparison.EQ).named(\"reverse_selector\")\n\n    # Combine the is_sorted condition with the reverse_selector\n    final_selector = rasp.SequenceMap(lambda x, y: x and y, is_sorted, reverse_selector).named(\"final_selector\")\n\n    # Use Aggregate to reverse the sequence if sorted, or keep it unchanged\n    result = rasp.Aggregate(final_selector, rasp.tokens).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_invert_if_sorted() -> rasp.SOp:\n    # Selector that checks if each element is less than or equal to the next element\n    ascending_selector = rasp.Select(rasp.tokens, rasp.SequenceMap(lambda x, y: y, rasp.tokens, rasp.indices), rasp.Comparison.LEQ).named(\"ascending_selector\")\n\n    # Count how many times the ascending condition is true\n    ascending_count = rasp.SelectorWidth(ascending_selector).named(\"ascending_count\")\n\n    # Create a sequence of length - 1 for each element\n    seq_length_minus_one = rasp.Map(lambda x: len(x) - 1, rasp.tokens).named(\"seq_length_minus_one\")\n\n    # Check if the sequence is sorted (ascending count equals length - 1)\n    is_sorted = rasp.Select(ascending_count, seq_length_minus_one, rasp.Comparison.EQ).named(\"is_sorted\")\n\n    # Create a selector for reversing the sequence\n    reverse_selector = rasp.Select(rasp.Map(lambda x: len(x) - 1 - x, rasp.indices), rasp.indices, rasp.Comparison.EQ).named(\"reverse_selector\")\n\n    # Use Aggregate to either return the reversed sequence or the original sequence\n    result = rasp.Aggregate(\n        rasp.Select(is_sorted, reverse_selector, lambda x, y: x and y),\n        rasp.tokens\n    ).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_invert_if_sorted() -> rasp.SOp:\n    # Create a selector that compares each element with the next\n    compare_next = rasp.Select(rasp.tokens, rasp.Map(lambda x: x[1:] + [None], rasp.tokens), rasp.Comparison.LEQ).named(\"compare_next\")\n    \n    # Count the number of True comparisons\n    sorted_count = rasp.SelectorWidth(compare_next).named(\"sorted_count\")\n    \n    # Create a sequence of the expected count for a sorted sequence (length - 1)\n    expected_count = rasp.Map(lambda x: len(x) - 1, rasp.tokens).named(\"expected_count\")\n    \n    # Check if the actual count matches the expected count\n    is_sorted = rasp.Select(sorted_count, expected_count, rasp.Comparison.EQ).named(\"is_sorted\")\n    \n    # Create inverted indices\n    inverted_indices = rasp.SequenceMap(\n        lambda x, y: y - x - 1,\n        rasp.indices,\n        rasp.Map(lambda x: len(x) - 1, rasp.tokens)\n    ).named(\"inverted_indices\")\n    \n    # Use the inverted indices to create an inverted sequence\n    inverted_sequence = rasp.Aggregate(\n        rasp.Select(inverted_indices, rasp.indices, rasp.Comparison.EQ),\n        rasp.tokens\n    ).named(\"inverted_sequence\")\n    \n    # Choose between the original and inverted sequence based on whether it's sorted\n    result = rasp.Aggregate(is_sorted, inverted_sequence, default=None).named(\"result\")\n    \n    return rasp.SequenceMap(\n        lambda x, y: y if y is not None else x,\n        rasp.tokens,\n        result\n    ).named(\"invert_if_sorted\")",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_invert_if_sorted() -> rasp.SOp:\n    # Selector that compares each element with the next element\n    ascending_selector = rasp.Select(rasp.tokens, rasp.tokens.shift(1), rasp.Comparison.LEQ).named(\"ascending_selector\")\n\n    # Count the number of adjacent pairs in ascending order\n    ascending_count = rasp.SelectorWidth(ascending_selector).named(\"ascending_count\")\n\n    # Create a Map to get the sequence length minus 1 for each element\n    sequence_length_minus_one = rasp.Map(lambda x: len(x) - 1, rasp.tokens).named(\"sequence_length_minus_one\")\n\n    # Selector that checks if the sequence is sorted (ascending_count equals sequence_length_minus_one)\n    is_sorted_selector = rasp.Select(ascending_count, sequence_length_minus_one, rasp.Comparison.EQ).named(\"is_sorted_selector\")\n\n    # Create a reverse selector if the sequence is sorted\n    reverse_selector = rasp.Select(\n        rasp.Map(lambda x: len(x) - 1 - x, rasp.indices),\n        rasp.indices,\n        rasp.Comparison.EQ\n    ).named(\"reverse_selector\")\n\n    # Combine the is_sorted_selector and reverse_selector\n    final_selector = (is_sorted_selector & reverse_selector) | (~is_sorted_selector & rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.EQ))\n\n    # Use Aggregate to apply the final_selector\n    result = rasp.Aggregate(final_selector, rasp.tokens).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": "'TokensType' object has no attribute 'shift'"
            }
        ],
        "make_logarithm": [
            {
                "generated rasp code": "def make_logarithm() -> rasp.SOp:\n    def custom_log10(x):\n        # Custom implementation of log base 10\n        if x <= 0:\n            return None\n        n = 0\n        while x >= 10:\n            n += 1\n            x /= 10\n        # Approximation for the fractional part\n        frac = 0\n        for _ in range(10):  # Increase for better precision\n            if x >= 1:\n                break\n            x *= 10\n            frac -= 1\n        return n + frac\n\n    # Apply the custom logarithm function to each element\n    return rasp.Map(custom_log10, rasp.tokens).named(\"logarithm\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0, 0, 0, 0, 0, 0]. (0.988 error rate)"
            },
            {
                "generated rasp code": "import math\n\ndef make_logarithm() -> rasp.SOp:\n    # Use Map to apply logarithm base 10 to each element\n    return rasp.Map(\n        lambda x: math.log10(x) if x > 0 else float('-inf'),\n        rasp.tokens\n    ).named(\"logarithm_base_10\")",
                "failure stage": 4,
                "error": "ground truth: ['BOS', 0.9030899869919434, 0.9030899869919434, 0.9542425094393249, 0.9542425094393249, 0.0] model output: ['BOS', 0.9030899869919435, 0.9030899869919435, 0.9542425094393249, 0.9542425094393249, 0.0] for [8, 8, 9, 9, 1]"
            },
            {
                "generated rasp code": "import math\n\ndef make_logarithm() -> rasp.SOp:\n    def safe_log10(x):\n        try:\n            return math.log10(x)\n        except (ValueError, TypeError):\n            return None  # Return None for non-positive or non-numeric values\n\n    # Apply logarithm base 10 to each element\n    return rasp.Map(safe_log10, rasp.tokens).named(\"logarithm\")",
                "failure stage": 4,
                "error": "ground truth: ['BOS', 0.9030899869919434, 0.9030899869919434, 0.9542425094393249, 0.9542425094393249, 0.0] model output: ['BOS', 0.9030899869919435, 0.9030899869919435, 0.9542425094393249, 0.9542425094393249, 0.0] for [8, 8, 9, 9, 1]"
            },
            {
                "generated rasp code": "import math\n\ndef make_logarithm() -> rasp.SOp:\n    # Apply logarithm base 10 to each element of the input sequence\n    return rasp.Map(\n        lambda x: math.log10(x) if x > 0 else None,\n        rasp.tokens\n    ).named(\"logarithm_base_10\")",
                "failure stage": 4,
                "error": "ground truth: ['BOS', 0.9030899869919434, 0.9030899869919434, 0.9542425094393249, 0.9542425094393249, 0.0] model output: ['BOS', 0.9030899869919435, 0.9030899869919435, 0.9542425094393249, 0.9542425094393249, 0.0] for [8, 8, 9, 9, 1]"
            },
            {
                "generated rasp code": "import math\n\ndef make_logarithm() -> rasp.SOp:\n    # Define a function to safely compute log10, returning None for non-positive numbers\n    def safe_log10(x):\n        return math.log10(x) if x > 0 else None\n    \n    # Use Map to apply the safe_log10 function to each element of the input sequence\n    return rasp.Map(lambda x: safe_log10(x), rasp.tokens).named(\"logarithm\")",
                "failure stage": 4,
                "error": "ground truth: ['BOS', 0.9030899869919434, 0.9030899869919434, 0.9542425094393249, 0.9542425094393249, 0.0] model output: ['BOS', 0.9030899869919435, 0.9030899869919435, 0.9542425094393249, 0.9542425094393249, 0.0] for [8, 8, 9, 9, 1]"
            }
        ],
        "make_product_with_next": [
            {
                "generated rasp code": "def make_product_with_next() -> rasp.SOp:\n    # Create a selector that selects the next element for each position,\n    # except for the last element where it selects itself\n    next_selector = rasp.Select(\n        rasp.indices,\n        rasp.indices,\n        lambda x, y: (x == y - 1) or (x == y and x == len(y) - 1)\n    ).named(\"next_selector\")\n\n    # Use Aggregate to shift the sequence by one position\n    shifted_sequence = rasp.Aggregate(next_selector, rasp.tokens).named(\"shifted_sequence\")\n\n    # Multiply the original sequence with the shifted sequence\n    product_sequence = rasp.SequenceMap(\n        lambda x, y: x * y,\n        rasp.tokens,\n        shifted_sequence\n    ).named(\"product_sequence\")\n\n    return product_sequence",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_product_with_next() -> rasp.SOp:\n    # Create a selector that selects the next element for each position\n    next_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y - 1).named(\"next_selector\")\n    \n    # Use Aggregate to shift the sequence by one position, with the last element repeating\n    shifted_sequence = rasp.Aggregate(next_selector, rasp.tokens).named(\"shifted_sequence\")\n    \n    # Use SequenceMap to multiply each element with its corresponding shifted element\n    product_sequence = rasp.SequenceMap(lambda x, y: x * y, rasp.tokens, shifted_sequence).named(\"product_sequence\")\n    \n    return product_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, 24.0, 16.0, 2.0, 5.0, 20.0]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_product_with_next() -> rasp.SOp:\n    # Create a selector that selects the next element (or current for the last position)\n    next_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: x + 1, rasp.indices),\n        rasp.Comparison.LEQ\n    ).named(\"next_selector\")\n\n    # Shift the sequence by one position (last element repeats)\n    shifted_sequence = rasp.Aggregate(next_selector, rasp.tokens).named(\"shifted_sequence\")\n\n    # Multiply each element with its corresponding shifted element\n    product_sequence = rasp.SequenceMap(\n        lambda x, y: x * y,\n        rasp.tokens,\n        shifted_sequence\n    ).named(\"product_sequence\")\n\n    return product_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [16.5, 34.666666666666664, 7.0, 3.8, 19.166666666666668, 15.333333333333334]. (0.898 error rate)"
            },
            {
                "generated rasp code": "def make_product_with_next() -> rasp.SOp:\n    # Create a selector that selects the next element for each position\n    # (and the current element for the last position)\n    next_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: x + 1, rasp.indices),\n        rasp.Comparison.LEQ\n    ).named(\"next_selector\")\n\n    # Use Aggregate to shift the sequence by one position\n    # (with the last element repeating)\n    shifted_sequence = rasp.Aggregate(next_selector, rasp.tokens).named(\"shifted_sequence\")\n\n    # Multiply each element with its corresponding shifted element\n    product_sequence = rasp.SequenceMap(\n        lambda x, y: x * y,\n        rasp.tokens,\n        shifted_sequence\n    ).named(\"product_sequence\")\n\n    return product_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [16.5, 34.666666666666664, 7.0, 3.8, 19.166666666666668, 15.333333333333334]. (0.898 error rate)"
            },
            {
                "generated rasp code": "def make_product_with_next() -> rasp.SOp:\n    # Create a selector that selects the next element for each position\n    next_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y - 1).named(\"next_selector\")\n\n    # Use Aggregate to shift the sequence by one position\n    # The default parameter ensures the last element is replaced by itself\n    shifted_sequence = rasp.Aggregate(next_selector, rasp.tokens, default=None).named(\"shifted_sequence\")\n\n    # Combine the original sequence with the shifted sequence using SequenceMap\n    # If shifted_sequence is None (for the last element), use the original value\n    result = rasp.SequenceMap(\n        lambda x, y: x * (y if y is not None else x),\n        rasp.tokens,\n        shifted_sequence\n    ).named(\"product_with_next\")\n\n    return result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, 24.0, 16.0, 2.0, 5.0, 20.0]. (1.0 error rate)"
            }
        ],
        "make_check_multiple_of_first": [
            {
                "generated rasp code": "def make_check_multiple_of_first() -> rasp.SOp:\n    # Select the first element\n    first_element_selector = rasp.Select(rasp.indices, rasp.tokens, lambda i, x: i == 0).named(\"first_element_selector\")\n    \n    # Extract the first element\n    first_element = rasp.Aggregate(first_element_selector, rasp.tokens).named(\"first_element\")\n    \n    # Perform element-wise division\n    division_result = rasp.SequenceMap(\n        lambda x, y: x / y if y != 0 else None,\n        rasp.tokens,\n        first_element\n    ).named(\"division_result\")\n    \n    # Check if each element is a multiple of the first element\n    is_multiple = rasp.Map(\n        lambda x: 1 if (x is not None and x.is_integer()) else 0,\n        division_result\n    ).named(\"is_multiple\")\n    \n    return is_multiple",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [1, 0, 0, 0, 0, 0]. (0.104 error rate)"
            },
            {
                "generated rasp code": "def make_check_multiple_of_first() -> rasp.SOp:\n    # Select the first element\n    first_element_selector = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.EQ).named(\"first_element_selector\")\n    \n    # Extract the first element\n    first_element = rasp.Aggregate(first_element_selector, rasp.tokens).named(\"first_element\")\n    \n    # Divide each element by the first element\n    division_result = rasp.SequenceMap(lambda x, y: x / y if y != 0 else None, rasp.tokens, first_element).named(\"division_result\")\n    \n    # Check if each element is a multiple of the first element\n    # Handle first element, zero division, and integer check\n    def check_multiple(x, i):\n        if i == 0:  # First element\n            return 1\n        elif x is None:  # Division by zero case\n            return 0\n        else:\n            return 1 if x.is_integer() else 0\n    \n    is_multiple = rasp.SequenceMap(check_multiple, division_result, rasp.indices).named(\"is_multiple\")\n    \n    return is_multiple",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [1, 1, 1, 1, 1, 1]. (0.839 error rate)"
            },
            {
                "generated rasp code": "def make_check_multiple_of_first() -> rasp.SOp:\n    # Select the first element\n    first_element_selector = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.EQ).named(\"first_element_selector\")\n    \n    # Extract the first element\n    first_element = rasp.Aggregate(first_element_selector, rasp.tokens).named(\"first_element\")\n    \n    # Check if the first element is zero\n    is_first_zero = rasp.Map(lambda x: x == 0, first_element).named(\"is_first_zero\")\n    \n    # Divide each element by the first element\n    division_result = rasp.SequenceMap(\n        lambda x, y: x / y if y != 0 else None,\n        rasp.tokens,\n        first_element\n    ).named(\"division_result\")\n    \n    # Check if the division result is an integer\n    is_multiple = rasp.Map(\n        lambda x: int(x is not None and x.is_integer()),\n        division_result\n    ).named(\"is_multiple\")\n    \n    # Handle the case where the first element is zero\n    result = rasp.SequenceMap(\n        lambda x, y: 1 if y and x == 0 else (0 if y else x),\n        is_multiple,\n        is_first_zero\n    ).named(\"result\")\n    \n    return result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [1, 1, 1, 1, 1, 1]. (0.839 error rate)"
            }
        ],
        "make_sum_of_last_two": [
            {
                "generated rasp code": "def make_sum_of_last_two() -> rasp.SOp:\n    # Create a selector for the last element\n    last_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: len(x) - 1, rasp.tokens), rasp.Comparison.EQ).named(\"last_selector\")\n    \n    # Create a selector for the second-to-last element\n    second_last_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: len(x) - 2, rasp.tokens), rasp.Comparison.EQ).named(\"second_last_selector\")\n    \n    # Get the last element\n    last_element = rasp.Aggregate(last_selector, rasp.tokens).named(\"last_element\")\n    \n    # Get the second-to-last element\n    second_last_element = rasp.Aggregate(second_last_selector, rasp.tokens).named(\"second_last_element\")\n    \n    # Sum the last two elements\n    sum_last_two = rasp.SequenceMap(lambda x, y: x + y if x is not None and y is not None else None, \n                                    last_element, second_last_element).named(\"sum_last_two\")\n    \n    # Create a sequence of the sequence length\n    seq_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"seq_length\")\n    \n    # Return None if sequence length is 1, otherwise return the sum\n    result = rasp.SequenceMap(lambda length, sum_val: None if length == 1 else sum_val, \n                              seq_length, sum_last_two).named(\"result\")\n    \n    return result",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_sum_of_last_two() -> rasp.SOp:\n    # Selector for the last element\n    last_selector = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.EQ).named(\"last_selector\")\n    \n    # Selector for the second-to-last element\n    second_last_selector = rasp.Select(\n        rasp.Map(lambda x: x - 1, rasp.indices),\n        rasp.indices,\n        rasp.Comparison.EQ\n    ).named(\"second_last_selector\")\n    \n    # Shift the last element to all positions\n    last_element = rasp.Aggregate(last_selector, rasp.tokens).named(\"last_element\")\n    \n    # Shift the second-to-last element to all positions\n    second_last_element = rasp.Aggregate(second_last_selector, rasp.tokens).named(\"second_last_element\")\n    \n    # Sum the last two elements\n    sum_last_two = rasp.SequenceMap(\n        lambda x, y: (x if x is not None else 0) + (y if y is not None else 0),\n        last_element,\n        second_last_element\n    ).named(\"sum_last_two\")\n    \n    # If both last and second-last are None, return None, otherwise return the sum\n    result = rasp.Map(\n        lambda x: None if x == 0 else x,\n        sum_last_two\n    ).named(\"result\")\n    \n    return result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [11.0, 10.0, 3.0, 6.0, 9.0, None]. (0.908 error rate)"
            },
            {
                "generated rasp code": "def make_sum_of_last_two() -> rasp.SOp:\n    # Create a selector for the last two elements\n    last_two_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: len(x) - 2, rasp.tokens),\n        rasp.Comparison.GEQ\n    ).named(\"last_two_selector\")\n\n    # Sum the selected elements\n    sum_last_two = rasp.Aggregate(last_two_selector, rasp.tokens).named(\"sum_last_two\")\n\n    # Create a sequence of the input length\n    seq_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"seq_length\")\n\n    # Combine the sum with a check for sequence length\n    result = rasp.SequenceMap(\n        lambda sum_val, length: sum_val if length > 1 else None,\n        sum_last_two,\n        seq_length\n    ).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_sum_of_last_two() -> rasp.SOp:\n    # Create a selector for the last element\n    last_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: len(x) - 1, rasp.indices), rasp.Comparison.EQ).named(\"last_selector\")\n    \n    # Create a selector for the second-to-last element\n    second_last_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: len(x) - 2, rasp.indices), rasp.Comparison.EQ).named(\"second_last_selector\")\n    \n    # Shift the last element to all positions\n    last_element = rasp.Aggregate(last_selector, rasp.tokens).named(\"last_element\")\n    \n    # Shift the second-to-last element to all positions\n    second_last_element = rasp.Aggregate(second_last_selector, rasp.tokens).named(\"second_last_element\")\n    \n    # Sum the last two elements\n    sum_last_two = rasp.SequenceMap(lambda x, y: (x or 0) + (y or 0), last_element, second_last_element).named(\"sum_last_two\")\n    \n    # Create a sequence of the length of the input\n    seq_length = rasp.Map(lambda x: len(x), rasp.indices).named(\"seq_length\")\n    \n    # Create a selector for sequences with length 1\n    single_element_selector = rasp.Select(seq_length, rasp.Map(lambda x: 1, rasp.indices), rasp.Comparison.EQ).named(\"single_element_selector\")\n    \n    # Return None for all positions if the sequence has only one element, otherwise return the sum\n    result = rasp.Aggregate(single_element_selector, rasp.Map(lambda x: None, rasp.tokens), default=sum_last_two).named(\"result\")\n    \n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_sum_of_last_two() -> rasp.SOp:\n    # Create a selector for the last element\n    last_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: len(x) - 1, rasp.indices), rasp.Comparison.EQ).named(\"last_selector\")\n    \n    # Create a selector for the second to last element\n    second_last_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: len(x) - 2, rasp.indices), rasp.Comparison.EQ).named(\"second_last_selector\")\n    \n    # Shift the last element to all positions\n    last_element = rasp.Aggregate(last_selector, rasp.tokens).named(\"last_element\")\n    \n    # Shift the second to last element to all positions\n    second_last_element = rasp.Aggregate(second_last_selector, rasp.tokens).named(\"second_last_element\")\n    \n    # Sum the last two elements\n    sum_last_two = rasp.SequenceMap(lambda x, y: (x or 0) + (y or 0), last_element, second_last_element).named(\"sum_last_two\")\n    \n    # Count the number of elements in the sequence\n    sequence_length = rasp.SelectorWidth(rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE)).named(\"sequence_length\")\n    \n    # Create a selector for sequences with more than one element\n    more_than_one_selector = rasp.Select(sequence_length, rasp.Map(lambda x: 1, rasp.indices), rasp.Comparison.GT).named(\"more_than_one_selector\")\n    \n    # Return the sum where the sequence has more than one element, and None otherwise\n    result = rasp.Aggregate(more_than_one_selector, sum_last_two).named(\"result\")\n    \n    return result",
                "failure stage": 0,
                "error": "test_run_op timed out"
            }
        ],
        "make_pairwise_sum": [
            {
                "generated rasp code": "def make_pairwise_sum() -> rasp.SOp:\n    # Create a selector that selects the previous element for each position\n    prev_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y - 1).named(\"prev_selector\")\n\n    # Use Aggregate to shift the sequence by one position to the right\n    shifted_sequence = rasp.Aggregate(prev_selector, rasp.tokens).named(\"shifted_sequence\")\n\n    # Use SequenceMap to add the original sequence and the shifted sequence\n    # The lambda function handles the None case for the first element\n    pairwise_sum = rasp.SequenceMap(\n        lambda x, y: x if y is None else x + y,\n        rasp.tokens,\n        shifted_sequence\n    ).named(\"pairwise_sum\")\n\n    return pairwise_sum",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, 11.0, 10.0, 3.0, 6.0, 9.0]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_pairwise_sum() -> rasp.SOp:\n    # Create a selector that selects the previous element for each position\n    prev_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y - 1).named(\"prev_selector\")\n\n    # Shift the sequence one position to the right\n    shifted_seq = rasp.Aggregate(prev_selector, rasp.tokens).named(\"shifted_seq\")\n\n    # Add the original sequence and the shifted sequence\n    # Keep the first element unchanged\n    pairwise_sum = rasp.SequenceMap(\n        lambda x, y: x if y is None else x + y,\n        rasp.tokens,\n        shifted_seq\n    ).named(\"pairwise_sum\")\n\n    return pairwise_sum",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, 11.0, 10.0, 3.0, 6.0, 9.0]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_pairwise_sum() -> rasp.SOp:\n    # Create a selector that selects the previous element for each position\n    prev_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y - 1).named(\"prev_selector\")\n\n    # Use Aggregate to shift the sequence by one position to the right\n    shifted_sequence = rasp.Aggregate(prev_selector, rasp.tokens).named(\"shifted_sequence\")\n\n    # Use SequenceMap to add the original sequence with the shifted sequence\n    # Handle the None value for the first element\n    def add_with_none(x, y):\n        if y is None:\n            return x\n        return x + y\n\n    pairwise_sum = rasp.SequenceMap(add_with_none, rasp.tokens, shifted_sequence).named(\"pairwise_sum\")\n\n    return pairwise_sum",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, 11.0, 10.0, 3.0, 6.0, 9.0]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_pairwise_sum() -> rasp.SOp:\n    # Create a selector that selects the previous element for each position\n    previous_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y - 1).named(\"previous_selector\")\n\n    # Shift the sequence to the right, with None as the first element\n    shifted_sequence = rasp.Aggregate(previous_selector, rasp.tokens).named(\"shifted_sequence\")\n\n    # Add the original sequence and the shifted sequence\n    # For the first element, we use the original value (y if x is None)\n    # For other elements, we add x and y\n    pairwise_sum = rasp.SequenceMap(\n        lambda x, y: y if x is None else x + y,\n        shifted_sequence,\n        rasp.tokens\n    ).named(\"pairwise_sum\")\n\n    return pairwise_sum",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, 11.0, 10.0, 3.0, 6.0, 9.0]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_pairwise_sum() -> rasp.SOp:\n    # Create a selector that selects the previous element for each position\n    prev_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y - 1).named(\"prev_selector\")\n\n    # Shift the sequence by one position to the right\n    shifted_sequence = rasp.Aggregate(prev_selector, rasp.tokens).named(\"shifted_sequence\")\n\n    # Add the original sequence and the shifted sequence\n    pairwise_sum = rasp.SequenceMap(\n        lambda x, y: x if y is None else x + y,\n        rasp.tokens,\n        shifted_sequence\n    ).named(\"pairwise_sum\")\n\n    return pairwise_sum",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, 11.0, 10.0, 3.0, 6.0, 9.0]. (1.0 error rate)"
            }
        ],
        "make_polynomial": [
            {
                "generated rasp code": "def make_polynomial() -> rasp.SOp:\n    # Selector to separate x (first element) from coefficients (rest of the sequence)\n    x_selector = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.EQ).named(\"x_selector\")\n    \n    # Extract x value\n    x = rasp.Aggregate(x_selector, rasp.tokens).named(\"x\")\n    \n    # Create powers of x (x^0, x^1, x^2, ...)\n    def power(i, x):\n        return 1 if i == 0 else x ** i\n    powers_of_x = rasp.SequenceMap(power, rasp.indices, x).named(\"powers_of_x\")\n    \n    # Multiply powers of x with coefficients\n    products = rasp.SequenceMap(lambda a, b: a * b, powers_of_x, rasp.tokens).named(\"products\")\n    \n    # Accumulate the sum using a series of SequenceMap operations\n    def accumulate(acc, val):\n        return acc + val if val is not None else acc\n    \n    polynomial_sum = rasp.Map(lambda x: 0, rasp.tokens).named(\"initial_sum\")\n    for _ in range(len(rasp.tokens)):  # This creates a fixed number of accumulation steps\n        polynomial_sum = rasp.SequenceMap(accumulate, polynomial_sum, products).named(\"polynomial_sum\")\n    \n    return polynomial_sum",
                "failure stage": 0,
                "error": "object of type 'TokensType' has no len()"
            },
            {
                "generated rasp code": "def make_polynomial():\n    # Extract x (first element)\n    x_selector = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.EQ).named(\"x_selector\")\n    x = rasp.Aggregate(x_selector, rasp.tokens).named(\"x\")\n\n    # Extract coefficients (all elements except the first)\n    coeff_selector = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.GT).named(\"coeff_selector\")\n    coefficients = rasp.Aggregate(coeff_selector, rasp.tokens).named(\"coefficients\")\n\n    # Create sequence of powers: [1, x, x^2, x^3, ...]\n    def power(i, x_val):\n        return 1 if i == 0 else x_val ** i\n    powers = rasp.SequenceMap(power, rasp.indices, x).named(\"powers\")\n\n    # Multiply powers with coefficients\n    terms = rasp.SequenceMap(lambda p, c: p * c if c is not None else 0, powers, coefficients).named(\"terms\")\n\n    # Cumulative sum of terms\n    def cumsum(acc, val):\n        return acc + val if acc is not None else val\n    result = rasp.SequenceMap(cumsum, terms, terms).named(\"result\")\n    for _ in range(len(rasp.tokens) - 2):  # -2 because we've already done one addition and we don't need to add the x term\n        result = rasp.SequenceMap(cumsum, result, result).named(\"result\")\n\n    # Broadcast the final result\n    final_selector = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.EQ).named(\"final_selector\")\n    final_result = rasp.Aggregate(final_selector, result).named(\"final_result\")\n\n    return final_result",
                "failure stage": 0,
                "error": "object of type 'TokensType' has no len()"
            },
            {
                "generated rasp code": "def make_polynomial(max_degree=10):\n    # Extract x (first element)\n    x_selector = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.EQ).named(\"x_selector\")\n    x = rasp.Aggregate(x_selector, rasp.tokens).named(\"x\")\n\n    # Create powers of x: [1, x, x^2, ..., x^max_degree]\n    def power(i, x):\n        return x ** i if i > 0 else 1\n    powers = rasp.SequenceMap(power, rasp.indices, x).named(\"powers\")\n\n    # Create coefficient sequence, padding with zeros\n    coeff_selector = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.GT).named(\"coeff_selector\")\n    coefficients = rasp.Aggregate(coeff_selector, rasp.tokens, default=0).named(\"coefficients\")\n\n    # Multiply powers with coefficients\n    terms = rasp.SequenceMap(lambda p, c: p * c, powers, coefficients).named(\"terms\")\n\n    # Sum up the terms\n    sum_selector = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.LT).named(\"sum_selector\")\n    polynomial_sum = rasp.Aggregate(sum_selector, terms, default=0).named(\"polynomial_sum\")\n\n    # Broadcast the result\n    result = rasp.Map(lambda _: polynomial_sum, rasp.tokens).named(\"result\")\n\n    return result",
                "failure stage": 3,
                "error": "unhashable type: 'Aggregate'"
            },
            {
                "generated rasp code": "def make_polynomial():\n    # Select the first element (x)\n    x_selector = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.EQ).named(\"x_selector\")\n    x = rasp.Aggregate(x_selector, rasp.tokens).named(\"x\")\n\n    # Select all elements except the first (coefficients)\n    coeff_selector = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.GT).named(\"coeff_selector\")\n    coefficients = rasp.Aggregate(coeff_selector, rasp.tokens, default=0).named(\"coefficients\")\n\n    # Create sequence of powers of x: [1, x, x^2, ...]\n    def power_sequence(t):\n        return 1 if t == 0 else x(t) ** t\n    powers = rasp.Map(power_sequence, rasp.indices).named(\"powers\")\n\n    # Multiply powers with coefficients\n    products = rasp.SequenceMap(lambda p, c: p * c, powers, coefficients).named(\"products\")\n\n    # Sum up the products\n    sum_selector = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.TRUE).named(\"sum_selector\")\n    result = rasp.Aggregate(sum_selector, products).named(\"result\")\n\n    # Handle the case where input is just x (no coefficients)\n    is_single_element = rasp.Select(\n        rasp.Map(lambda t: len(t), rasp.tokens),\n        rasp.Map(lambda _: 1, rasp.tokens),\n        rasp.Comparison.EQ\n    ).named(\"is_single_element\")\n\n    # Final result: if single element, return x; otherwise, return the polynomial evaluation\n    final_result = rasp.Aggregate(is_single_element, x, default=result).named(\"final_result\")\n\n    return final_result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_polynomial(max_degree=10):\n    def get_x(tokens):\n        return rasp.Aggregate(rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.EQ), tokens)\n\n    def get_coefficients(tokens):\n        return rasp.Aggregate(rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.GT), tokens, default=0)\n\n    def powers_of_x(x):\n        return rasp.Map(lambda i: x ** i if i > 0 else 1, rasp.indices)\n\n    x = get_x(rasp.tokens).named(\"x\")\n    coefficients = get_coefficients(rasp.tokens).named(\"coefficients\")\n    x_powers = powers_of_x(x).named(\"x_powers\")\n\n    terms = rasp.SequenceMap(lambda coeff, power: coeff * power, coefficients, x_powers).named(\"terms\")\n\n    sum_selector = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.LT)\n    polynomial_value = rasp.Aggregate(sum_selector, terms, default=0).named(\"polynomial_value\")\n\n    return rasp.Map(lambda _: polynomial_value, rasp.tokens).named(\"polynomial_result\")",
                "failure stage": 3,
                "error": "unhashable type: 'Aggregate'"
            }
        ],
        "make_flip_halves": [
            {
                "generated rasp code": "def make_flip_halves() -> rasp.SOp:\n    # Get the length of the sequence\n    length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"length\")\n    \n    # Calculate the midpoint (rounded down for odd lengths)\n    midpoint = rasp.Map(lambda x: x // 2, length).named(\"midpoint\")\n    \n    # Create a selector for the first half\n    first_half_selector = rasp.Select(rasp.indices, midpoint, rasp.Comparison.LT).named(\"first_half_selector\")\n    \n    # Create a selector for the second half\n    second_half_selector = rasp.Select(rasp.indices, midpoint, rasp.Comparison.GEQ).named(\"second_half_selector\")\n    \n    # Create a selector for the new positions of the second half\n    new_second_half_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: x - x // 2, length), rasp.Comparison.LT).named(\"new_second_half_selector\")\n    \n    # Create a selector for the new positions of the first half\n    new_first_half_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: x - x // 2, length), rasp.Comparison.GEQ).named(\"new_first_half_selector\")\n    \n    # Combine selectors to create the flipped sequence\n    flipped_sequence = rasp.Aggregate(\n        new_second_half_selector & second_half_selector |\n        new_first_half_selector & first_half_selector,\n        rasp.tokens\n    ).named(\"flipped_sequence\")\n    \n    return flipped_sequence",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_flip_halves() -> rasp.SOp:\n    # Calculate the midpoint of the sequence\n    sequence_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"sequence_length\")\n    midpoint = rasp.Map(lambda x: (x + 1) // 2, sequence_length).named(\"midpoint\")\n    \n    # Create selectors for the first and second halves\n    first_half_selector = rasp.Select(rasp.indices, midpoint, rasp.Comparison.LT).named(\"first_half_selector\")\n    second_half_selector = rasp.Select(rasp.indices, midpoint, rasp.Comparison.GEQ).named(\"second_half_selector\")\n    \n    # Create new indices for the flipped sequence\n    new_indices = rasp.SequenceMap(\n        lambda i, m: i + m if i < m else i - m,\n        rasp.indices,\n        midpoint\n    ).named(\"new_indices\")\n    \n    # Create a selector for the new order\n    new_order_selector = rasp.Select(new_indices, rasp.indices, rasp.Comparison.EQ).named(\"new_order_selector\")\n    \n    # Use Aggregate to reorder the sequence\n    flipped_sequence = rasp.Aggregate(new_order_selector, rasp.tokens).named(\"flipped_sequence\")\n    \n    return flipped_sequence",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_flip_halves() -> rasp.SOp:\n    # Calculate the length of the sequence\n    length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"length\")\n    \n    # Calculate the midpoint (rounded down)\n    midpoint = rasp.Map(lambda x: x // 2, length).named(\"midpoint\")\n    \n    # Create selectors for the first and second halves\n    first_half_selector = rasp.Select(\n        rasp.indices,\n        midpoint,\n        rasp.Comparison.LT\n    ).named(\"first_half_selector\")\n    \n    second_half_selector = rasp.Select(\n        rasp.indices,\n        rasp.SequenceMap(lambda i, m: i >= m + (1 if i % 2 == 1 else 0), rasp.indices, midpoint),\n        rasp.Comparison.EQ\n    ).named(\"second_half_selector\")\n    \n    # Move the second half to the beginning\n    first_part = rasp.Aggregate(second_half_selector, rasp.tokens).named(\"first_part\")\n    \n    # Keep the middle element in place for odd-length sequences\n    middle_selector = rasp.Select(\n        rasp.indices,\n        rasp.SequenceMap(lambda i, m: i == m, rasp.indices, midpoint),\n        rasp.Comparison.EQ\n    ).named(\"middle_selector\")\n    middle_part = rasp.Aggregate(middle_selector, rasp.tokens).named(\"middle_part\")\n    \n    # Move the first half to the end\n    last_part = rasp.Aggregate(first_half_selector, rasp.tokens).named(\"last_part\")\n    \n    # Combine the parts\n    result = rasp.SequenceMap(\n        lambda f, m, l: f if f is not None else (m if m is not None else l),\n        first_part,\n        rasp.SequenceMap(lambda m, l: m if m is not None else l, middle_part, last_part)\n    ).named(\"result\")\n    \n    return result",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_flip_halves() -> rasp.SOp:\n    # Create a sequence of the indices\n    indices = rasp.indices\n\n    # Create a sequence of the sequence length\n    length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"length\")\n\n    # Create a sequence of half the length (floored)\n    half_length = rasp.Map(lambda x: x // 2, length).named(\"half_length\")\n\n    # Selector for the first half\n    first_half_selector = rasp.Select(indices, half_length, rasp.Comparison.LT).named(\"first_half_selector\")\n\n    # Selector for the second half (including middle element if odd)\n    second_half_selector = rasp.Select(indices, half_length, rasp.Comparison.GEQ).named(\"second_half_selector\")\n\n    # Create a sequence of reversed indices\n    reversed_indices = rasp.Map(lambda x: len(x) - 1 - x, indices).named(\"reversed_indices\")\n\n    # Move second half to first half positions\n    first_half_result = rasp.Aggregate(first_half_selector, rasp.Aggregate(second_half_selector, rasp.tokens)).named(\"first_half_result\")\n\n    # Move first half to second half positions\n    second_half_result = rasp.Aggregate(second_half_selector, rasp.Aggregate(first_half_selector, rasp.tokens)).named(\"second_half_result\")\n\n    # Combine the results\n    result = rasp.SequenceMap(\n        lambda x, y: x if x is not None else y,\n        first_half_result,\n        second_half_result\n    ).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_flip_halves() -> rasp.SOp:\n    # Get the length of the sequence\n    length = rasp.SelectorWidth(rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE)).named(\"length\")\n    \n    # Calculate the midpoint (rounded up for odd lengths)\n    midpoint = rasp.Map(lambda x: (x + 1) // 2, length).named(\"midpoint\")\n    \n    # Create a selector for the first half\n    first_half_selector = rasp.Select(rasp.indices, midpoint, rasp.Comparison.LT).named(\"first_half_selector\")\n    \n    # Create a selector for the second half (including the middle element for odd lengths)\n    second_half_selector = rasp.Select(rasp.indices, midpoint, rasp.Comparison.GEQ).named(\"second_half_selector\")\n    \n    # Create a sequence of reversed indices\n    reversed_indices = rasp.Map(lambda x: x - 1, length).named(\"reversed_indices\")\n    \n    # Create a selector to place the second half at the beginning\n    second_half_first_selector = rasp.Select(rasp.indices, midpoint, rasp.Comparison.LT).named(\"second_half_first_selector\")\n    \n    # Create a selector to place the first half at the end\n    first_half_last_selector = rasp.Select(rasp.indices, midpoint, rasp.Comparison.GEQ).named(\"first_half_last_selector\")\n    \n    # Aggregate to create the flipped sequence\n    flipped_sequence = rasp.Aggregate(\n        second_half_first_selector,\n        rasp.Aggregate(second_half_selector, rasp.tokens)\n    ).named(\"second_half\")\n    \n    flipped_sequence = rasp.Aggregate(\n        first_half_last_selector,\n        rasp.Aggregate(first_half_selector, rasp.tokens),\n        default=flipped_sequence\n    ).named(\"flipped_sequence\")\n    \n    return flipped_sequence",
                "failure stage": 0,
                "error": ""
            }
        ],
        "make_arcsine": [
            {
                "generated rasp code": "def make_arcsine() -> rasp.SOp:\n    def arcsine_approx(x):\n        # Taylor series approximation of arcsine\n        if x < -1 or x > 1:\n            return float('nan')  # arcsine is undefined outside [-1, 1]\n        \n        result = x\n        term = x\n        x_squared = x * x\n        for n in range(1, 15):  # 15 terms for better accuracy\n            term *= x_squared * (2*n - 1)**2 / ((2*n) * (2*n + 1))\n            result += term / (2*n + 1)\n        \n        return result\n\n    return rasp.Map(lambda x: arcsine_approx(x), rasp.tokens).named(\"arcsine\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [nan, nan, nan, 1.0871674735059336, nan, nan]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_arcsine() -> rasp.SOp:\n    def arcsine_approx(x):\n        # Simple polynomial approximation of arcsine\n        # Valid for x in [-1, 1]\n        if x < -1 or x > 1:\n            return float('nan')  # Return NaN for values outside [-1, 1]\n        return x + (x**3)/6 + (3*x**5)/40 + (5*x**7)/112 + (35*x**9)/1152\n\n    return rasp.Map(lambda x: arcsine_approx(x), rasp.tokens).named(\"arcsine\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [nan, nan, nan, 1.3166914682539683, nan, nan]. (0.972 error rate)"
            },
            {
                "generated rasp code": "import math\n\ndef make_arcsine() -> rasp.SOp:\n    # Apply arcsine function to each element of the input sequence\n    return rasp.Map(\n        lambda x: math.asin(x) / math.pi * 2 if -1 <= x <= 1 else None,\n        rasp.tokens\n    ).named(\"arcsine\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, None, None, 1.0, None, None]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_arcsine() -> rasp.SOp:\n    def arcsine_approx(x):\n        # Clamp x to [-1, 1]\n        x = max(-1, min(1, x))\n        \n        # Taylor series approximation of arcsine\n        result = x\n        term = x\n        x_squared = x * x\n        for n in range(1, 10):  # Using 10 terms for approximation\n            term *= x_squared * (2*n - 1) * (2*n - 1) / ((2*n) * (2*n + 1))\n            result += term\n        \n        # Convert to multiples of \u03c0\n        pi = 3.14159265359\n        return result / (pi/2)\n\n    return rasp.Map(arcsine_approx, rasp.tokens).named(\"arcsine\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0.8859803287055396, 0.8859803287055396, 0.8859803287055396, 0.8859803287055396, 0.8859803287055396, 0.8859803287055396]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_arcsine():\n    def arcsine_approx(x):\n        # Handle edge cases\n        if x == 1:\n            return 1.5707963267948966  # \u03c0/2\n        elif x == -1:\n            return -1.5707963267948966  # -\u03c0/2\n        \n        # Series expansion for arcsine\n        x2 = x * x\n        x3 = x2 * x\n        x5 = x3 * x2\n        x7 = x5 * x2\n        x9 = x7 * x2\n        x11 = x9 * x2\n        \n        return (x + (1/6)*x3 + (3/40)*x5 + (5/112)*x7 +\n                (35/1152)*x9 + (63/2816)*x11)\n\n    return rasp.Map(lambda x: arcsine_approx(max(min(x, 1), -1)), rasp.tokens).named(\"arcsine\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [1.5707963267948966, 1.5707963267948966, 1.5707963267948966, 1.5707963267948966, 1.5707963267948966, 1.5707963267948966]. (0.964 error rate)"
            }
        ],
        "make_check_divisibility": [],
        "make_arccosine": [
            {
                "generated rasp code": "def make_arccosine() -> rasp.SOp:\n    def arccosine_approx(x):\n        # Clamp x to [-1, 1]\n        x = max(-1, min(1, x))\n        \n        # Polynomial approximation of arccosine\n        # This is a simple approximation and may not be very accurate\n        # acos(x) \u2248 \u03c0/2 - x - x^3/6 for x in [-1, 1]\n        pi = 3.14159265358979323846\n        return pi/2 - x - (x**3)/6\n\n    return rasp.Map(arccosine_approx, rasp.tokens).named(\"arccosine\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0.40412966012822993, 0.40412966012822993, 0.40412966012822993, 0.40412966012822993, 0.40412966012822993, 0.40412966012822993]. (0.999 error rate)"
            },
            {
                "generated rasp code": "import math\n\ndef make_arccosine() -> rasp.SOp:\n    # Apply arccosine function to each element of the input sequence\n    return rasp.Map(\n        lambda x: math.acos(x) if -1 <= x <= 1 else None,\n        rasp.tokens\n    ).named(\"arccosine\")",
                "failure stage": 4,
                "error": "('Inputs {0.723102771013545, 0.5020895776770055} not found in encoding ', dict_keys([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 'BOS', 'compiler_pad']))"
            },
            {
                "generated rasp code": "def make_arccosine() -> rasp.SOp:\n    def arccosine_approx(x):\n        if x < -1 or x > 1:\n            return None\n        if x == 1:\n            return 0\n        if x == -1:\n            return 3.141592653589793  # Approximation of \u03c0\n        \n        # Simple approximation of arccosine using Taylor series\n        # arccos(x) \u2248 \u03c0/2 - x - x^3/6 - 3x^5/40 - 5x^7/112\n        pi_2 = 1.5707963267948966  # \u03c0/2\n        return pi_2 - x - (x**3)/6 - (3*x**5)/40 - (5*x**7)/112\n\n    return rasp.Map(lambda x: arccosine_approx(x), rasp.tokens).named(\"arccosine\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, None, None, 0, None, None]. (0.989 error rate)"
            },
            {
                "generated rasp code": "def make_arccosine() -> rasp.SOp:\n    def arccosine_approx(x):\n        if x < -1 or x > 1:\n            return None\n        \n        # For x close to \u00b11, use the identity acos(x) = 2 * asin(sqrt((1-x)/2))\n        if abs(x) > 0.9:\n            y = (1 - x) / 2\n            result = 0\n            term = 1\n            for n in range(10):  # Limit to 10 terms for efficiency\n                result += term * y ** n / (2 * n + 1)\n                term *= 2 * n + 1\n                term /= 2 * (n + 1)\n            return 2 * result ** 0.5\n        \n        # For other values, use Taylor series for acos(x)\n        result = 3.141592653589793 / 2  # \u03c0/2\n        term = x\n        x_squared = x * x\n        for n in range(1, 10):  # Limit to 10 terms for efficiency\n            result -= term / (2 * n - 1)\n            term *= x_squared * (2 * n - 1) / (2 * n)\n        \n        return result\n\n    return rasp.Map(lambda x: arccosine_approx(x), rasp.tokens).named(\"arccosine\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, None, None, 2.0, None, None]. (0.933 error rate)"
            },
            {
                "generated rasp code": "def make_arccosine() -> rasp.SOp:\n    def approx_acos(x):\n        # Simple polynomial approximation of arccosine\n        # This is a rough approximation and works best for x close to 0\n        if x < -1 or x > 1:\n            return None\n        return 1.5707963267948966 - x - x**3/6  # \u03c0/2 - x - x^3/6\n\n    # Apply the approximate arccosine function to each element\n    return rasp.Map(lambda x: approx_acos(x), rasp.tokens).named(\"arccosine\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, None, None, 0.40412966012822993, None, None]. (0.999 error rate)"
            }
        ],
        "make_check_all_equal": [
            {
                "generated rasp code": "def make_check_all_equal() -> rasp.SOp:\n    # Selector that compares each element with the first element\n    first_element = rasp.Aggregate(rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.EQ), rasp.tokens)\n    eq_selector = rasp.Select(rasp.tokens, first_element, rasp.Comparison.EQ).named(\"eq_selector\")\n\n    # Count the number of elements equal to the first element\n    eq_count = rasp.SelectorWidth(eq_selector).named(\"eq_count\")\n\n    # Create a sequence of the input length\n    sequence_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"sequence_length\")\n\n    # Compare eq_count with sequence_length\n    all_equal = rasp.SequenceMap(lambda x, y: x == y, eq_count, sequence_length).named(\"all_equal\")\n\n    # Map True to 1 and False to 0\n    result = rasp.Map(lambda x: 1 if x else 0, all_equal).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_check_all_equal() -> rasp.SOp:\n    # Selector that compares each element with the first element\n    eq_selector = rasp.Select(rasp.tokens, rasp.Aggregate(rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.EQ), rasp.tokens), rasp.Comparison.EQ).named(\"eq_selector\")\n\n    # Count the number of elements equal to the first element\n    eq_count = rasp.SelectorWidth(eq_selector).named(\"eq_count\")\n\n    # Create a sequence of the input length\n    seq_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"seq_length\")\n\n    # Compare eq_count with seq_length\n    all_equal = rasp.SequenceMap(lambda x, y: x == y, eq_count, seq_length).named(\"all_equal\")\n\n    # Map True to 1 and False to 0\n    result = rasp.Map(lambda x: 1 if x else 0, all_equal).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_check_all_equal() -> rasp.SOp:\n    # Selector that creates a comparison matrix where each element is compared to every other element for equality\n    eq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.EQ).named(\"eq_selector\")\n\n    # Count the number of elements each element is equal to (including itself)\n    eq_count = rasp.SelectorWidth(eq_selector).named(\"eq_count\")\n\n    # Create a Map to get the sequence length for each element\n    sequence_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"sequence_length\")\n\n    # Compare eq_count with sequence_length and map to 1 if equal (all elements are the same) or 0 if not\n    result = rasp.SequenceMap(lambda count, length: 1 if count == length else 0, eq_count, sequence_length).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_check_all_equal() -> rasp.SOp:\n    # Selector that compares each element to the first element\n    first_element = rasp.Aggregate(rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.EQ), rasp.tokens)\n    eq_selector = rasp.Select(rasp.tokens, first_element, rasp.Comparison.EQ).named(\"eq_selector\")\n\n    # Count the number of elements equal to the first element\n    eq_count = rasp.SelectorWidth(eq_selector).named(\"eq_count\")\n\n    # Create a sequence of the input length\n    sequence_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"sequence_length\")\n\n    # Compare eq_count with sequence_length\n    all_equal = rasp.SequenceMap(lambda x, y: x == y, eq_count, sequence_length).named(\"all_equal\")\n\n    # Map the comparison result to 1 (if all equal) or 0 (if not all equal)\n    result = rasp.Map(lambda x: 1 if x else 0, all_equal).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_check_all_equal() -> rasp.SOp:\n    # Selector that compares each element with the first element\n    eq_first_selector = rasp.Select(rasp.tokens, rasp.Aggregate(rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.EQ), rasp.tokens), rasp.Comparison.EQ).named(\"eq_first_selector\")\n\n    # Count the number of elements equal to the first element\n    eq_count = rasp.SelectorWidth(eq_first_selector).named(\"eq_count\")\n\n    # Create a sequence where each element is the length of the input sequence\n    seq_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"seq_length\")\n\n    # Compare eq_count with seq_length\n    all_equal = rasp.SequenceMap(lambda x, y: x == y, eq_count, seq_length).named(\"all_equal\")\n\n    # Map True to 1 and False to 0\n    result = rasp.Map(lambda x: 1 if x else 0, all_equal).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": "test_run_op timed out"
            }
        ],
        "make_position": [
            {
                "generated rasp code": "def make_position() -> rasp.SOp:\n    # Use Map to add 1 to each index, converting 0-based indices to 1-based positions\n    return rasp.Map(lambda x: x + 1, rasp.indices).named(\"position\")",
                "failure stage": 3,
                "error": "'tokens'"
            },
            {
                "generated rasp code": "def make_position() -> rasp.SOp:\n    # Use rasp.Map to add 1 to each element of rasp.indices\n    # This transforms the zero-indexed positions to one-indexed positions\n    return rasp.Map(lambda x: x + 1, rasp.indices).named(\"position\")",
                "failure stage": 3,
                "error": "'tokens'"
            },
            {
                "generated rasp code": "def make_position() -> rasp.SOp:\n    # Use rasp.Map to add 1 to each element of rasp.indices\n    # This transforms the zero-indexed sequence to a one-indexed sequence\n    return rasp.Map(lambda x: x + 1, rasp.indices).named(\"position\")",
                "failure stage": 3,
                "error": "'tokens'"
            },
            {
                "generated rasp code": "def make_position() -> rasp.SOp:\n    # Use rasp.Map to add 1 to each index, transforming zero-indexed positions to one-indexed positions\n    return rasp.Map(lambda x: x + 1, rasp.indices).named(\"position\")",
                "failure stage": 3,
                "error": "'tokens'"
            },
            {
                "generated rasp code": "def make_position() -> rasp.SOp:\n    # Use rasp.Map to add 1 to each element of rasp.indices\n    # This transforms the zero-indexed sequence to a one-indexed sequence\n    position_sequence = rasp.Map(lambda x: x + 1, rasp.indices).named(\"position_sequence\")\n    \n    return position_sequence",
                "failure stage": 3,
                "error": "'tokens'"
            }
        ],
        "make_set_to_median": [
            {
                "generated rasp code": "def make_set_to_median() -> rasp.SOp:\n    # Selector that creates a comparison matrix where each element is compared to every other element\n    leq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LEQ).named(\"leq_selector\")\n\n    # Count the number of elements less than or equal to each element\n    leq_count = rasp.SelectorWidth(leq_selector).named(\"leq_count\")\n\n    # Calculate sequence length\n    seq_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"seq_length\")\n\n    # Calculate median index (length / 2)\n    median_index = rasp.Map(lambda x: x // 2, seq_length).named(\"median_index\")\n\n    # Check if length is odd (1) or even (0)\n    is_odd = rasp.SequenceMap(lambda x, y: x % 2, seq_length, rasp.tokens).named(\"is_odd\")\n\n    # Selector for odd length (count equals median index + 1)\n    odd_selector = rasp.Select(leq_count, rasp.Map(lambda x: x + 1, median_index), rasp.Comparison.EQ).named(\"odd_selector\")\n\n    # Selector for even length (count equals median index or median index + 1)\n    even_selector_lower = rasp.Select(leq_count, median_index, rasp.Comparison.EQ).named(\"even_selector_lower\")\n    even_selector_upper = rasp.Select(leq_count, rasp.Map(lambda x: x + 1, median_index), rasp.Comparison.EQ).named(\"even_selector_upper\")\n    even_selector = (even_selector_lower | even_selector_upper).named(\"even_selector\")\n\n    # Combine odd and even selectors\n    median_selector = rasp.SequenceMap(\n        lambda odd, even: odd if odd else even,\n        rasp.SequenceMap(lambda is_odd, odd: odd if is_odd else False, is_odd, odd_selector),\n        rasp.SequenceMap(lambda is_odd, even: even if not is_odd else False, is_odd, even_selector)\n    ).named(\"median_selector\")\n\n    # Use Aggregate to broadcast the median element(s) across the entire sequence\n    median_sequence = rasp.Aggregate(median_selector, rasp.tokens).named(\"median_sequence\")\n\n    return median_sequence",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_set_to_median() -> rasp.SOp:\n    # Selector that creates a comparison matrix where each element is compared to every other element\n    leq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LEQ).named(\"leq_selector\")\n\n    # Count the number of comparisons where each element is less than or equal to other elements\n    leq_count = rasp.SelectorWidth(leq_selector).named(\"leq_count\")\n\n    # Calculate the sequence length\n    sequence_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"sequence_length\")\n\n    # Calculate the lower median index (floor(length / 2))\n    lower_median_index = rasp.Map(lambda x: x // 2, sequence_length).named(\"lower_median_index\")\n\n    # Calculate the upper median index (ceil(length / 2))\n    upper_median_index = rasp.Map(lambda x: (x + 1) // 2, sequence_length).named(\"upper_median_index\")\n\n    # Selector for the lower median element\n    lower_median_selector = rasp.Select(leq_count, lower_median_index, rasp.Comparison.EQ).named(\"lower_median_selector\")\n\n    # Selector for the upper median element\n    upper_median_selector = rasp.Select(leq_count, upper_median_index, rasp.Comparison.EQ).named(\"upper_median_selector\")\n\n    # Use Aggregate to get the lower and upper median elements\n    lower_median = rasp.Aggregate(lower_median_selector, rasp.tokens).named(\"lower_median\")\n    upper_median = rasp.Aggregate(upper_median_selector, rasp.tokens).named(\"upper_median\")\n\n    # Average the lower and upper median elements\n    median = rasp.SequenceMap(lambda x, y: (x + y) / 2, lower_median, upper_median).named(\"median\")\n\n    return median",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_set_to_median() -> rasp.SOp:\n    # Create selectors for \"Less Than\" and \"Less Than or Equal\" comparisons\n    lt_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LT).named(\"lt_selector\")\n    leq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LEQ).named(\"leq_selector\")\n\n    # Count the number of elements less than and less than or equal to each element\n    lt_count = rasp.SelectorWidth(lt_selector).named(\"lt_count\")\n    leq_count = rasp.SelectorWidth(leq_selector).named(\"leq_count\")\n\n    # Calculate sequence length\n    seq_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"seq_length\")\n\n    # Calculate floor and ceiling of half the sequence length\n    half_floor = rasp.Map(lambda x: x // 2, seq_length).named(\"half_floor\")\n    half_ceil = rasp.Map(lambda x: (x + 1) // 2, seq_length).named(\"half_ceil\")\n\n    # Create selectors for potential median elements\n    lower_median_selector = rasp.Select(lt_count, half_floor, rasp.Comparison.LT).named(\"lower_median_selector\")\n    upper_median_selector = rasp.Select(leq_count, half_ceil, rasp.Comparison.LEQ).named(\"upper_median_selector\")\n\n    # Aggregate potential median elements\n    lower_median = rasp.Aggregate(lower_median_selector, rasp.tokens).named(\"lower_median\")\n    upper_median = rasp.Aggregate(upper_median_selector, rasp.tokens).named(\"upper_median\")\n\n    # Calculate average of potential median elements\n    median = rasp.SequenceMap(lambda x, y: (x + y) // 2, lower_median, upper_median).named(\"median\")\n\n    return median",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_set_to_median() -> rasp.SOp:\n    # Create a selector for elements greater than or equal to each other\n    geq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.GEQ).named(\"geq_selector\")\n\n    # Count how many elements each element is greater than or equal to\n    geq_count = rasp.SelectorWidth(geq_selector).named(\"geq_count\")\n\n    # Get the sequence length\n    seq_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"seq_length\")\n\n    # Calculate half the sequence length (floored)\n    half_length = rasp.Map(lambda x: x // 2, seq_length).named(\"half_length\")\n\n    # Selector for elements that are greater than or equal to half the elements (potential medians)\n    median_selector = rasp.Select(geq_count, half_length, rasp.Comparison.GEQ).named(\"median_selector\")\n\n    # Selector for elements that are exactly at the middle (for odd-length sequences)\n    exact_median_selector = rasp.Select(geq_count, half_length, rasp.Comparison.EQ).named(\"exact_median_selector\")\n\n    # Select the median for odd-length sequences\n    odd_median = rasp.Aggregate(exact_median_selector, rasp.tokens).named(\"odd_median\")\n\n    # Select two middle elements for even-length sequences\n    even_median_low = rasp.Aggregate(median_selector, rasp.tokens).named(\"even_median_low\")\n    even_median_high = rasp.Aggregate(~median_selector, rasp.tokens).named(\"even_median_high\")\n\n    # Average the two middle elements for even-length sequences\n    even_median = rasp.SequenceMap(lambda x, y: (x + y) / 2 if x is not None and y is not None else None, \n                                   even_median_low, even_median_high).named(\"even_median\")\n\n    # Determine if the sequence length is odd\n    is_odd = rasp.Map(lambda x: x % 2 == 1, seq_length).named(\"is_odd\")\n\n    # Choose between odd and even median based on sequence length\n    final_median = rasp.SequenceMap(lambda odd, even, is_odd: odd if is_odd else even,\n                                    odd_median, even_median, is_odd).named(\"final_median\")\n\n    return final_median",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            },
            {
                "generated rasp code": "def make_set_to_median() -> rasp.SOp:\n    # Create a selector for elements less than or equal to each element\n    leq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LEQ).named(\"leq_selector\")\n    \n    # Count how many elements are less than or equal to each element\n    leq_count = rasp.SelectorWidth(leq_selector).named(\"leq_count\")\n    \n    # Calculate the length of the sequence\n    seq_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"seq_length\")\n    \n    # Calculate the middle index (for odd-length sequences) or the average of two middle indices (for even-length sequences)\n    middle_index = rasp.Map(lambda n: (n + 1) / 2, seq_length).named(\"middle_index\")\n    \n    # Select elements that could be the median (either one or two elements)\n    potential_median_selector = rasp.Select(leq_count, middle_index, rasp.Comparison.LEQ).named(\"potential_median_selector\")\n    \n    # Get the potential median values\n    potential_median_values = rasp.Aggregate(potential_median_selector, rasp.tokens).named(\"potential_median_values\")\n    \n    # Count how many potential median values we have (1 for odd-length, 2 for even-length)\n    potential_median_count = rasp.SelectorWidth(potential_median_selector).named(\"potential_median_count\")\n    \n    # Calculate the final median\n    # If potential_median_count is 1, use that value\n    # If potential_median_count is 2, calculate the average of the two values\n    final_median = rasp.SequenceMap(\n        lambda count, value: value if count == 1 else (value + rasp.Aggregate(rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.GT), rasp.tokens, default=0)(value)) / 2,\n        potential_median_count,\n        potential_median_values\n    ).named(\"final_median\")\n    \n    # Broadcast the final median to all positions\n    return rasp.Map(lambda x: x, final_median).named(\"median_sequence\")",
                "failure stage": 0,
                "error": "test_run_op timed out"
            }
        ],
        "make_swap_min_max": [
            {
                "generated rasp code": "def make_swap_min_max() -> rasp.SOp:\n    # Find maximum value\n    max_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LEQ).named(\"max_selector\")\n    max_count = rasp.SelectorWidth(max_selector).named(\"max_count\")\n    sequence_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"sequence_length\")\n    is_max = rasp.Select(max_count, sequence_length, rasp.Comparison.EQ).named(\"is_max\")\n\n    # Find minimum value\n    min_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.GEQ).named(\"min_selector\")\n    min_count = rasp.SelectorWidth(min_selector).named(\"min_count\")\n    is_min = rasp.Select(min_count, sequence_length, rasp.Comparison.EQ).named(\"is_min\")\n\n    # Get max and min values\n    max_value = rasp.Aggregate(is_max, rasp.tokens).named(\"max_value\")\n    min_value = rasp.Aggregate(is_min, rasp.tokens).named(\"min_value\")\n\n    # Replace max with min and min with max\n    replaced_max = rasp.Aggregate(is_max, min_value).named(\"replaced_max\")\n    replaced_min = rasp.Aggregate(is_min, max_value).named(\"replaced_min\")\n\n    # Combine results\n    def combine(token, r_max, r_min):\n        if r_max is not None:\n            return r_max\n        elif r_min is not None:\n            return r_min\n        else:\n            return token\n\n    swapped = rasp.SequenceMap(combine, rasp.tokens, replaced_max, replaced_min).named(\"swapped\")\n\n    return swapped",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            },
            {
                "generated rasp code": "def make_swap_min_max() -> rasp.SOp:\n    # Find maximum value\n    max_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LEQ).named(\"max_selector\")\n    max_count = rasp.SelectorWidth(max_selector).named(\"max_count\")\n    sequence_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"sequence_length\")\n    is_max = rasp.Select(max_count, sequence_length, rasp.Comparison.EQ).named(\"is_max\")\n\n    # Find minimum value\n    min_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.GEQ).named(\"min_selector\")\n    min_count = rasp.SelectorWidth(min_selector).named(\"min_count\")\n    is_min = rasp.Select(min_count, sequence_length, rasp.Comparison.EQ).named(\"is_min\")\n\n    # Get max and min values\n    max_value = rasp.Aggregate(is_max, rasp.tokens).named(\"max_value\")\n    min_value = rasp.Aggregate(is_min, rasp.tokens).named(\"min_value\")\n\n    # Replace max with min\n    replace_max = rasp.Aggregate(is_max, min_value).named(\"replace_max\")\n\n    # Replace min with max\n    replace_min = rasp.Aggregate(is_min, max_value).named(\"replace_min\")\n\n    # Combine results\n    def combine(orig, rep_max, rep_min):\n        if rep_max is not None:\n            return rep_max\n        elif rep_min is not None:\n            return rep_min\n        else:\n            return orig\n\n    swapped = rasp.SequenceMap(combine, rasp.tokens, replace_max, replace_min).named(\"swapped\")\n\n    return swapped",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            },
            {
                "generated rasp code": "def make_swap_min_max() -> rasp.SOp:\n    # Find the maximum value\n    max_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.GEQ)\n    max_value = rasp.Aggregate(max_selector, rasp.tokens)\n\n    # Find the minimum value\n    min_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LEQ)\n    min_value = rasp.Aggregate(min_selector, rasp.tokens)\n\n    # Create selectors for positions of maximum and minimum values\n    is_max = rasp.Select(rasp.tokens, max_value, rasp.Comparison.EQ)\n    is_min = rasp.Select(rasp.tokens, min_value, rasp.Comparison.EQ)\n\n    # Swap max and min values\n    def swap(x, is_max, is_min, max_val, min_val):\n        if is_max:\n            return min_val\n        elif is_min:\n            return max_val\n        else:\n            return x\n\n    swapped = rasp.SequenceMap(\n        lambda x, max_pos, min_pos, max_val, min_val: \n            swap(x, max_pos, min_pos, max_val, min_val),\n        rasp.tokens, is_max, is_min, max_value, min_value\n    )\n\n    return swapped.named(\"swap_min_max\")",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 7 were given"
            },
            {
                "generated rasp code": "def make_swap_min_max() -> rasp.SOp:\n    # Find the maximum value\n    max_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LEQ)\n    max_count = rasp.SelectorWidth(max_selector)\n    max_index_selector = rasp.Select(max_count, rasp.Map(lambda x: len(x), rasp.tokens), rasp.Comparison.EQ)\n    max_value = rasp.Aggregate(max_index_selector, rasp.tokens)\n\n    # Find the minimum value\n    min_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.GEQ)\n    min_count = rasp.SelectorWidth(min_selector)\n    min_index_selector = rasp.Select(min_count, rasp.Map(lambda x: len(x), rasp.tokens), rasp.Comparison.EQ)\n    min_value = rasp.Aggregate(min_index_selector, rasp.tokens)\n\n    # Create selectors for max and min occurrences\n    max_occurrences = rasp.Select(rasp.tokens, max_value, rasp.Comparison.EQ)\n    min_occurrences = rasp.Select(rasp.tokens, min_value, rasp.Comparison.EQ)\n\n    # Replace max with min and min with max\n    max_to_min = rasp.Aggregate(max_occurrences, min_value)\n    min_to_max = rasp.Aggregate(min_occurrences, max_value)\n\n    # Combine results\n    def combine(x, y, z):\n        return z if z is not None else (y if y is not None else x)\n    \n    result = rasp.SequenceMap(combine, rasp.tokens, min_to_max, max_to_min)\n\n    return result.named(\"swap_min_max\")",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            },
            {
                "generated rasp code": "def make_swap_min_max() -> rasp.SOp:\n    # Find positions of maximum values\n    max_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.LEQ)\n    max_positions = rasp.SelectorWidth(max_selector)\n    is_max = rasp.Select(max_positions, rasp.Map(lambda x: len(x), rasp.tokens), rasp.Comparison.EQ)\n\n    # Find positions of minimum values\n    min_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.GEQ)\n    min_positions = rasp.SelectorWidth(min_selector)\n    is_min = rasp.Select(min_positions, rasp.Map(lambda x: len(x), rasp.tokens), rasp.Comparison.EQ)\n\n    # Get the maximum and minimum values\n    max_value = rasp.Aggregate(is_max, rasp.tokens)\n    min_value = rasp.Aggregate(is_min, rasp.tokens)\n\n    # Replace max values with min and min values with max\n    replaced_max = rasp.Aggregate(is_max, min_value)\n    replaced_min = rasp.Aggregate(is_min, max_value)\n\n    # Combine the results\n    def combine(original, replaced_max, replaced_min):\n        if replaced_max is not None:\n            return replaced_max\n        elif replaced_min is not None:\n            return replaced_min\n        else:\n            return original\n\n    return rasp.SequenceMap(combine, rasp.tokens, replaced_max, replaced_min).named(\"swap_min_max\")",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            }
        ],
        "make_clip": [],
        "make_pairwise_max": [
            {
                "generated rasp code": "def make_pairwise_max() -> rasp.SOp:\n    # Shift the sequence by 1 position to the right, filling the first position with the first element\n    shifted_sequence = rasp.Aggregate(\n        rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.GT),\n        rasp.tokens\n    ).named(\"shifted_sequence\")\n\n    # Create a selector that compares each element with its predecessor\n    max_selector = rasp.Select(rasp.tokens, shifted_sequence, rasp.Comparison.GEQ).named(\"max_selector\")\n\n    # Use the selector to aggregate the maximum of each element and its predecessor\n    max_aggregated = rasp.Aggregate(max_selector, rasp.tokens).named(\"max_aggregated\")\n\n    # Combine the original first element with the rest of the transformed sequence\n    result = rasp.SequenceMap(\n        lambda x, y: x if y is None else y,\n        max_aggregated,\n        rasp.tokens\n    ).named(\"pairwise_max_result\")\n\n    return result",
                "failure stage": 1,
                "error": "query is None!"
            },
            {
                "generated rasp code": "def make_pairwise_max() -> rasp.SOp:\n    # Create a selector that selects the previous element for each position\n    prev_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y - 1).named(\"prev_selector\")\n\n    # Shift the sequence by one position to the right, inserting None at the beginning\n    shifted_sequence = rasp.Aggregate(prev_selector, rasp.tokens).named(\"shifted_sequence\")\n\n    # Compare each element with its previous element (or itself for the first element) and take the maximum\n    pairwise_max = rasp.SequenceMap(\n        lambda x, y: x if y is None else max(x, y),\n        rasp.tokens,\n        shifted_sequence\n    ).named(\"pairwise_max\")\n\n    return pairwise_max",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, 8, 8.0, 2.0, 5, 5.0]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_pairwise_max() -> rasp.SOp:\n    # Create a selector for previous elements (select i-1 for position i)\n    prev_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y - 1).named(\"prev_selector\")\n\n    # Shift the sequence by one position\n    shifted = rasp.Aggregate(prev_selector, rasp.tokens).named(\"shifted\")\n\n    # Compare each element with its shifted counterpart, taking the maximum\n    # Note: We use -float('inf') for None to ensure it's always less than any number\n    pairwise_max = rasp.SequenceMap(\n        lambda x, y: max(x, y) if y is not None else x,\n        rasp.tokens,\n        shifted\n    ).named(\"pairwise_max\")\n\n    return pairwise_max",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, 8, 8.0, 2.0, 5, 5.0]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_pairwise_max() -> rasp.SOp:\n    # Create a selector for the previous element (shifted right by 1)\n    shift_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y + 1).named(\"shift_selector\")\n\n    # Shift the sequence right by 1, leaving the first element as None\n    shifted = rasp.Aggregate(shift_selector, rasp.tokens).named(\"shifted\")\n\n    # Handle the None case in the shifted sequence\n    shifted_safe = rasp.Map(lambda x: x if x is not None else float('-inf'), shifted).named(\"shifted_safe\")\n\n    # Compare each element with its previous (shifted) element\n    max_with_prev = rasp.SequenceMap(lambda x, y: max(x, y), rasp.tokens, shifted_safe).named(\"max_with_prev\")\n\n    # Create a selector for the first element\n    first_elem_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == 0).named(\"first_elem_selector\")\n\n    # Combine results: use original value for first element, max_with_prev for others\n    result = rasp.SequenceMap(\n        lambda x, y: x if y else y,\n        max_with_prev,\n        first_elem_selector\n    ).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_pairwise_max() -> rasp.SOp:\n    # Create a selector that selects the previous element for each position\n    prev_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y - 1).named(\"prev_selector\")\n\n    # Use Aggregate to shift the sequence by one position to the right\n    shifted_sequence = rasp.Aggregate(prev_selector, rasp.tokens).named(\"shifted_sequence\")\n\n    # Create a selector for the first element\n    first_elem_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == 0).named(\"first_elem_selector\")\n\n    # Use SequenceMap to compare each element with its previous element and take the maximum\n    pairwise_max = rasp.SequenceMap(lambda x, y: max(x, y) if y is not None else x, rasp.tokens, shifted_sequence).named(\"pairwise_max\")\n\n    # Combine the first element (unchanged) with the pairwise max of the rest\n    result = rasp.Aggregate(first_elem_selector, rasp.tokens, default=None).named(\"first_elem\") | pairwise_max\n\n    return result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [None, 3.0, 3.0, 3.0, 3.0, 3.0]. (1.0 error rate)"
            }
        ],
        "make_check_alternating": [
            {
                "generated rasp code": "def make_check_alternating() -> rasp.SOp:\n    # Check if each number is odd\n    is_odd = rasp.Select(\n        rasp.Map(lambda x: x % 2, rasp.tokens),\n        rasp.Map(lambda x: 1, rasp.tokens),\n        rasp.Comparison.EQ\n    ).named(\"is_odd\")\n\n    # Check if each index is odd\n    is_odd_index = rasp.Select(\n        rasp.Map(lambda x: x % 2, rasp.indices),\n        rasp.Map(lambda x: 1, rasp.tokens),\n        rasp.Comparison.EQ\n    ).named(\"is_odd_index\")\n\n    # Combine conditions: (number is odd AND index is odd) OR (number is even AND index is even)\n    is_alternating = rasp.SequenceMap(\n        lambda x, y: (x and y) or (not x and not y),\n        is_odd,\n        is_odd_index\n    ).named(\"is_alternating\")\n\n    # Map to 1 if alternating, 0 otherwise\n    result = rasp.Map(lambda x: 1 if x else 0, is_alternating).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_check_alternating() -> rasp.SOp:\n    # Create a selector for odd numbers\n    is_odd = rasp.Select(rasp.tokens, rasp.Map(lambda x: 2, rasp.tokens), rasp.Comparison.NEQ).named(\"is_odd\")\n    \n    # Create a selector for even numbers\n    is_even = rasp.Select(rasp.tokens, rasp.Map(lambda x: 2, rasp.tokens), rasp.Comparison.EQ).named(\"is_even\")\n    \n    # Create two alternating patterns (odd-even and even-odd)\n    pattern_odd_even = rasp.SequenceMap(lambda x, y: x % 2 == 1, rasp.indices, rasp.tokens).named(\"pattern_odd_even\")\n    pattern_even_odd = rasp.SequenceMap(lambda x, y: x % 2 == 0, rasp.indices, rasp.tokens).named(\"pattern_even_odd\")\n    \n    # Check if the sequence follows either pattern\n    follows_odd_even = rasp.Select(rasp.tokens, pattern_odd_even, rasp.Comparison.EQ).named(\"follows_odd_even\")\n    follows_even_odd = rasp.Select(rasp.tokens, pattern_even_odd, rasp.Comparison.EQ).named(\"follows_even_odd\")\n    \n    # Combine the patterns\n    follows_pattern = rasp.selector_or(follows_odd_even, follows_even_odd).named(\"follows_pattern\")\n    \n    # Count how many elements follow the pattern\n    correct_count = rasp.SelectorWidth(follows_pattern).named(\"correct_count\")\n    \n    # Get the sequence length\n    seq_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"seq_length\")\n    \n    # Check if all elements follow the pattern\n    all_correct = rasp.Select(correct_count, seq_length, rasp.Comparison.EQ).named(\"all_correct\")\n    \n    # Map the result to 1's and 0's\n    result = rasp.Map(lambda x: 1 if x else 0, all_correct).named(\"result\")\n    \n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_check_alternating() -> rasp.SOp:\n    # Create a sequence representing odd (1) or even (0)\n    odd_even_seq = rasp.Map(lambda x: x % 2, rasp.tokens).named(\"odd_even_seq\")\n\n    # Create the expected alternating pattern (1, 0, 1, 0, ...)\n    expected_pattern = rasp.Map(lambda x: x % 2, rasp.indices).named(\"expected_pattern\")\n\n    # Compare the actual odd/even sequence with the expected pattern\n    pattern_match = rasp.SequenceMap(\n        lambda x, y: 1 if x == y else 0,\n        odd_even_seq,\n        expected_pattern\n    ).named(\"pattern_match\")\n\n    # Check if all elements match the pattern\n    all_match_selector = rasp.Select(\n        pattern_match,\n        rasp.Map(lambda x: 1, rasp.tokens),\n        rasp.Comparison.EQ\n    ).named(\"all_match_selector\")\n\n    # Use Aggregate to broadcast the result (all 1s if pattern matches, all 0s otherwise)\n    result = rasp.Aggregate(all_match_selector, rasp.Map(lambda x: 1, rasp.tokens), default=None).named(\"result\")\n\n    return result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [1.0, 1.0, 1.0, 1.0, 1.0, 1.0]. (0.96 error rate)"
            },
            {
                "generated rasp code": "def make_check_alternating() -> rasp.SOp:\n    # Check if a number is odd\n    is_odd = rasp.Map(lambda x: x % 2 == 1, rasp.tokens).named(\"is_odd\")\n    \n    # Check if a number is even\n    is_even = rasp.Map(lambda x: x % 2 == 0, rasp.tokens).named(\"is_even\")\n    \n    # Create a sequence of alternating True/False values\n    alternating_pattern = rasp.Map(lambda x: x % 2 == 1, rasp.indices).named(\"alternating_pattern\")\n    \n    # Check if odd numbers are at odd indices and even numbers at even indices\n    correct_odd = rasp.Select(is_odd, alternating_pattern, rasp.Comparison.EQ).named(\"correct_odd\")\n    correct_even = rasp.Select(is_even, ~alternating_pattern, rasp.Comparison.EQ).named(\"correct_even\")\n    \n    # Combine the odd and even conditions\n    alternating_condition = (correct_odd & correct_even).named(\"alternating_condition\")\n    \n    # Count how many elements satisfy the alternating condition\n    alternating_count = rasp.SelectorWidth(alternating_condition).named(\"alternating_count\")\n    \n    # Create a sequence of the input length\n    sequence_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"sequence_length\")\n    \n    # Check if all elements satisfy the alternating condition\n    all_alternating = rasp.SequenceMap(lambda x, y: x == y, alternating_count, sequence_length).named(\"all_alternating\")\n    \n    # Map the result to 1 if condition is met, 0 otherwise\n    result = rasp.Map(lambda x: 1 if x else 0, all_alternating).named(\"result\")\n    \n    return result",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_check_alternating() -> rasp.SOp:\n    # Check if each number is odd\n    is_odd = rasp.Map(lambda x: x % 2 == 1, rasp.tokens).named(\"is_odd\")\n    \n    # Check if each number is even\n    is_even = rasp.Map(lambda x: x % 2 == 0, rasp.tokens).named(\"is_even\")\n    \n    # Create a selector for the alternating pattern\n    alternating_selector = rasp.SequenceMap(\n        lambda x, y: (x and not y) or (not x and y),\n        is_odd,\n        rasp.Aggregate(rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.EQ + 1), is_odd)\n    ).named(\"alternating_selector\")\n    \n    # Count how many pairs follow the alternating pattern\n    alternating_count = rasp.SelectorWidth(alternating_selector).named(\"alternating_count\")\n    \n    # Create a sequence of the expected count (sequence length - 1)\n    expected_count = rasp.Map(lambda x: len(x) - 1, rasp.tokens).named(\"expected_count\")\n    \n    # Check if the alternating count matches the expected count\n    is_fully_alternating = rasp.Select(alternating_count, expected_count, rasp.Comparison.EQ).named(\"is_fully_alternating\")\n    \n    # Map the result to 1 (if pattern is followed) or 0 (if not)\n    result = rasp.Map(lambda x: 1 if x else 0, is_fully_alternating).named(\"result\")\n    \n    return result",
                "failure stage": 0,
                "error": "unsupported operand type(s) for +: 'Comparison' and 'int'"
            }
        ],
        "make_exponential": [
            {
                "generated rasp code": "def make_exponential() -> rasp.SOp:\n    def exp_approx(x):\n        # Approximate e^x using a Taylor series expansion\n        # e^x \u2248 1 + x + x^2/2! + x^3/3! + x^4/4! + x^5/5!\n        result = 1 + x\n        term = x\n        for i in range(2, 6):  # Using terms up to x^5\n            term *= x / i\n            result += term\n        return result\n\n    # Apply the exponential approximation to each element\n    return rasp.Map(exp_approx, rasp.tokens).named(\"exponential\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [18.4, 570.0666666666666, 7.266666666666667, 2.7166666666666663, 91.41666666666667, 42.86666666666666]. (0.987 error rate)"
            },
            {
                "generated rasp code": "def make_exponential() -> rasp.SOp:\n    # Define the mathematical constant e\n    e = 2.718281828\n\n    # Use Map to apply the exponential function to each element\n    return rasp.Map(lambda x: e**x, rasp.tokens).named(\"exponential\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [20.085536913011932, 2980.957983014493, 7.389056096435021, 2.718281828, 148.41315897726145, 54.598149996263544]. (0.987 error rate)"
            },
            {
                "generated rasp code": "def make_exponential() -> rasp.SOp:\n    # Define the exponential function using e raised to the power of x\n    # We use 2.718281828 as an approximation of e\n    exp_function = lambda x: 2.718281828 ** x\n    \n    # Use Map to apply the exponential function to each element of the input sequence\n    exponential_sequence = rasp.Map(exp_function, rasp.tokens).named(\"exponential_sequence\")\n    \n    return exponential_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [20.085536913011932, 2980.957983014493, 7.389056096435021, 2.718281828, 148.41315897726145, 54.598149996263544]. (0.987 error rate)"
            },
            {
                "generated rasp code": "def make_exponential() -> rasp.SOp:\n    # Define the mathematical constant e\n    e = 2.718281828\n\n    # Use Map to apply the exponential function to each element\n    exponential_sequence = rasp.Map(lambda x: e**x, rasp.tokens).named(\"exponential_sequence\")\n\n    return exponential_sequence",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [20.085536913011932, 2980.957983014493, 7.389056096435021, 2.718281828, 148.41315897726145, 54.598149996263544]. (0.987 error rate)"
            },
            {
                "generated rasp code": "def make_exponential() -> rasp.SOp:\n    # Use Map to apply the exponential function to each element\n    # We use the approximation e^x \u2248 (1 + x/n)^n for n=1000\n    return rasp.Map(lambda x: (1 + x/1000)**1000, rasp.tokens).named(\"exponential\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [19.995534623451498, 2887.5672632098995, 7.374312390354616, 2.7169239322355936, 146.57562561109216, 54.164259360432794]. (0.987 error rate)"
            }
        ],
        "make_interleave_reverse": [
            {
                "generated rasp code": "def make_interleave_reverse() -> rasp.SOp:\n    # Create a selector for even indices\n    even_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 0).named(\"even_selector\")\n    \n    # Create a selector for the reverse order\n    reverse_selector = rasp.Select(\n        rasp.indices,\n        rasp.Map(lambda x: len(x) - 1 - x, rasp.indices),\n        rasp.Comparison.EQ\n    ).named(\"reverse_selector\")\n    \n    # Select elements from the original sequence for even indices\n    even_elements = rasp.Aggregate(even_selector, rasp.tokens).named(\"even_elements\")\n    \n    # Select elements from the reversed sequence for odd indices\n    odd_elements = rasp.Aggregate(~even_selector, rasp.Aggregate(reverse_selector, rasp.tokens)).named(\"odd_elements\")\n    \n    # Combine even and odd elements\n    interleaved = rasp.SequenceMap(\n        lambda x, y: x if x is not None else y,\n        even_elements,\n        odd_elements\n    ).named(\"interleaved\")\n    \n    return interleaved",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_interleave_reverse() -> rasp.SOp:\n    # Create a sequence of indices\n    indices = rasp.indices\n\n    # Create a sequence of the reversed indices\n    reversed_indices = rasp.Map(lambda x: len(x) - 1 - x, indices).named(\"reversed_indices\")\n\n    # Create a selector for even indices\n    even_selector = rasp.Select(rasp.Map(lambda x: x % 2, indices), rasp.Map(lambda x: 0, indices), rasp.Comparison.EQ).named(\"even_selector\")\n\n    # Create a selector for odd indices\n    odd_selector = rasp.Select(rasp.Map(lambda x: x % 2, indices), rasp.Map(lambda x: 1, indices), rasp.Comparison.EQ).named(\"odd_selector\")\n\n    # Select elements at even indices (keeping original order)\n    even_elements = rasp.Aggregate(even_selector, rasp.tokens).named(\"even_elements\")\n\n    # Create a sequence that contains original indices for even positions and reversed indices for odd positions\n    mixed_indices = rasp.SequenceMap(\n        lambda x, y: x if y % 2 == 0 else y,\n        indices,\n        reversed_indices\n    ).named(\"mixed_indices\")\n\n    # Use the mixed indices to select elements, effectively reversing odd indices\n    mixed_elements = rasp.Aggregate(rasp.Select(mixed_indices, indices, rasp.Comparison.EQ), rasp.tokens).named(\"mixed_elements\")\n\n    # Combine even elements (in original order) with mixed elements (reversed at odd indices)\n    result = rasp.SequenceMap(\n        lambda x, y: x if x is not None else y,\n        even_elements,\n        mixed_elements\n    ).named(\"interleaved_reverse\")\n\n    return result",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_interleave_reverse() -> rasp.SOp:\n    # Create a selector for even indices\n    even_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 0).named(\"even_selector\")\n    \n    # Create a selector for odd indices\n    odd_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 != 0).named(\"odd_selector\")\n    \n    # Create a reversed index sequence\n    reversed_indices = rasp.Map(lambda x: len(x) - 1 - x, rasp.indices).named(\"reversed_indices\")\n    \n    # Select elements for even indices (keeping them in place)\n    even_elements = rasp.Aggregate(even_selector, rasp.tokens).named(\"even_elements\")\n    \n    # Select elements for odd indices (in reverse order)\n    odd_elements = rasp.Aggregate(odd_selector, rasp.Aggregate(rasp.Select(reversed_indices, rasp.indices, rasp.Comparison.EQ), rasp.tokens)).named(\"odd_elements\")\n    \n    # Combine even and odd elements\n    interleaved = rasp.SequenceMap(\n        lambda x, y: x if x is not None else y,\n        even_elements,\n        odd_elements\n    ).named(\"interleaved\")\n    \n    return interleaved",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_interleave_reverse() -> rasp.SOp:\n    # Create a selector for even indices\n    even_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 == 0).named(\"even_selector\")\n    \n    # Create a selector for odd indices\n    odd_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x % 2 != 0).named(\"odd_selector\")\n    \n    # Create a reversed index sequence\n    reversed_indices = rasp.Map(lambda x: len(x) - 1 - x, rasp.indices).named(\"reversed_indices\")\n    \n    # Select elements from the original sequence for even indices\n    even_elements = rasp.Aggregate(even_selector, rasp.tokens).named(\"even_elements\")\n    \n    # Select elements from the reversed sequence for odd indices\n    odd_elements = rasp.Aggregate(odd_selector, rasp.Aggregate(rasp.Select(reversed_indices, rasp.indices, rasp.Comparison.EQ), rasp.tokens)).named(\"odd_elements\")\n    \n    # Combine even and odd elements\n    interleaved = rasp.SequenceMap(\n        lambda x, y: x if x is not None else y,\n        even_elements,\n        odd_elements\n    ).named(\"interleaved\")\n    \n    return interleaved",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_interleave_reverse() -> rasp.SOp:\n    # Create a selector for even indices\n    even_indices = rasp.Select(rasp.indices, rasp.Map(lambda x: 0, rasp.indices), rasp.Comparison.EQ).named(\"even_indices\")\n\n    # Create a selector for reverse order\n    sequence_length = rasp.Map(lambda x: len(x) - 1, rasp.tokens).named(\"sequence_length\")\n    reverse_order = rasp.Select(rasp.indices, sequence_length, rasp.Comparison.EQ).named(\"reverse_order\")\n\n    # Combine selectors: even indices stay in place, odd indices are reversed\n    combined_selector = (even_indices & rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.EQ)) | \\\n                        (~even_indices & reverse_order)\n\n    # Use Aggregate to create the final interleaved and reversed sequence\n    interleaved_reversed = rasp.Aggregate(combined_selector, rasp.tokens).named(\"interleaved_reversed\")\n\n    return interleaved_reversed",
                "failure stage": 0,
                "error": "test_run_op timed out"
            }
        ],
        "make_element_divide": [
            {
                "generated rasp code": "def make_element_divide() -> rasp.SOp:\n    # Check if sequence has at least two elements\n    has_two_elements = rasp.Map(lambda x: x >= 2, rasp.SelectorWidth(rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.LT))).named(\"has_two_elements\")\n    \n    # Extract first and second elements\n    first_element = rasp.Aggregate(rasp.Select(rasp.indices, rasp.Map(lambda x: 0, rasp.indices), rasp.Comparison.EQ), rasp.tokens).named(\"first_element\")\n    second_element = rasp.Aggregate(rasp.Select(rasp.indices, rasp.Map(lambda x: 1, rasp.indices), rasp.Comparison.EQ), rasp.tokens).named(\"second_element\")\n    \n    # Check if first or second element is zero\n    first_is_zero = rasp.Map(lambda x: x == 0, first_element).named(\"first_is_zero\")\n    second_is_zero = rasp.Map(lambda x: x == 0, second_element).named(\"second_is_zero\")\n    \n    # Combine conditions: proceed if we have two elements and neither is zero\n    should_divide = rasp.SequenceMap(lambda x, y, z: x and not (y or z), has_two_elements, first_is_zero, second_is_zero).named(\"should_divide\")\n    \n    # Calculate division factor (second element divided by first element)\n    division_factor = rasp.SequenceMap(lambda x, y: y / x if x != 0 else 1, first_element, second_element).named(\"division_factor\")\n    \n    # Divide each element by the division factor\n    divided_sequence = rasp.SequenceMap(lambda x, y: x / y if y != 0 else x, rasp.tokens, division_factor).named(\"divided_sequence\")\n    \n    # Use the condition to choose between original and divided sequence\n    result = rasp.SequenceMap(\n        lambda original, divided, condition: divided if condition else original,\n        rasp.tokens,\n        divided_sequence,\n        should_divide\n    ).named(\"result\")\n    \n    return result",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            },
            {
                "generated rasp code": "def make_element_divide():\n    # Select the first element\n    first_selector = rasp.Select(rasp.indices, rasp.tokens, lambda i, _: i == 0).named(\"first_selector\")\n    first_element = rasp.Map(lambda x: x[0] if x else None, rasp.Aggregate(first_selector, rasp.tokens)).named(\"first_element\")\n\n    # Select the second element\n    second_selector = rasp.Select(rasp.indices, rasp.tokens, lambda i, _: i == 1).named(\"second_selector\")\n    second_element = rasp.Map(lambda x: x[0] if x else None, rasp.Aggregate(second_selector, rasp.tokens)).named(\"second_element\")\n\n    # Calculate division factor (second / first)\n    division_factor = rasp.SequenceMap(\n        lambda x, y: y / x if x != 0 and y is not None else None,\n        first_element,\n        second_element\n    ).named(\"division_factor\")\n\n    # Check if division is valid (neither first nor second is zero, and sequence has at least two elements)\n    is_valid_division = rasp.SequenceMap(\n        lambda x, y: x != 0 and y is not None,\n        first_element,\n        second_element\n    ).named(\"is_valid_division\")\n\n    # Divide each element by the division factor if valid, otherwise return the original element\n    result = rasp.SequenceMap(\n        lambda x, factor, valid: x / factor if valid and factor is not None else x,\n        rasp.tokens,\n        division_factor,\n        is_valid_division\n    ).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            },
            {
                "generated rasp code": "def make_element_divide() -> rasp.SOp:\n    # Create a selector for sequences with at least two non-zero elements\n    valid_sequence = rasp.Select(\n        rasp.SequenceMap(lambda x, y: x > 1 and y != 0 and z != 0,\n                         rasp.Map(lambda x: len(x), rasp.tokens),\n                         rasp.Aggregate(rasp.Select(rasp.indices, rasp.Map(lambda x: 0, rasp.indices), rasp.Comparison.EQ), rasp.tokens),\n                         rasp.Aggregate(rasp.Select(rasp.indices, rasp.Map(lambda x: 1, rasp.indices), rasp.Comparison.EQ), rasp.tokens)),\n        rasp.Map(lambda x: True, rasp.indices),\n        rasp.Comparison.EQ\n    ).named(\"valid_sequence\")\n\n    # Get the first and second elements\n    first_element = rasp.Aggregate(rasp.Select(rasp.indices, rasp.Map(lambda x: 0, rasp.indices), rasp.Comparison.EQ), rasp.tokens).named(\"first_element\")\n    second_element = rasp.Aggregate(rasp.Select(rasp.indices, rasp.Map(lambda x: 1, rasp.indices), rasp.Comparison.EQ), rasp.tokens).named(\"second_element\")\n\n    # Calculate the division factor\n    division_factor = rasp.SequenceMap(lambda x, y: y / x if x != 0 else 1, first_element, second_element).named(\"division_factor\")\n\n    # Divide each element by the division factor\n    divided_sequence = rasp.SequenceMap(lambda x, y: x / y if y != 0 else x, rasp.tokens, division_factor).named(\"divided_sequence\")\n\n    # Choose between the divided sequence and the original sequence based on the validity\n    result = rasp.SequenceMap(\n        lambda x, y, z: y if z else x,\n        rasp.tokens,\n        divided_sequence,\n        valid_sequence\n    ).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            },
            {
                "generated rasp code": "def make_element_divide():\n    # Select the first two elements\n    first_two_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: 1, rasp.indices), rasp.Comparison.LEQ).named(\"first_two_selector\")\n    \n    # Calculate the division factor (second element / first element)\n    division_factor = rasp.SequenceMap(\n        lambda x, y: y / x if x != 0 and y != 0 else 1,\n        rasp.Aggregate(rasp.Select(rasp.indices, rasp.Map(lambda x: 0, rasp.indices), rasp.Comparison.EQ), rasp.tokens),\n        rasp.Aggregate(rasp.Select(rasp.indices, rasp.Map(lambda x: 1, rasp.indices), rasp.Comparison.EQ), rasp.tokens)\n    ).named(\"division_factor\")\n    \n    # Check if the division is valid (neither of first two elements is zero and sequence has at least two elements)\n    valid_division = rasp.SequenceMap(\n        lambda x, y: x != 0 and y != 0,\n        rasp.Aggregate(rasp.Select(rasp.indices, rasp.Map(lambda x: 0, rasp.indices), rasp.Comparison.EQ), rasp.tokens),\n        rasp.Aggregate(rasp.Select(rasp.indices, rasp.Map(lambda x: 1, rasp.indices), rasp.Comparison.EQ), rasp.tokens)\n    ).named(\"valid_division\")\n    \n    sequence_length = rasp.SelectorWidth(rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE)).named(\"sequence_length\")\n    valid_length = rasp.Map(lambda x: x >= 2, sequence_length).named(\"valid_length\")\n    \n    division_validity = rasp.SequenceMap(lambda x, y: x and y, valid_division, valid_length).named(\"division_validity\")\n    \n    # Apply the division if valid, otherwise return the original element\n    result = rasp.SequenceMap(\n        lambda x, y: x / y if y else x,\n        rasp.tokens,\n        rasp.SequenceMap(\n            lambda x, y: y if x else 1,\n            division_validity,\n            division_factor\n        )\n    ).named(\"result\")\n    \n    return result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [1.125, 3.0, 0.75, 0.375, 1.875, 1.5]. (0.091 error rate)"
            },
            {
                "generated rasp code": "def make_element_divide():\n    # Create a selector for sequences with at least 2 elements\n    length_selector = rasp.Select(\n        rasp.Map(lambda x: len(x), rasp.tokens),\n        rasp.Map(lambda x: 2, rasp.indices),\n        rasp.Comparison.GEQ\n    ).named(\"length_selector\")\n\n    # Get the first element\n    first_element = rasp.Aggregate(\n        rasp.Select(rasp.indices, rasp.Map(lambda x: 0, rasp.indices), rasp.Comparison.EQ),\n        rasp.tokens\n    ).named(\"first_element\")\n\n    # Get the second element\n    second_element = rasp.Aggregate(\n        rasp.Select(rasp.indices, rasp.Map(lambda x: 1, rasp.indices), rasp.Comparison.EQ),\n        rasp.tokens\n    ).named(\"second_element\")\n\n    # Create a selector for non-zero first and second elements\n    non_zero_selector = rasp.Select(\n        rasp.SequenceMap(lambda x, y: x != 0 and y != 0, first_element, second_element),\n        rasp.Map(lambda x: True, rasp.indices),\n        rasp.Comparison.EQ\n    ).named(\"non_zero_selector\")\n\n    # Combine length and non-zero selectors\n    valid_selector = rasp.selector_and(length_selector, non_zero_selector).named(\"valid_selector\")\n\n    # Calculate division factor\n    division_factor = rasp.Aggregate(\n        valid_selector,\n        rasp.SequenceMap(lambda x, y: y / x if x != 0 else None, first_element, second_element)\n    ).named(\"division_factor\")\n\n    # Divide each element by the division factor\n    divided_sequence = rasp.SequenceMap(\n        lambda x, y: x / y if y is not None else x,\n        rasp.tokens,\n        division_factor\n    ).named(\"divided_sequence\")\n\n    # Select between divided sequence and original sequence based on valid_selector\n    result = rasp.Aggregate(valid_selector, divided_sequence, default=None).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": "test_run_op timed out"
            }
        ],
        "make_set_to_index": [
            {
                "generated rasp code": "def make_set_to_index() -> rasp.SOp:\n    # Simply return rasp.indices, which already provides the index for each element\n    return rasp.indices.named(\"set_to_index\")",
                "failure stage": 3,
                "error": "Expression indices cannot be translated to a model component."
            },
            {
                "generated rasp code": "def make_set_to_index() -> rasp.SOp:\n    # Simply return the rasp.indices operation\n    # This will replace each element with its index in the sequence\n    return rasp.indices.named(\"set_to_index\")",
                "failure stage": 3,
                "error": "Expression indices cannot be translated to a model component."
            },
            {
                "generated rasp code": "def make_set_to_index() -> rasp.SOp:\n    # Simply return the rasp.indices SOp\n    # This SOp already gives us a sequence where each element is its index\n    return rasp.indices.named(\"set_to_index\")",
                "failure stage": 3,
                "error": "Expression indices cannot be translated to a model component."
            },
            {
                "generated rasp code": "def make_set_to_index() -> rasp.SOp:\n    # Simply return the rasp.indices SOp, which gives the index of each element\n    return rasp.indices.named(\"set_to_index\")",
                "failure stage": 3,
                "error": "Expression indices cannot be translated to a model component."
            },
            {
                "generated rasp code": "def make_set_to_index() -> rasp.SOp:\n    # Simply return the indices of the sequence\n    # We use rasp.Map with the identity function to ensure it's a proper SOp\n    return rasp.Map(lambda x: x, rasp.indices).named(\"set_to_index\")",
                "failure stage": 3,
                "error": "'tokens'"
            }
        ],
        "make_check_multiple_of_n": [
            {
                "generated rasp code": "def make_check_multiple_of_n(n=2):\n    # Apply modulo operation to each element\n    mod_n = rasp.Map(lambda x: x % n, rasp.tokens).named(\"mod_n\")\n\n    # Create a selector for elements that are multiples of n (remainder 0)\n    multiple_selector = rasp.Select(mod_n, rasp.Map(lambda x: 0, rasp.tokens), rasp.Comparison.EQ).named(\"multiple_selector\")\n\n    # Count how many elements are multiples of n\n    multiple_count = rasp.SelectorWidth(multiple_selector).named(\"multiple_count\")\n\n    # Get the length of the sequence\n    sequence_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"sequence_length\")\n\n    # Check if all elements are multiples (count equals length)\n    all_multiples = rasp.Select(multiple_count, sequence_length, rasp.Comparison.EQ).named(\"all_multiples\")\n\n    # Map the result to 1 if all are multiples, 0 otherwise\n    result = rasp.Map(lambda x: 1 if x else 0, all_multiples).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_check_multiple_of_n(n=2):\n    def check_multiple(tokens):\n        # Create a sequence of n values\n        n_sequence = rasp.Map(lambda x: n, rasp.tokens).named(\"n_sequence\")\n        \n        # Perform modulo operation\n        modulo_result = rasp.SequenceMap(lambda x, y: x % y, rasp.tokens, n_sequence).named(\"modulo_result\")\n        \n        # Create a selector for elements that are multiples of n\n        multiple_selector = rasp.Select(modulo_result, rasp.Map(lambda x: 0, rasp.tokens), rasp.Comparison.EQ).named(\"multiple_selector\")\n        \n        # Count the number of elements that are multiples of n\n        multiple_count = rasp.SelectorWidth(multiple_selector).named(\"multiple_count\")\n        \n        # Get the length of the sequence\n        sequence_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"sequence_length\")\n        \n        # Check if all elements are multiples of n\n        all_multiples = rasp.SequenceMap(lambda x, y: x == y, multiple_count, sequence_length).named(\"all_multiples\")\n        \n        # Map the result to 1 if all elements are multiples of n, and 0 otherwise\n        result = rasp.Map(lambda x: 1 if x else 0, all_multiples).named(\"result\")\n        \n        return result\n    \n    return check_multiple",
                "failure stage": 2,
                "error": "<class 'function'>"
            },
            {
                "generated rasp code": "def make_check_multiple_of_n(n: int = 2) -> rasp.SOp:\n    # Create a sequence of n values\n    n_sequence = rasp.Map(lambda x: n, rasp.indices).named(\"n_sequence\")\n\n    # Perform element-wise modulo operation\n    modulo_result = rasp.SequenceMap(lambda x, y: x % y, rasp.tokens, n_sequence).named(\"modulo_result\")\n\n    # Create a selector for elements that are multiples of n\n    multiple_selector = rasp.Select(modulo_result, rasp.Map(lambda x: 0, rasp.indices), rasp.Comparison.EQ).named(\"multiple_selector\")\n\n    # Count the number of elements that are multiples of n\n    multiple_count = rasp.SelectorWidth(multiple_selector).named(\"multiple_count\")\n\n    # Create a sequence of the input length\n    sequence_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"sequence_length\")\n\n    # Compare the count with the sequence length and output 1 if equal, 0 otherwise\n    result = rasp.Map(lambda x: 1 if x[0] == x[1] else 0, \n                      rasp.SequenceMap(lambda x, y: (x, y), multiple_count, sequence_length)).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_check_multiple_of_n(n: int = 2) -> rasp.SOp:\n    # Perform modulo operation on each element\n    mod_n = rasp.Map(lambda x: x % n, rasp.tokens).named(\"mod_n\")\n\n    # Create a selector for elements that are multiples of n\n    multiple_selector = rasp.Select(mod_n, rasp.Map(lambda x: 0, rasp.tokens), rasp.Comparison.EQ).named(\"multiple_selector\")\n\n    # Count how many elements are multiples of n\n    multiple_count = rasp.SelectorWidth(multiple_selector).named(\"multiple_count\")\n\n    # Create a sequence of the input length\n    sequence_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"sequence_length\")\n\n    # Check if all elements are multiples of n\n    all_multiples = rasp.Select(multiple_count, sequence_length, rasp.Comparison.EQ).named(\"all_multiples\")\n\n    # Convert boolean result to 1s and 0s\n    result = rasp.Map(lambda x: 1 if x else 0, all_multiples).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_check_multiple_of_n(n: int = 2) -> rasp.SOp:\n    # Create a sequence of n for each element in the input\n    n_sequence = rasp.Map(lambda x: n, rasp.tokens).named(\"n_sequence\")\n\n    # Perform modulo operation between input sequence and n_sequence\n    modulo_result = rasp.SequenceMap(lambda x, y: x % y, rasp.tokens, n_sequence).named(\"modulo_result\")\n\n    # Create a selector that checks if modulo result is 0\n    is_multiple_selector = rasp.Select(modulo_result, rasp.Map(lambda x: 0, rasp.tokens), rasp.Comparison.EQ).named(\"is_multiple_selector\")\n\n    # Count the number of elements that are multiples of n\n    multiple_count = rasp.SelectorWidth(is_multiple_selector).named(\"multiple_count\")\n\n    # Create a sequence of the input length for each position\n    sequence_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"sequence_length\")\n\n    # Compare the count with the sequence length\n    all_multiples = rasp.SequenceMap(lambda x, y: x == y, multiple_count, sequence_length).named(\"all_multiples\")\n\n    # Map the result to 1 (if all elements are multiples of n) or 0 (otherwise)\n    result = rasp.Map(lambda x: 1 if x else 0, all_multiples).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": "test_run_op timed out"
            }
        ],
        "make_swap_first_last": [
            {
                "generated rasp code": "def make_swap_first_last() -> rasp.SOp:\n    # Selector for the first element\n    first_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: 0, rasp.indices), rasp.Comparison.EQ).named(\"first_selector\")\n\n    # Selector for the last element\n    last_index = rasp.Map(lambda x: len(x) - 1, rasp.tokens).named(\"last_index\")\n    last_selector = rasp.Select(rasp.indices, last_index, rasp.Comparison.EQ).named(\"last_selector\")\n\n    # Selector for middle elements (neither first nor last)\n    middle_selector = ~(first_selector | last_selector).named(\"middle_selector\")\n\n    # Move last element to first position\n    first_swapped = rasp.Aggregate(first_selector, rasp.Aggregate(last_selector, rasp.tokens)).named(\"first_swapped\")\n\n    # Move first element to last position\n    last_swapped = rasp.Aggregate(last_selector, rasp.Aggregate(first_selector, rasp.tokens)).named(\"last_swapped\")\n\n    # Keep middle elements unchanged\n    middle_unchanged = rasp.Aggregate(middle_selector, rasp.tokens).named(\"middle_unchanged\")\n\n    # Combine swapped elements with unchanged middle elements\n    swapped_sequence = rasp.SequenceMap(\n        lambda x, y, z: x if x is not None else (y if y is not None else z),\n        first_swapped,\n        rasp.SequenceMap(\n            lambda x, y: x if x is not None else y,\n            middle_unchanged,\n            last_swapped\n        )\n    ).named(\"swapped_sequence\")\n\n    return swapped_sequence",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_swap_first_last() -> rasp.SOp:\n    # Create a helper sequence for the length of the input\n    seq_length = rasp.SelectorWidth(rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.TRUE)).named(\"seq_length\")\n    \n    # Create a helper sequence for the last index\n    last_index = rasp.Map(lambda x: x - 1, seq_length).named(\"last_index\")\n    \n    # Selector for the first element\n    first_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: 0, rasp.indices), rasp.Comparison.EQ).named(\"first_selector\")\n    \n    # Selector for the last element\n    last_selector = rasp.Select(rasp.indices, last_index, rasp.Comparison.EQ).named(\"last_selector\")\n    \n    # Selector for first and last elements combined\n    first_last_selector = (first_selector | last_selector).named(\"first_last_selector\")\n    \n    # Selector for middle elements (all except first and last)\n    middle_selector = ~first_last_selector.named(\"middle_selector\")\n    \n    # Swap first and last elements\n    swapped_ends = rasp.Aggregate(first_last_selector, rasp.SequenceMap(\n        lambda x, y: y if x == 0 else (y if x == last_index else None),\n        rasp.indices,\n        rasp.tokens\n    )).named(\"swapped_ends\")\n    \n    # Keep middle elements in place\n    middle_elements = rasp.Aggregate(middle_selector, rasp.tokens).named(\"middle_elements\")\n    \n    # Combine swapped ends and middle elements\n    result = rasp.SequenceMap(\n        lambda x, y: x if x is not None else y,\n        swapped_ends,\n        middle_elements\n    ).named(\"result\")\n    \n    return result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [3.5, 3.5, 3.5, 3.5, 3.5, 3.5]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_swap_first_last() -> rasp.SOp:\n    # Create a sequence of the input length\n    seq_length = rasp.Map(lambda x: len(x), rasp.tokens).named(\"seq_length\")\n\n    # Selector for sequences with more than one element\n    more_than_one = rasp.Select(seq_length, rasp.Map(lambda x: 1, rasp.indices), rasp.Comparison.GT).named(\"more_than_one\")\n\n    # Selector for the first element\n    first_elem = rasp.Select(rasp.indices, rasp.Map(lambda x: 0, rasp.indices), rasp.Comparison.EQ).named(\"first_elem\")\n\n    # Selector for the last element\n    last_elem = rasp.Select(rasp.indices, rasp.Map(lambda x: x - 1, seq_length), rasp.Comparison.EQ).named(\"last_elem\")\n\n    # Selector for middle elements (neither first nor last)\n    middle_elems = ~(first_elem | last_elem).named(\"middle_elems\")\n\n    # Swap first and last elements\n    swapped_first = rasp.Aggregate(last_elem, rasp.tokens).named(\"swapped_first\")\n    swapped_last = rasp.Aggregate(first_elem, rasp.tokens).named(\"swapped_last\")\n\n    # Keep middle elements unchanged\n    unchanged_middle = rasp.Aggregate(middle_elems, rasp.tokens).named(\"unchanged_middle\")\n\n    # Combine swapped and unchanged elements\n    swapped_sequence = rasp.SequenceMap(\n        lambda x, y, z: x if x is not None else (y if y is not None else z),\n        swapped_first,\n        unchanged_middle,\n        swapped_last\n    ).named(\"swapped_sequence\")\n\n    # Final result: apply swapping only if sequence has more than one element\n    result = rasp.SequenceMap(\n        lambda cond, swapped, original: swapped if cond else original,\n        more_than_one,\n        swapped_sequence,\n        rasp.tokens\n    ).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": "SequenceMap.__init__() takes 4 positional arguments but 5 were given"
            },
            {
                "generated rasp code": "def make_swap_first_last() -> rasp.SOp:\n    # Get the length of the sequence\n    seq_length = rasp.SelectorWidth(rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.TRUE)).named(\"seq_length\")\n    \n    # Create a selector for the first element\n    first_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: 0, rasp.indices), rasp.Comparison.EQ).named(\"first_selector\")\n    \n    # Create a selector for the last element\n    last_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: x-1, seq_length), rasp.Comparison.EQ).named(\"last_selector\")\n    \n    # Combine first and last selectors\n    first_last_selector = (first_selector | last_selector).named(\"first_last_selector\")\n    \n    # Create a selector for middle elements (all except first and last)\n    middle_selector = (~first_last_selector).named(\"middle_selector\")\n    \n    # Swap first and last elements\n    swapped = rasp.Aggregate(first_selector, rasp.Aggregate(last_selector, rasp.tokens)).named(\"swapped\")\n    \n    # Keep middle elements unchanged\n    unchanged = rasp.Aggregate(middle_selector, rasp.tokens).named(\"unchanged\")\n    \n    # Combine swapped and unchanged parts\n    result = rasp.SequenceMap(lambda x, y: x if x is not None else y, swapped, unchanged).named(\"result\")\n    \n    # Handle edge cases (length 1 and 2)\n    return rasp.SequenceMap(\n        lambda length, res: res if length > 1 else rasp.tokens,\n        seq_length,\n        result\n    ).named(\"final_result\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [4.0, 4.0, 4.0, 4.0, 4.0, 4.0]. (1.0 error rate)"
            },
            {
                "generated rasp code": "def make_swap_first_last() -> rasp.SOp:\n    # Selector for the first element\n    first_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: 0, rasp.indices), rasp.Comparison.EQ).named(\"first_selector\")\n    \n    # Selector for the last element\n    last_selector = rasp.Select(rasp.indices, rasp.Map(lambda x: len(x) - 1, rasp.tokens), rasp.Comparison.EQ).named(\"last_selector\")\n    \n    # Selector for the first and last elements combined\n    first_last_selector = (first_selector | last_selector).named(\"first_last_selector\")\n    \n    # Selector for all elements except first and last\n    middle_selector = (~first_last_selector).named(\"middle_selector\")\n    \n    # Swap first and last elements\n    swapped = rasp.Aggregate(first_last_selector, rasp.SequenceMap(\n        lambda x, y: y, rasp.tokens, rasp.Aggregate(~first_last_selector, rasp.tokens)\n    )).named(\"swapped\")\n    \n    # Keep middle elements unchanged\n    unchanged = rasp.Aggregate(middle_selector, rasp.tokens).named(\"unchanged\")\n    \n    # Combine swapped and unchanged elements\n    result = rasp.SequenceMap(lambda x, y: x if x is not None else y, swapped, unchanged).named(\"result\")\n    \n    # Selector for sequences of length 1\n    length_one_selector = rasp.Select(\n        rasp.Map(lambda x: len(x), rasp.tokens), \n        rasp.Map(lambda x: 1, rasp.indices), \n        rasp.Comparison.EQ\n    ).named(\"length_one_selector\")\n    \n    # Final result: original sequence if length is 1, otherwise swapped\n    final_result = rasp.SequenceMap(\n        lambda x, y: y if x else x, \n        rasp.Aggregate(length_one_selector, rasp.tokens), \n        result\n    ).named(\"final_result\")\n    \n    return final_result",
                "failure stage": 0,
                "error": "test_run_op timed out"
            }
        ],
        "make_test_at_least_two_equal": [
            {
                "generated rasp code": "def make_test_at_least_two_equal() -> rasp.SOp:\n    # Selector that creates a comparison matrix where each element is compared to every other element for equality.\n    eq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.EQ).named(\"eq_selector\")\n\n    # Count the number of elements each element is equal to (including itself).\n    eq_count = rasp.SelectorWidth(eq_selector).named(\"eq_count\")\n\n    # Create a Map to check if the count is greater than 1 (at least two equal elements).\n    has_equal = rasp.Map(lambda x: 1 if x > 1 else 0, eq_count).named(\"has_equal\")\n\n    # Create a selector that selects all elements.\n    select_all = rasp.Select(rasp.tokens, rasp.tokens, lambda x, y: True).named(\"select_all\")\n\n    # Use Aggregate to broadcast the maximum value (0 or 1) across the entire sequence.\n    result = rasp.Aggregate(select_all, has_equal).named(\"result\")\n\n    return result",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]. (0.6 error rate)"
            }
        ],
        "make_reflect": [],
        "make_check_square": [
            {
                "generated rasp code": "def make_check_square(max_check=10):\n    # Create a sequence of integers from 0 to max_check\n    int_sequence = rasp.Map(lambda x: x, rasp.indices).named(\"int_sequence\")\n    \n    # Square the integers\n    squared_sequence = rasp.Map(lambda x: x * x, int_sequence).named(\"squared_sequence\")\n    \n    # Create a selector that checks if each input token is equal to any squared number\n    is_square_selector = rasp.Select(rasp.tokens, squared_sequence, rasp.Comparison.EQ).named(\"is_square_selector\")\n    \n    # Count how many times each input token matches a squared number\n    match_count = rasp.SelectorWidth(is_square_selector).named(\"match_count\")\n    \n    # Convert the count to 1 if it's greater than 0 (indicating a square number), and 0 otherwise\n    is_square = rasp.Map(lambda x: 1 if x > 0 else 0, match_count).named(\"is_square\")\n    \n    return is_square",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0, 1, 1, 0, 0, 0]. (0.757 error rate)"
            },
            {
                "generated rasp code": "def make_check_square() -> rasp.SOp:\n    # Create a sequence of integers from 0 to 10\n    int_sequence = rasp.Map(lambda x: x, rasp.indices).named(\"int_sequence\")\n    \n    # Create a sequence of perfect squares (0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100)\n    square_sequence = rasp.Map(lambda x: x * x, int_sequence).named(\"square_sequence\")\n    \n    # Create a selector that compares each input token with the square sequence\n    is_square_selector = rasp.Select(rasp.tokens, square_sequence, rasp.Comparison.EQ).named(\"is_square_selector\")\n    \n    # Count how many matches each input element has with the perfect squares\n    match_count = rasp.SelectorWidth(is_square_selector).named(\"match_count\")\n    \n    # Convert the count to 1 if it's greater than 0 (indicating a square number), and 0 otherwise\n    is_square = rasp.Map(lambda x: 1 if x > 0 else 0, match_count).named(\"is_square\")\n    \n    return is_square",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0, 1, 1, 0, 0, 0]. (0.757 error rate)"
            },
            {
                "generated rasp code": "def make_check_square() -> rasp.SOp:\n    # Create a sequence of indices\n    indices = rasp.indices\n\n    # Create a sequence of squares up to each input element\n    squares = rasp.SequenceMap(lambda x, y: y * y, indices, rasp.tokens).named(\"squares\")\n\n    # Compare each input element with its corresponding sequence of squares\n    is_square_selector = rasp.Select(squares, rasp.tokens, rasp.Comparison.EQ).named(\"is_square_selector\")\n\n    # Count matches (will be 1 for square numbers, 0 for non-squares)\n    square_count = rasp.SelectorWidth(is_square_selector).named(\"square_count\")\n\n    # Convert count to 1 (if count > 0) or 0 (if count == 0)\n    is_square = rasp.Map(lambda x: 1 if x > 0 else 0, square_count).named(\"is_square\")\n\n    return is_square",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0, 0, 0, 1, 0, 1]. (0.399 error rate)"
            },
            {
                "generated rasp code": "def make_check_square(max_sqrt=10):\n    # Create a sequence of integers from 0 to max_sqrt\n    integers = rasp.Map(lambda x: x, rasp.indices).named(\"integers\")\n    \n    # Create a sequence of squares\n    squares = rasp.Map(lambda x: x * x, integers).named(\"squares\")\n    \n    # Create a selector that compares each input token with each square\n    is_square_selector = rasp.Select(rasp.tokens, squares, rasp.Comparison.EQ).named(\"is_square_selector\")\n    \n    # Count how many times each input token matches a square number\n    square_match_count = rasp.SelectorWidth(is_square_selector).named(\"square_match_count\")\n    \n    # Convert the count to 1 if it's greater than 0 (indicating a square number), and 0 otherwise\n    is_square = rasp.Map(lambda x: 1 if x > 0 else 0, square_match_count).named(\"is_square\")\n    \n    return is_square",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0, 1, 1, 0, 0, 0]. (0.757 error rate)"
            },
            {
                "generated rasp code": "def make_check_square(max_check=10):\n    # Create a sequence of integers from 0 to max_check\n    int_sequence = rasp.Map(lambda x: x, rasp.indices).named(\"int_sequence\")\n    \n    # Create a sequence of perfect squares\n    squares = rasp.Map(lambda x: x * x, int_sequence).named(\"squares\")\n    \n    # Create a selector that checks if each input element is equal to any perfect square\n    is_square_selector = rasp.Select(rasp.tokens, squares, rasp.Comparison.EQ).named(\"is_square_selector\")\n    \n    # Count how many matches each input element has with perfect squares\n    match_count = rasp.SelectorWidth(is_square_selector).named(\"match_count\")\n    \n    # Convert count to 1 if greater than 0, else 0\n    is_square = rasp.Map(lambda x: 1 if x > 0 else 0, match_count).named(\"is_square\")\n    \n    return is_square",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0, 1, 1, 0, 0, 0]. (0.757 error rate)"
            }
        ],
        "make_count_prime_factors": [
            {
                "generated rasp code": "def make_count_prime_factors(max_iterations=20):\n    def count_prime_factors(x):\n        # Initialize a sequence of potential factors\n        factors = rasp.Map(lambda _: 2, rasp.indices)\n        \n        # Initialize the count of prime factors and the current number\n        count = rasp.Map(lambda _: 0, rasp.indices)\n        current = rasp.Map(lambda _: x, rasp.indices)\n        \n        for _ in range(max_iterations):\n            # Check if the current factor divides the number\n            is_factor = rasp.Select(current, factors, lambda a, b: a % b == 0)\n            \n            # Update the count if it's a factor\n            count = rasp.SequenceMap(lambda c, f: c + f, count, rasp.SelectorWidth(is_factor))\n            \n            # Update the current number by dividing by the factor if it's divisible\n            current = rasp.SequenceMap(\n                lambda a, b, f: a // b if f else a,\n                current,\n                factors,\n                rasp.SelectorWidth(is_factor)\n            )\n            \n            # Increment the factor\n            factors = rasp.Map(lambda f: f + 1, factors)\n        \n        # If the final current number is greater than 1, it's a prime factor itself\n        final_check = rasp.Select(current, rasp.Map(lambda _: 1, rasp.indices), rasp.Comparison.GT)\n        count = rasp.SequenceMap(lambda c, f: c + f, count, rasp.SelectorWidth(final_check))\n        \n        return count\n\n    return rasp.Map(count_prime_factors, rasp.tokens)",
                "failure stage": 0,
                "error": "test_run_op timed out"
            },
            {
                "generated rasp code": "def make_count_prime_factors() -> rasp.SOp:\n    def count_prime_factors(n):\n        if n < 2:\n            return 0\n        count = 0\n        d = 2\n        while n > 1:\n            while n % d == 0:\n                count += 1\n                n //= d\n            d += 1\n            if d * d > n:\n                if n > 1:\n                    count += 1\n                break\n        return count\n\n    return rasp.Map(lambda x: count_prime_factors(x), rasp.tokens).named(\"count_prime_factors\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [1, 3, 1, 0, 1, 2]. (0.761 error rate)"
            },
            {
                "generated rasp code": "def make_count_prime_factors(max_factor=10):\n    def count_factors(n, factor=2, count=0):\n        if factor > max_factor or factor * factor > n:\n            return count + (n > 1)\n        if n % factor == 0:\n            return count_factors(n // factor, factor, count + 1)\n        return count_factors(n, factor + 1, count)\n\n    return rasp.Map(lambda x: count_factors(x), rasp.tokens).named(\"count_prime_factors\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [1, 3, 1, 0, 1, 2]. (0.761 error rate)"
            },
            {
                "generated rasp code": "def make_count_prime_factors() -> rasp.SOp:\n    def count_prime_factors(n):\n        if n < 2:\n            return 0\n        count = 0\n        for i in range(2, int(n**0.5) + 1):\n            while n % i == 0:\n                count += 1\n                n //= i\n        if n > 1:\n            count += 1\n        return count\n\n    # Apply the count_prime_factors function to each element in the sequence\n    return rasp.Map(count_prime_factors, rasp.tokens).named(\"count_prime_factors\")",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [1, 3, 1, 0, 1, 2]. (0.761 error rate)"
            }
        ],
        "make_zero_if_less_than_previous": [
            {
                "generated rasp code": "def make_zero_if_less_than_previous() -> rasp.SOp:\n    # Create a selector that compares each element with the next\n    gt_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.GT).named(\"gt_selector\")\n\n    # Shift the selector by one position\n    shifted_selector = rasp.Aggregate(\n        rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y + 1),\n        gt_selector\n    ).named(\"shifted_selector\")\n\n    # Use the shifted selector to choose between the original element and zero\n    zero_if_less = rasp.SequenceMap(\n        lambda x, y: x if y else 0,\n        rasp.tokens,\n        shifted_selector\n    ).named(\"zero_if_less\")\n\n    # Ensure the first element is always kept\n    result = rasp.SequenceMap(\n        lambda x, y: y if x > 0 else x,\n        rasp.indices,\n        zero_if_less\n    ).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_zero_if_less_than_previous() -> rasp.SOp:\n    # Create a selector that compares each element with the previous element\n    lt_selector = rasp.Select(rasp.tokens[:-1], rasp.tokens[1:], rasp.Comparison.LT).named(\"lt_selector\")\n\n    # Shift the selector by one position to align with current elements\n    shifted_selector = rasp.Aggregate(\n        rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y + 1),\n        lt_selector\n    ).named(\"shifted_selector\")\n\n    # Create a selector for the first element (always True as it has no previous element)\n    first_element_selector = rasp.Select(\n        rasp.indices, rasp.Map(lambda x: 0, rasp.indices), rasp.Comparison.EQ\n    ).named(\"first_element_selector\")\n\n    # Combine the selectors\n    combined_selector = (first_element_selector | shifted_selector).named(\"combined_selector\")\n\n    # Create the final sequence\n    result = rasp.SequenceMap(\n        lambda x, y: x if y else 0,\n        rasp.tokens,\n        combined_selector\n    ).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": "'TokensType' object is not subscriptable"
            },
            {
                "generated rasp code": "def make_zero_if_less_than_previous() -> rasp.SOp:\n    # Create a selector that compares each element with its previous element\n    lt_selector = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.LT).named(\"lt_selector\")\n\n    # Shift the selector by one position to align it with the current elements\n    shifted_selector = rasp.Aggregate(\n        rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.EQ),\n        lt_selector\n    ).named(\"shifted_selector\")\n\n    # Create the final sequence: set to 0 if less than previous, else keep original value\n    result = rasp.SequenceMap(\n        lambda sel, token: 0 if sel else token,\n        shifted_selector,\n        rasp.tokens\n    ).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_zero_if_less_than_previous() -> rasp.SOp:\n    # Create a selector that compares each element with the previous element\n    less_than_prev_selector = rasp.Select(\n        rasp.tokens, \n        rasp.shift(rasp.tokens, offset=1, default=float('-inf')),\n        rasp.Comparison.LT\n    ).named(\"less_than_prev_selector\")\n\n    # Shift the selector by one position to align with current elements\n    shifted_selector = rasp.Aggregate(\n        rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y + 1),\n        less_than_prev_selector,\n        default=None\n    ).named(\"shifted_selector\")\n\n    # Create the final sequence\n    result = rasp.SequenceMap(\n        lambda x, y: 0 if y else x,\n        rasp.tokens,\n        shifted_selector\n    ).named(\"result\")\n\n    return result\n\n# Helper function to shift sequence\ndef shift(sop: rasp.SOp, offset: int, default: Any) -> rasp.SOp:\n    return rasp.Aggregate(\n        rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y + offset),\n        sop,\n        default=default\n    )",
                "failure stage": 0,
                "error": "name 'Any' is not defined"
            },
            {
                "generated rasp code": "def make_zero_if_less_than_previous() -> rasp.SOp:\n    # Create a selector that compares each element with the previous element\n    geq_selector = rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.GEQ).named(\"geq_selector\")\n\n    # Shift the selector by one position to align with current elements\n    shifted_selector = rasp.Aggregate(\n        rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == y + 1),\n        geq_selector\n    ).named(\"shifted_selector\")\n\n    # Set the first element of the shifted selector to True\n    first_element_selector = rasp.Select(rasp.indices, rasp.indices, lambda x, y: x == 0).named(\"first_element_selector\")\n    final_selector = rasp.selector_or(shifted_selector, first_element_selector).named(\"final_selector\")\n\n    # Apply the selector to keep original values or set to zero\n    result = rasp.SequenceMap(\n        lambda x, y: x if y else 0,\n        rasp.tokens,\n        final_selector\n    ).named(\"result\")\n\n    return result",
                "failure stage": 0,
                "error": ""
            }
        ],
        "make_element_subtract_constant": [],
        "make_check_prime": [
            {
                "generated rasp code": "def make_check_prime(max_divisor=100):\n    # Create a sequence of potential divisors from 2 to max_divisor\n    divisors = rasp.Map(lambda x: x + 2, rasp.indices).named(\"divisors\")\n    \n    # Create a selector for numbers less than or equal to max_divisor\n    in_range_selector = rasp.Select(rasp.tokens, rasp.Map(lambda x: max_divisor, rasp.tokens), rasp.Comparison.LEQ).named(\"in_range_selector\")\n    \n    # Check divisibility for each number with each potential divisor\n    divisibility_selector = rasp.Select(\n        rasp.SequenceMap(lambda x, y: x % y, rasp.tokens, divisors),\n        rasp.Map(lambda x: 0, rasp.tokens),\n        rasp.Comparison.EQ\n    ).named(\"divisibility_selector\")\n    \n    # Count the number of divisors for each number\n    divisor_count = rasp.SelectorWidth(divisibility_selector & in_range_selector).named(\"divisor_count\")\n    \n    # A number is prime if it has exactly 2 divisors (1 and itself)\n    is_prime = rasp.SequenceMap(\n        lambda count, num: 1 if (count == 2 and num > 1) else 0,\n        divisor_count,\n        rasp.tokens\n    ).named(\"is_prime\")\n    \n    # Handle edge cases: numbers greater than max_divisor that might be prime\n    possible_large_prime = rasp.SequenceMap(\n        lambda in_range, num: 1 if (not in_range and num > max_divisor) else 0,\n        in_range_selector,\n        rasp.tokens\n    ).named(\"possible_large_prime\")\n    \n    # Combine results: a number is considered prime if it's determined to be prime\n    # or if it's a possible large prime (beyond our divisor check range)\n    final_result = rasp.SequenceMap(\n        lambda x, y: 1 if (x == 1 or y == 1) else 0,\n        is_prime,\n        possible_large_prime\n    ).named(\"final_result\")\n    \n    return final_result",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_check_prime(max_divisor=100):\n    # Create a sequence of potential divisors from 2 to max_divisor\n    divisors = rasp.Map(lambda x: x + 2, rasp.indices).named(\"divisors\")\n    \n    # Create a selector for divisibility check\n    divisibility_selector = rasp.Select(\n        rasp.tokens,\n        divisors,\n        lambda x, y: (y <= x) and (x % y == 0)\n    ).named(\"divisibility_selector\")\n    \n    # Count the number of divisors for each number\n    divisor_count = rasp.SelectorWidth(divisibility_selector).named(\"divisor_count\")\n    \n    # Select numbers with exactly one divisor in our range (prime numbers)\n    prime_selector = rasp.Select(divisor_count, rasp.tokens, lambda x, y: x == 1 and y > 1).named(\"prime_selector\")\n    \n    # Convert selector to 1s and 0s\n    prime_check = rasp.Map(lambda x: 1 if x else 0, prime_selector).named(\"prime_check\")\n    \n    return prime_check",
                "failure stage": 0,
                "error": ""
            },
            {
                "generated rasp code": "def make_check_prime(max_divisor=100):\n    # Create a sequence of potential divisors from 2 to max_divisor\n    divisors = rasp.Map(lambda x: x + 2, rasp.indices).named(\"divisors\")\n    \n    # Create a selector for numbers less than or equal to max_divisor\n    in_range_selector = rasp.Select(rasp.tokens, rasp.Map(lambda x: max_divisor, rasp.tokens), rasp.Comparison.LEQ).named(\"in_range_selector\")\n    \n    # Perform modulo operation to check divisibility\n    remainders = rasp.SequenceMap(lambda x, y: x % y if y <= x else 1, rasp.tokens, divisors).named(\"remainders\")\n    \n    # Select where remainder is 0 (divisible)\n    divisible_selector = rasp.Select(remainders, rasp.Map(lambda x: 0, rasp.tokens), rasp.Comparison.EQ).named(\"divisible_selector\")\n    \n    # Count number of divisors\n    divisor_count = rasp.SelectorWidth(divisible_selector).named(\"divisor_count\")\n    \n    # Convert count to prime (1) or not prime (0)\n    # Numbers with exactly 0 divisors in our range (excluding 1 and itself) are prime\n    is_prime = rasp.Map(lambda x: 1 if x == 0 else 0, divisor_count).named(\"is_prime\")\n    \n    # Handle edge cases: 1 is not prime, 2 is prime, and numbers > max_divisor are assumed prime\n    edge_cases = rasp.SequenceMap(\n        lambda x, y: 1 if x == 2 or (x > max_divisor and x != 1) else y,\n        rasp.tokens,\n        is_prime\n    ).named(\"edge_cases\")\n    \n    return edge_cases\n\n# Usage:\n# check_prime = make_check_prime()\n# result = check_prime([2, 4, 5, 7, 9, 11, 97, 100, 101])\n# Expected output: [1, 0, 1, 1, 0, 1, 1, 0, 1]",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [1, 1, 1, 1, 1, 1]. (0.808 error rate)"
            },
            {
                "generated rasp code": "def make_check_prime(max_divisor=100):\n    # Create a sequence of potential divisors from 2 to max_divisor\n    divisors = rasp.Map(lambda x: x + 2, rasp.indices).named(\"divisors\")\n    \n    # Create a selector for divisibility check\n    is_divisible = rasp.Select(rasp.tokens, divisors, lambda x, y: x % y == 0 if x > 1 else False).named(\"is_divisible\")\n    \n    # Count the number of divisors\n    divisor_count = rasp.SelectorWidth(is_divisible).named(\"divisor_count\")\n    \n    # Check if the number is prime (exactly 2 divisors) and greater than 1\n    is_prime = rasp.SequenceMap(\n        lambda x, y: 1 if x == 2 and y > 1 else 0,\n        divisor_count,\n        rasp.tokens\n    ).named(\"is_prime\")\n    \n    # Handle numbers larger than max_divisor\n    is_large = rasp.Select(rasp.tokens, rasp.Map(lambda x: max_divisor, rasp.tokens), rasp.Comparison.GT).named(\"is_large\")\n    large_prime_check = rasp.Map(\n        lambda x: 1 if x > max_divisor and all(x % i != 0 for i in range(2, int(x**0.5) + 1)) else 0,\n        rasp.tokens\n    ).named(\"large_prime_check\")\n    \n    # Combine results for small and large numbers\n    final_result = rasp.SequenceMap(\n        lambda small, large: large if small == 0 else small,\n        is_prime,\n        large_prime_check\n    ).named(\"final_result\")\n    \n    return final_result\n\n# Usage\ncheck_prime = make_check_prime()",
                "failure stage": 1,
                "error": "the rasp program doesn't produce the correct output (for input [3,8,2,1,5,4]) --> [0, 0, 1, 0, 0, 0]. (0.87 error rate)"
            },
            {
                "generated rasp code": "def make_check_prime(max_sequence_length=100):\n    # Create a sequence of potential divisors from 2 to max_sequence_length\n    divisors = rasp.Map(lambda x: x + 2, rasp.indices).named(\"divisors\")\n    \n    # Create a selector for divisibility check\n    is_divisible = rasp.Select(rasp.tokens, divisors, lambda x, y: x % y == 0 if x > 1 and y < x else False).named(\"is_divisible\")\n    \n    # Count the number of divisors\n    divisor_count = rasp.SelectorWidth(is_divisible).named(\"divisor_count\")\n    \n    # Convert count to prime indicator (1 if prime, 0 if not)\n    # A number is prime if it has exactly 2 divisors (1 and itself)\n    is_prime = rasp.Map(lambda x: 1 if x == 2 else 0, divisor_count).named(\"is_prime\")\n    \n    # Handle edge cases: numbers less than 2 are not prime\n    less_than_two = rasp.Select(rasp.tokens, rasp.Map(lambda x: 2, rasp.tokens), rasp.Comparison.LT).named(\"less_than_two\")\n    \n    # Combine results: use 0 for numbers less than 2, otherwise use is_prime result\n    final_result = rasp.SequenceMap(\n        lambda x, y: 0 if x else y,\n        less_than_two,\n        is_prime\n    ).named(\"final_result\")\n    \n    return final_result\n\n# Usage\ncheck_prime = make_check_prime()",
                "failure stage": 0,
                "error": ""
            }
        ],
        "make_index_parity": [
            {
                "generated rasp code": "def make_index_parity() -> rasp.SOp:\n    # Use Map to apply a parity-checking function to each index\n    return rasp.Map(\n        # Lambda function to determine parity:\n        # If index % 2 == 0, it's even (return 0), otherwise it's odd (return 1)\n        lambda x: 0 if x % 2 == 0 else 1,\n        # Use rasp.indices to get the index of each element\n        rasp.indices\n    ).named(\"index_parity\")",
                "failure stage": 3,
                "error": "'tokens'"
            },
            {
                "generated rasp code": "def make_index_parity() -> rasp.SOp:\n    # Use rasp.Map to apply a parity-checking function to each index\n    return rasp.Map(\n        # Lambda function to determine parity:\n        # If index % 2 == 0, it's even (return 0), otherwise it's odd (return 1)\n        lambda x: 0 if x % 2 == 0 else 1,\n        # Use rasp.indices to get the index of each element\n        rasp.indices\n    ).named(\"index_parity\")",
                "failure stage": 3,
                "error": "'tokens'"
            },
            {
                "generated rasp code": "def make_index_parity() -> rasp.SOp:\n    # Create a Map operation that calculates the parity of each index\n    # 0 for even indices (including 0), 1 for odd indices\n    index_parity = rasp.Map(lambda x: x % 2, rasp.indices).named(\"index_parity\")\n    \n    return index_parity",
                "failure stage": 3,
                "error": "'tokens'"
            },
            {
                "generated rasp code": "def make_index_parity() -> rasp.SOp:\n    # Use rasp.Map to apply a parity function to each index\n    # The lambda function x % 2 returns 0 for even indices and 1 for odd indices\n    return rasp.Map(lambda x: x % 2, rasp.indices).named(\"index_parity\")",
                "failure stage": 3,
                "error": "'tokens'"
            },
            {
                "generated rasp code": "def make_index_parity() -> rasp.SOp:\n    # Use Map to apply a parity calculation to each index\n    # The lambda function uses modulo 2 to determine if the index is even (0) or odd (1)\n    return rasp.Map(lambda x: x % 2, rasp.indices).named(\"index_parity\")",
                "failure stage": 3,
                "error": "'tokens'"
            }
        ]
    }
}